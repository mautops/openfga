# 第 6 章：关系元组管理

让授权模型落地：从数据操作到高级特性

---

第一次写关系元组时，我犯了个低级错误——忘记加类型前缀，写成了 `"object": "report"` 而不是 `"object": "document:report"`。结果 API 返回了一个模糊的错误信息，我花了半小时才找到问题。

这种小坑，你可能也会遇到。

本章将带你掌握关系元组的管理——从基本操作到批量处理，从上下文元组到条件关系。读完本章，你不仅能熟练操作关系元组，更能理解如何在生产环境中高效管理权限数据。

## 6.1 关系元组基础

授权模型定义了"可以有什么关系"，关系元组则记录了"实际存在哪些关系"。如果说授权模型是建筑蓝图，关系元组就是构成建筑的砖块。

### 元组的本质

关系元组表达的是"谁与什么有什么关系"。它包含三个核心字段：

```json
{
  "user": "user:alice",
  "relation": "owner",
  "object": "document:report"
}
```

这表示"用户 alice 是文档 report 的所有者"。

**字段说明**：

- `user` - 关系的主体，可以是用户、组或其他实体
- `relation` - 关系类型，必须在授权模型中定义
- `object` - 关系的对象，格式为 `<type>:<id>`

> **踩坑经验**：`object` 字段必须包含类型前缀。我见过不少人忘记这个，导致 API 调用失败。记住：永远是 `document:123`，不是 `123`。

### 特殊的 user 格式

`user` 字段有多种格式，这是 OpenFGA 灵活性的体现：

**直接用户**：
```json
{"user": "user:alice", "relation": "viewer", "object": "document:1"}
```

**组成员**（Userset）：
```json
{"user": "team:engineering#member", "relation": "editor", "object": "document:1"}
```

这表示"engineering 团队的所有成员"拥有编辑权限。注意 `#member` 的用法——这是通过团队的成员关系获得权限。

**公共访问**：
```json
{"user": "user:*", "relation": "viewer", "object": "document:public"}
```

`user:*` 表示所有用户，用于实现公开访问。

### 元组与模型的关系

关系元组必须符合授权模型的约束。如果模型定义：

```openfga
type document
  relations
    define owner: [user]
    define editor: [user, team#member]
```

那么：
- ✅ `{user: "user:alice", relation: "owner", object: "document:1"}` - 有效
- ✅ `{user: "team:eng#member", relation: "editor", object: "document:1"}` - 有效
- ❌ `{user: "team:eng#member", relation: "owner", object: "document:1"}` - 无效（owner 只接受 user）

OpenFGA 会在写入时验证这些约束，确保数据一致性。

## 6.2 基本操作：增删改查

关系元组的操作很直观——添加、删除、读取。OpenFGA 提供了多种方式来执行这些操作。

### 写入元组

使用 HTTP API 写入元组：

```bash
curl -X POST $FGA_API_URL/stores/$STORE_ID/write \
  -H "Content-Type: application/json" \
  -d '{
    "writes": {
      "tuple_keys": [
        {"user": "user:alice", "relation": "owner", "object": "document:report"}
      ]
    }
  }'
```

使用 Python SDK 更简洁：

```python
body = ClientWriteRequest(
    writes=[
        ClientTuple(
            user="user:alice",
            relation="owner",
            object="document:report"
        )
    ]
)
await fga_client.write(body, options)
```

**完整代码示例**：参考 [Python SDK 集成](../integrates/09.agentscope-mcp-integration/)

> **实践建议**：在生产环境中，始终指定 `authorization_model_id`。这确保元组与特定模型版本关联，避免模型更新时的不一致问题。

### 删除元组

删除操作使用相同的 API，但在 `deletes` 字段中指定：

```python
body = ClientWriteRequest(
    deletes=[
        ClientTuple(
            user="user:alice",
            relation="owner",
            object="document:report"
        )
    ]
)
await fga_client.write(body, options)
```

删除操作是幂等的——删除不存在的元组不会报错。这个特性在批量操作时很有用。

### 读取元组

Read API 支持灵活的筛选条件：

```python
# 读取特定对象的所有关系
response = await fga_client.read({
    "tuple_key": {"object": "document:report"}
})

# 读取特定用户的所有关系
response = await fga_client.read({
    "tuple_key": {"user": "user:alice"}
})
```

Read API 支持分页，使用 `continuation_token` 处理大量数据：

```python
all_tuples = []
token = None

while True:
    response = await fga_client.read({
        "page_size": 100,
        "continuation_token": token
    })
    all_tuples.extend(response.tuples)
    token = response.continuation_token
    if not token:
        break
```

### 更新元组

OpenFGA 没有直接的"更新"操作——元组由 user、relation、object 唯一确定。要更新，需要先删除旧元组，再添加新元组。

**事务性更新**（推荐）：

```python
# 在同一请求中删除和添加，保证原子性
body = ClientWriteRequest(
    deletes=[
        ClientTuple(user="user:alice", relation="viewer", object="document:1")
    ],
    writes=[
        ClientTuple(user="user:alice", relation="editor", object="document:1")
    ]
)
await fga_client.write(body, options)
```

这种方式确保操作的原子性——要么全部成功，要么全部失败。

## 6.3 批量操作与数据迁移

在生产环境中，批量操作是常态——初始化权限、迁移数据、批量更新。批量操作不仅更高效，还能保证事务性。

### 批量写入的优势

我在一个项目中需要导入 10 万条权限数据。如果逐条写入，需要 10 万次 API 调用，耗时超过 1 小时。改用批量写入后，只需要 200 次调用（每批 500 条），5 分钟就完成了。

批量操作的优势：
- **性能提升** - 减少网络往返，提高效率
- **事务保证** - 同一批操作在同一事务中执行
- **错误处理** - 统一处理和重试

### 分批处理策略

单次请求不要太大（建议每批 100-500 条），避免超时和内存问题：

```python
async def batch_write(tuples, batch_size=100):
    for i in range(0, len(tuples), batch_size):
        batch = tuples[i:i + batch_size]
        body = ClientWriteRequest(writes=batch)
        await fga_client.write(body, options)
        print(f"已处理 {min(i + batch_size, len(tuples))}/{len(tuples)}")
```

**完整批量导入工具**：参考 [数据迁移脚本](../integrates/08.go-microservice/scripts/)

### 数据导入导出

导出关系元组用于备份或迁移：

```python
async def export_tuples():
    all_tuples = []
    token = None

    while True:
        response = await fga_client.read({
            "page_size": 100,
            "continuation_token": token
        })
        all_tuples.extend(response.tuples)
        token = response.continuation_token
        if not token:
            break

    return all_tuples
```

导入时记得验证数据：

```python
async def import_tuples(tuples):
    # 验证格式
    for t in tuples:
        if ":" not in t.object:
            raise ValueError(f"无效的 object 格式: {t.object}")

    # 去重
    unique = {f"{t.user}:{t.relation}:{t.object}": t for t in tuples}

    # 批量写入
    await batch_write(list(unique.values()))
```

> **踩坑经验**：导入前一定要去重！我曾经因为没去重，导致同一个关系被写入多次，虽然不会报错，但浪费了存储空间。

## 6.4 上下文元组：动态授权的利器

上下文元组是 OpenFGA 的一个强大特性——它们只在请求期间有效，不会持久化。这让授权决策可以基于动态的上下文信息。

### 为什么需要上下文元组

有些权限依赖于动态上下文——当前组织、时间窗口、IP 地址等。这些信息变化频繁，不适合作为持久化的关系元组。

比如在多租户系统中，用户的权限取决于当前选择的组织。用户 Alice 可能在组织 A 中是管理员，但在组织 B 中只是普通成员。这种上下文信息最适合用上下文元组来表达。

### 组织上下文示例

假设授权模型定义：

```openfga
type organization
  relations
    define member: [user]

type project
  relations
    define viewer: [organization#member]
```

在权限检查时，通过上下文元组提供组织成员关系：

```python
check_request = {
    "user": "user:alice",
    "relation": "viewer",
    "object": "project:X",
    "contextual_tuples": [
        {
            "user": "user:alice",
            "relation": "member",
            "object": "organization:A"
        }
    ]
}
response = await fga_client.check(check_request)
```

这样，Alice 在组织 A 的上下文中可以查看项目 X，但在其他组织上下文中则不行。

### JWT Token 集成

实际应用中，上下文信息通常来自 JWT token：

```python
def extract_context(token):
    payload = decode_jwt(token)
    return {
        "user_id": f"user:{payload['sub']}",
        "org_id": f"organization:{payload['org_id']}"
    }

async def check_with_jwt(token, resource, relation):
    ctx = extract_context(token)

    check_request = {
        "user": ctx["user_id"],
        "relation": relation,
        "object": resource,
        "contextual_tuples": [
            {
                "user": ctx["user_id"],
                "relation": "member",
                "object": ctx["org_id"]
            }
        ]
    }

    response = await fga_client.check(check_request)
    return response.allowed
```

**完整 JWT 集成示例**：参考 [Go 微服务集成](../integrates/08.go-microservice/internal/middleware/)

> **注意事项**：上下文元组不会持久化，每次请求都需要重新提供。这意味着难以缓存权限检查结果，可能影响性能。只在必要时使用上下文元组。

## 6.5 条件关系元组：实现 ABAC

条件关系元组是实现基于属性的访问控制（ABAC）的关键机制。通过在元组中添加条件，可以根据动态属性值决定关系是否有效。

### 基于时间的访问控制

授权模型中定义条件：

```openfga
type document
  relations
    define viewer: [user with non_expired_grant]

condition non_expired_grant(grant_time: timestamp, grant_duration: duration, current_time: timestamp) {
  current_time >= grant_time and current_time <= grant_time + grant_duration
}
```

写入条件关系元组：

```python
body = ClientWriteRequest(
    writes=[
        ClientTuple(
            user="user:alice",
            relation="viewer",
            object="document:secret",
            condition={
                "name": "non_expired_grant",
                "context": {
                    "grant_time": "2024-01-01T00:00:00Z",
                    "grant_duration": "24h"
                }
            }
        )
    ]
)
await fga_client.write(body, options)
```

权限检查时提供当前时间：

```python
check_request = {
    "user": "user:alice",
    "relation": "viewer",
    "object": "document:secret",
    "context": {
        "current_time": "2024-01-01T12:00:00Z"
    }
}
response = await fga_client.check(check_request)
# response.allowed = True（在有效期内）
```

### 基于 IP 的访问控制

条件关系元组也可以用于 IP 地址限制：

```openfga
condition ip_based_access(user_ip: ipaddr, allowed_ips: ipaddr[]) {
  user_ip in allowed_ips
}
```

这种方式让你可以实现"只允许从公司网络访问"的策略。

> **实践经验**：条件关系元组很强大，但也增加了复杂度。在我的项目中，我只在真正需要动态属性判断的场景使用它，比如临时访问权限和 IP 限制。对于静态权限，还是用普通关系元组更简单。

**完整 ABAC 示例**：参考 [条件模型设计](../models/05.05.conditional-tuples/)

## 6.6 性能优化与最佳实践

在生产环境中，关系元组管理的性能至关重要。这里分享一些实战经验。

### 批量操作优化

**分批大小**：每批 100-500 条是个不错的平衡点。太小会增加网络开销，太大可能导致超时。

**并发控制**：使用信号量限制并发数，避免过度并发导致的性能问题：

```python
semaphore = asyncio.Semaphore(5)  # 最多 5 个并发请求

async def process_batch(batch):
    async with semaphore:
        await fga_client.write(ClientWriteRequest(writes=batch), options)
```

**错误重试**：网络不稳定时，实现指数退避重试：

```python
for attempt in range(3):
    try:
        await fga_client.write(body, options)
        break
    except Exception as e:
        if attempt < 2:
            await asyncio.sleep(2 ** attempt)
        else:
            raise
```

### 数据一致性

OpenFGA 保证同一请求中的所有操作具有原子性——要么全部成功，要么全部失败。利用这个特性，在更新权限时使用事务性写入：

```python
# 原子性更新：删除旧权限，添加新权限
body = ClientWriteRequest(
    deletes=[old_tuple],
    writes=[new_tuple]
)
await fga_client.write(body, options)
```

### 存储优化

**定期清理**：删除过期或无效的关系元组，避免数据膨胀。

**合理设计**：避免过度嵌套的关系结构，这会影响查询性能。

**监控指标**：关注存储增长和查询延迟，及时发现问题。

> **踩坑经验**：我曾经遇到过一个性能问题——随着关系元组数量增长到 100 万条，查询延迟从 10ms 增加到 100ms。排查后发现是数据库索引不足。添加合适的索引后，性能立即恢复正常。所以，数据库优化也很重要！

## 本章小结

关系元组是 OpenFGA 授权系统的数据基础。本章我们学习了：

**基础操作** - 关系元组的增删改查，理解元组的结构和约束。元组必须符合授权模型的定义，OpenFGA 会在写入时验证。

**批量处理** - 批量操作显著提高效率，并保证事务性。分批处理、并发控制和错误重试是关键技巧。

**上下文元组** - 用于动态授权决策，适合组织上下文、时间窗口等场景。不会持久化，每次请求都需要提供。

**条件关系元组** - 实现 ABAC 的关键机制，支持基于时间、IP 等属性的动态访问控制。

**性能优化** - 合理的批量大小、并发控制、错误重试和数据清理是生产环境的关键。

在下一章中，我们将学习 OpenFGA 的 API 详解——Check、ListObjects、Expand 等核心 API 的使用方法，以及如何在实际应用中高效集成这些 API。

---

## 实践练习

### 基础练习

1. **创建文档共享系统的关系元组**

   使用 SDK 创建以下关系：
   - Alice 是文档 report 的所有者
   - Bob 是文档 report 的编辑者
   - 工程团队的成员是文档 report 的查看者

2. **实现批量导入工具**

   从 CSV 文件批量导入关系元组，要求：
   - 支持数据验证和去重
   - 实现分批处理和错误重试
   - 显示导入进度

### 进阶练习

3. **使用上下文元组实现多租户权限**

   实现一个多租户系统，用户在不同组织中有不同权限。使用上下文元组在权限检查时提供组织上下文。

4. **实现基于时间的临时访问**

   使用条件关系元组实现临时访问权限（24 小时有效）。包括权限授予、检查和过期处理。

### 挑战练习

5. **设计高性能批量导入工具**

   实现一个生产级的批量导入工具：
   - 支持 JSON、CSV、YAML 多种格式
   - 实现并发控制、进度跟踪、断点续传
   - 提供详细的导入报告和错误处理

---

## 延伸阅读

- **关系元组管理**：[OpenFGA 官方文档](https://openfga.dev/docs/getting-started/update-relationship-tuples)
- **上下文元组**：[Token Claims 与上下文元组](https://openfga.dev/docs/modeling/token-claims-contextual-tuples)
- **条件关系元组**：[条件定义指南](https://openfga.dev/docs/modeling/conditions)
- **API 参考**：[完整 API 文档](https://openfga.dev/api/service)
