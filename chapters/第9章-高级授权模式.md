# 第 9 章：高级授权模式

从简单到复杂：掌握企业级授权系统的核心模式

---

当你的应用从几十个用户增长到几千个用户，从单一产品演变成多租户 SaaS 平台时，你会发现之前简单的授权设计开始捉襟见肘——这就是我们需要高级授权模式的时候了。

本章讨论五个企业级应用中无法回避的授权场景：
- **多租户隔离** - 如何在共享架构中确保数据完全隔离
- **动态上下文权限** - 基于时间、位置、设备等动态条件的授权
- **细粒度控制** - 字段级、操作级的精确权限管理
- **层级继承** - 组织架构、文件夹等层级结构的权限设计
- **身份提供者集成** - 与 OAuth2、SAML 等认证系统的集成

这些都是我在实际项目中踩过坑、填过坑之后总结出来的经验。

---

## 8.1 多租户系统的授权设计

多租户（Multi-Tenant）系统是现代 SaaS 应用的标准架构模式。在多租户系统中，多个客户（租户）共享同一套应用实例，但数据完全隔离。如何在共享的资源上实现严格的租户隔离，同时保证授权系统的性能和可扩展性，是设计多租户授权系统的核心挑战。

### 8.1.1 多租户架构模式

在深入了解授权设计之前，我们需要理解多租户系统的不同架构模式，因为不同的架构模式会影响授权模型的设计策略。

#### 多租户数据隔离模式

多租户系统通常采用以下三种数据隔离模式：

**1. 共享数据库，共享 Schema**

- 所有租户使用同一个数据库和表结构
- 通过租户标识符（Tenant ID）区分不同租户的数据
- **授权考虑**：需要在所有类型中添加租户关系，确保租户隔离

**2. 共享数据库，独立 Schema**

- 所有租户共享数据库，但每个租户有独立的 Schema
- 数据库层面实现数据隔离
- **授权考虑**：可以在 OpenFGA 层面简化租户隔离逻辑

**3. 独立数据库**

- 每个租户有独立的数据库实例
- 完全隔离，安全性最高
- **授权考虑**：可以为每个租户创建独立的 OpenFGA Store

#### OpenFGA 中的多租户策略

OpenFGA 支持多种多租户实现策略：

**策略一：单 Store 多租户（推荐）**

在单个 OpenFGA Store 中管理所有租户的授权数据，通过类型级别的租户关系实现隔离。这种方式的优势是：

- 统一的授权模型管理
- 跨租户查询和统计更方便
- 资源利用率高
- 管理和维护成本低

**策略二：多 Store 多租户**

为每个租户创建独立的 OpenFGA Store，实现完全隔离。这种方式适用于：

- 对数据隔离要求极高的场景
- 需要租户级别的授权模型定制
- 需要独立的备份和恢复策略

本章重点讲解策略一（单 Store 多租户），因为它是最常用且最具挑战性的模式。

### 8.1.2 租户隔离策略

在多租户系统中，租户隔离是安全性的核心。我们需要确保：

1. **数据隔离**：租户只能访问自己的数据
2. **权限隔离**：租户的权限变更不影响其他租户
3. **查询隔离**：授权查询不会泄露其他租户的信息

#### 基础租户隔离模型

首先，我们需要在授权模型中添加租户（Tenant/Organization）类型，并建立资源与租户的关联关系。

```openfga
model
  schema 1.1

type user

type tenant
  relations
    define member: [user]
    define admin: [user]

type document
  relations
    define tenant: [tenant]           # 文档所属租户
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor

    # 确保权限检查时验证租户成员关系
    define can_view: viewer and tenant#member
    define can_edit: editor and tenant#member
```

**关键设计点：**

1. **租户关联**：每个资源必须关联一个租户（通过 `tenant` 关系）
2. **成员验证**：权限检查时需要验证用户在租户中的成员关系
3. **组合权限**：权限关系需要组合资源权限和租户成员关系

#### 完整的租户隔离授权模型

在实际应用中，我们需要更完善的模型设计：

```openfga
model
  schema 1.1

type user

type tenant
  relations
    define member: [user]
    define admin: [user]
    define billing_admin: [user]

type project
  relations
    define tenant: [tenant]            # 项目所属租户
    define owner: [tenant#admin, tenant#member]  # 租户管理员或成员可以拥有项目
    define collaborator: [tenant#member]

    # 权限定义，确保租户隔离
    define can_view: owner or collaborator
    define can_edit: owner
    define can_delete: tenant#admin or owner

type document
  relations
    define tenant: [project#tenant]   # 通过项目继承租户
    define parent: [project]
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor

    # 确保权限检查时验证租户成员关系
    define can_view: (viewer or viewer from parent) and tenant#member
    define can_edit: (editor or editor from parent) and tenant#member
    define can_delete: owner and tenant#member
```

> **设计要点：**
>
> 1. **租户继承**：文档通过父项目继承租户关系，避免在每个资源上显式设置租户
> 2. **权限组合**：使用 `and` 操作符组合资源权限和租户成员关系
> 3. **租户管理员**：租户管理员拥有特殊权限，可以管理租户内的所有资源

### 8.1.3 设计示例

#### 示例一：基础多租户 SaaS 平台

让我们设计一个简化的多租户文档协作平台：

**授权模型：**

```openfga
model
  schema 1.1

type user

type organization
  relations
    define member: [user]
    define admin: [user]

    # 组织管理员可以管理组织成员
    define can_invite_member: admin
    define can_remove_member: admin
    define can_view_members: member

type workspace
  relations
    define organization: [organization]  # 工作空间属于组织
    define owner: [organization#admin, organization#member]
    define member: [organization#member]

    define can_view: owner or member
    define can_manage: organization#admin or owner

type document
  relations
    define workspace: [workspace]        # 文档属于工作空间
    define organization: [workspace#organization]  # 继承组织的租户关系
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor

    # 权限检查需要同时满足：资源权限 + 租户成员关系
    define can_view: (viewer or viewer from workspace) and organization#member
    define can_edit: (editor or editor from workspace) and organization#member
    define can_delete: owner and (organization#admin or workspace#can_manage)
```

**初始化关系元组：**

```python
from openfga_sdk import OpenFgaClient, ClientWriteRequest, ClientTuple

# 初始化 OpenFGA 客户端
fga_client = OpenFgaClient(
    api_url='http://localhost:8080',
    store_id='your_store_id'
)

async def initialize_tenant(organization_id: str, admin_user_id: str):
    """
    初始化租户并设置管理员
    
    参数:
        organization_id: 组织ID
        admin_user_id: 管理员用户ID
    """
    # 1. 创建组织并设置管理员
    body = ClientWriteRequest(
        writes=[
            ClientTuple(
                user=f"user:{admin_user_id}",
                relation="admin",
                object=f"organization:{organization_id}"
            ),
            ClientTuple(
                user=f"user:{admin_user_id}",
                relation="member",
                object=f"organization:{organization_id}"
            ),
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.write(body, options)
    return response


async def create_workspace(organization_id: str, workspace_id: str, user_id: str):
    """
    创建工作空间并关联到组织
    
    参数:
        organization_id: 组织ID
        workspace_id: 工作空间ID
        user_id: 创建者用户ID
    """
    # 2. 创建工作空间
    body = ClientWriteRequest(
        writes=[
            ClientTuple(
                user=f"organization:{organization_id}",
                relation="organization",
                object=f"workspace:{workspace_id}"
            ),
            ClientTuple(
                user=f"user:{user_id}",
                relation="owner",
                object=f"workspace:{workspace_id}"
            ),
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.write(body, options)
    return response
```

> **代码说明：**
>
> 1. **功能说明**：初始化多租户系统的组织和工作空间
> 2. **关键步骤**：首先设置组织管理员和成员关系，然后创建工作空间并关联到组织
> 3. **注意事项**：确保管理员同时具有 admin 和 member 关系，以获得完整权限
> 4. **最佳实践**：使用异步函数提高性能，统一使用字符串格式化构建对象标识符

**权限检查实现：**

```python
async def check_document_access(user_id: str, document_id: str, organization_id: str):
    """
    检查用户是否有权访问文档（带租户隔离）
    
    参数:
        user_id: 用户ID
        document_id: 文档ID
        organization_id: 当前组织ID
        
    返回:
        bool: 是否允许访问
    """
    from openfga_sdk import ClientCheckRequest, ClientTuple
    
    # 权限检查会自动验证租户隔离
    body = ClientCheckRequest(
        user=f"user:{user_id}",
        relation="can_view",
        object=f"document:{document_id}",
        # 使用上下文元组提供当前租户上下文
        contextual_tuples=[
            ClientTuple(
                user=f"user:{user_id}",
                relation="member",
                object=f"organization:{organization_id}"
            ),
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：检查用户对文档的访问权限，并验证租户隔离
> 2. **关键步骤**：使用上下文元组提供当前的租户上下文信息
> 3. **注意事项**：上下文元组不会持久化，仅在本次请求中有效
> 4. **扩展方向**：可以增加更多上下文信息，如IP地址、时间段等
> 5. **实际应用**：在Web应用中，组织ID通常从JWT token或session中获取

#### 示例二：使用上下文元组的多租户授权

在某些场景中，用户可能同时属于多个组织，我们需要在权限检查时指定当前的组织上下文：

**授权模型：**

```openfga
type organization
  relations
    define member: [user]
    define user_in_context: [user]  # 用户当前的组织上下文

type resource
  relations
    define organization: [organization]
    define can_access: [organization#member]

    # 只有在指定组织上下文中才能访问
    define can_view: can_access and organization#user_in_context
```

**实现代码：**

```python
async def check_resource_with_context(user_id: str, resource_id: str, current_org_id: str):
    """
    使用上下文检查资源访问权限
    
    参数:
        user_id: 用户ID
        resource_id: 资源ID  
        current_org_id: 当前组织ID（从JWT token或session获取）
        
    返回:
        bool: 是否允许访问
    """
    from openfga_sdk import ClientCheckRequest, ClientTuple
    
    # 从 JWT token 或其他来源获取当前组织上下文
    body = ClientCheckRequest(
        user=f"user:{user_id}",
        relation="can_view",
        object=resource_id,
        contextual_tuples=[
            # 指定当前的组织上下文
            ClientTuple(
                user=f"user:{user_id}",
                relation="user_in_context",
                object=f"organization:{current_org_id}"
            ),
            # 同时提供成员关系
            ClientTuple(
                user=f"user:{user_id}",
                relation="member",
                object=f"organization:{current_org_id}"
            ),
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：在多组织场景中指定当前组织上下文进行权限检查
> 2. **关键步骤**：同时提供 `user_in_context` 和 `member` 两个关系
> 3. **注意事项**：当前组织ID应该从经过验证的JWT token中提取
> 4. **最佳实践**：使用上下文元组避免将临时状态写入数据库

#### 租户隔离最佳实践

1. **强制租户关联**：确保所有资源类型都通过直接或间接关系关联到租户
2. **权限组合验证**：使用 `and` 操作符组合资源权限和租户成员关系
3. **上下文提供**：在权限检查时提供当前的租户上下文（使用上下文元组）
4. **查询过滤**：使用 ListObjects API 时，确保结果已经过租户过滤
5. **审计日志**：记录所有权限操作，包括租户信息，便于审计和问题排查

---

## 8.2 基于上下文的动态权限控制

传统的授权模型通常是静态的，权限关系在创建时就已经确定。但在实际应用中，许多授权决策需要依赖动态的上下文信息，如当前时间、用户位置、IP 地址、请求参数等。OpenFGA 通过上下文元组（Contextual Tuples）和条件关系元组（Conditional Relationship Tuples）提供了强大的动态权限控制能力。

### 8.2.1 上下文权限概念

上下文权限是指授权决策依赖于请求时的动态上下文信息，而非仅依赖持久化的关系元组。这种模式使得授权系统能够适应复杂多变的业务需求。

#### 上下文信息的类型

常见的上下文信息包括：

1. **时间上下文**：当前时间、时间段、工作日/周末
2. **位置上下文**：IP 地址、地理位置、网络范围
3. **环境上下文**：设备类型、浏览器类型、操作系统
4. **组织上下文**：当前选择的组织、部门
5. **会话上下文**：会话 ID、登录方式、认证强度

#### 上下文元组 vs 条件关系元组

OpenFGA 提供了两种实现动态权限的机制：

**上下文元组（Contextual Tuples）：**

- 临时性的关系元组，仅在请求期间有效
- 不会持久化到数据库
- 适用于频繁变化的上下文信息
- 支持 Check、ListObjects、ListUsers 等 API

**条件关系元组（Conditional Relationship Tuples）：**

- 持久化的关系元组，但带有条件评估逻辑
- 存储在数据库中
- 条件在权限检查时评估
- 适用于相对稳定的条件规则

### 8.2.2 实现方法

#### 方法一：使用上下文元组实现动态权限

**场景：基于时间和 IP 地址的访问控制**

**授权模型：**

```openfga
model
  schema 1.1

type user

type timeslot
type ip_address_range

type branch
  relations
    define approved_timeslot: [timeslot]
    define approved_ip_address_range: [ip_address_range]

type account
  relations
    define can_access: [user, timeslot, ip_address_range]

type transaction
  relations
    define branch: [branch]
    define account: [account]
    define can_view: [account#can_access] and branch#approved_timeslot and branch#approved_ip_address_range
```

**实现代码：**

```python
from datetime import datetime
from typing import Optional

def get_current_timeslot() -> str:
    """
    获取当前时间段标识
    
    返回:
        str: 时间段标识，如 "timeslot:12_13" 表示 12-13 点
    """
    hour = datetime.now().hour
    # 生成时间段标识，如 "timeslot:12_13" 表示 12-13 点
    return f"timeslot:{hour}_{hour + 1}"


def get_ip_range(ip_address: str) -> Optional[str]:
    """
    根据 IP 地址返回对应的 IP 范围
    
    参数:
        ip_address: IP 地址字符串
        
    返回:
        Optional[str]: IP 范围标识，如果不在允许范围则返回 None
    """
    # 根据 IP 地址返回对应的 IP 范围
    if ip_address.startswith("192.168."):
        return "ip-address-range:192.168.0.0/16"
    if ip_address.startswith("10."):
        return "ip-address-range:10.0.0.0/8"
    return None


async def check_transaction_access(
    user_id: str, 
    transaction_id: str, 
    account_id: str,
    branch_id: str,
    user_ip: str
):
    """
    检查交易访问权限（包含时间和IP限制）
    
    参数:
        user_id: 用户ID
        transaction_id: 交易ID
        account_id: 账户ID
        branch_id: 分行ID
        user_ip: 用户IP地址
        
    返回:
        bool: 是否允许访问
    """
    from openfga_sdk import ClientCheckRequest, ClientTuple
    
    current_timeslot = get_current_timeslot()
    ip_range = get_ip_range(user_ip)
    
    if not ip_range:
        # IP 不在允许范围内
        return False
    
    body = ClientCheckRequest(
        user=f"user:{user_id}",
        relation="can_view",
        object=f"transaction:{transaction_id}",
        contextual_tuples=[
            # 用户在当前时间段有访问权限
            ClientTuple(
                user=f"user:{user_id}",
                relation="can_access",
                object=current_timeslot
            ),
            # 账户在当前时间段有访问权限
            ClientTuple(
                user=f"account:{account_id}",
                relation="can_access",
                object=current_timeslot
            ),
            # 分支在当前时间段被批准
            ClientTuple(
                user=current_timeslot,
                relation="approved_timeslot",
                object=f"branch:{branch_id}"
            ),
            # IP 地址范围被批准
            ClientTuple(
                user=ip_range,
                relation="approved_ip_address_range",
                object=f"branch:{branch_id}"
            ),
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：实现基于时间段和IP地址的动态访问控制
> 2. **关键步骤**：
>    - 获取当前时间段和IP范围
>    - 使用上下文元组提供动态上下文信息
>    - 在权限检查中同时验证时间和IP限制
> 3. **注意事项**：
>    - 上下文元组不会持久化，适合动态变化的信息
>    - IP范围检查应该在应用层预先验证
> 4. **扩展方向**：可以增加更多上下文条件，如地理位置、设备类型等
> 5. **实际应用**：适用于银行、金融等需要严格访问控制的场景

#### 方法二：使用条件关系元组实现 ABAC

**场景：基于时间的临时访问授权**

**授权模型：**

```openfga
model
  schema 1.1

type user

type document
  relations
    define viewer: [user with non_expired_grant]

condition non_expired_grant(grant_time: timestamp, grant_duration: duration, current_time: timestamp) {
  current_time >= grant_time and current_time <= grant_time + grant_duration
}
```

**实现代码：**

```python
from datetime import datetime
from openfga_sdk import ClientWriteRequest, ClientTuple, RelationshipCondition

async def grant_temporary_access(user_id: str, document_id: str, duration_hours: int):
    """
    授予用户临时访问权限
    
    参数:
        user_id: 用户ID
        document_id: 文档ID
        duration_hours: 持续时间（小时）
    """
    grant_time = datetime.now()
    grant_duration = f"{duration_hours}h"
    
    body = ClientWriteRequest(
        writes=[
            ClientTuple(
                user=f"user:{user_id}",
                relation="viewer",
                object=f"document:{document_id}",
                condition=RelationshipCondition(
                    name="non_expired_grant",
                    context={
                        "grant_time": grant_time.isoformat(),
                        "grant_duration": grant_duration,
                    },
                ),
            ),
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.write(body, options)
    return response


# 权限检查（需要提供当前时间上下文）
async def check_document_access(user_id: str, document_id: str):
    """
    检查文档访问权限
    
    参数:
        user_id: 用户ID
        document_id: 文档ID
        
    返回:
        bool: 是否允许访问
    """
    from openfga_sdk import ClientCheckRequest
    
    current_time = datetime.now().isoformat()
    
    body = ClientCheckRequest(
        user=f"user:{user_id}",
        relation="viewer",
        object=f"document:{document_id}",
        context={
            "current_time": current_time,
        },
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：使用条件关系元组实现临时访问授权
> 2. **关键步骤**：
>    - 写入时指定条件和上下文参数
>    - 检查时提供当前时间用于条件评估
> 3. **注意事项**：
>    - 条件关系元组会持久化到数据库
>    - 条件在每次权限检查时都会评估
> 4. **扩展方向**：可以实现更复杂的ABAC策略，如基于用户属性、资源属性等
> 5. **实际应用**：适用于临时授权、时间限制的访问等场景

### 8.2.3 实际应用场景

#### 场景一：组织上下文授权

在多组织系统中，用户的权限可能取决于当前选择的组织上下文。

**授权模型：**

```openfga
model
  schema 1.1

type user

type organization
  relations
    define member: [user]
    define user_in_context: [user]  # 当前的组织上下文

type project
  relations
    define can_view: [organization#member]
    define can_edit: [organization#member]

    # 只有在指定组织上下文中才能访问
    define can_view_with_context: can_view and organization#user_in_context
    define can_edit_with_context: can_edit and organization#user_in_context
```

**实现：**

```python
async def check_project_access(user_id: str, project_id: str, current_org_id: str):
    """
    检查项目访问权限（带组织上下文）
    
    参数:
        user_id: 用户ID
        project_id: 项目ID
        current_org_id: 当前组织ID
        
    返回:
        bool: 是否允许访问
    """
    from openfga_sdk import ClientCheckRequest, ClientTuple
    
    body = ClientCheckRequest(
        user=f"user:{user_id}",
        relation="can_view_with_context",
        object=f"project:{project_id}",
        contextual_tuples=[
            ClientTuple(
                user=f"user:{user_id}",
                relation="user_in_context",
                object=f"organization:{current_org_id}"
            ),
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

#### 场景二：JWT Token 声明的上下文

从 JWT token 中提取组织、角色等信息作为上下文。

**实现：**

```python
import base64
import json
from typing import Dict, List, Optional

def extract_context_from_jwt(token: str) -> Dict:
    """
    从JWT token中提取上下文信息
    
    参数:
        token: JWT token字符串
        
    返回:
        dict: 包含用户ID、组织ID、角色和组信息的字典
    """
    # 解析JWT token
    parts = token.split('.')
    if len(parts) != 3:
        raise ValueError("Invalid JWT token format")
    
    # 解码payload（第二部分）
    payload_bytes = base64.urlsafe_b64decode(parts[1] + '==')  # 添加padding
    payload = json.loads(payload_bytes)
    
    return {
        'user_id': f"user:{payload.get('sub')}",
        'organization_id': f"organization:{payload['org_id']}" if payload.get('org_id') else None,
        'roles': payload.get('roles', []),
        'groups': payload.get('groups', []),
    }


async def check_with_jwt_context(token: str, resource_id: str, relation: str):
    """
    使用JWT上下文进行权限检查
    
    参数:
        token: JWT token
        resource_id: 资源ID
        relation: 关系名称
        
    返回:
        bool: 是否允许访问
    """
    from openfga_sdk import ClientCheckRequest, ClientTuple
    
    context = extract_context_from_jwt(token)
    contextual_tuples = []
    
    # 添加组织成员关系
    if context['organization_id']:
        contextual_tuples.extend([
            ClientTuple(
                user=context['user_id'],
                relation="member",
                object=context['organization_id']
            ),
            ClientTuple(
                user=context['user_id'],
                relation="user_in_context",
                object=context['organization_id']
            ),
        ])
    
    # 添加组成员关系
    for group_id in context['groups']:
        contextual_tuples.append(
            ClientTuple(
                user=context['user_id'],
                relation="member",
                object=f"group:{group_id}"
            )
        )
    
    body = ClientCheckRequest(
        user=context['user_id'],
        relation=relation,
        object=resource_id,
        contextual_tuples=contextual_tuples,
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：从JWT token中提取上下文信息并用于权限检查
> 2. **关键步骤**：
>    - 解析JWT token获取用户和组织信息
>    - 构建上下文元组数组
>    - 执行权限检查
> 3. **注意事项**：
>    - 实际应用中应使用专业的JWT库（如PyJWT）进行token验证
>    - 需要验证token签名以确保安全性
> 4. **扩展方向**：可以增加更多JWT声明，如角色、权限组等
> 5. **实际应用**：这是Web应用中最常见的授权模式

#### 上下文权限最佳实践

1. **合理选择机制**：频繁变化的上下文使用上下文元组，相对稳定的规则使用条件关系元组
2. **性能考虑**：上下文元组会增加权限检查的计算复杂度，避免使用过多
3. **缓存策略**：上下文权限的结果难以缓存，需要考虑性能影响
4. **安全性**：确保上下文信息来自可信源（如 JWT token 签名验证）
5. **日志记录**：记录权限检查时的上下文信息，便于审计和调试

---

## 8.3 细粒度访问控制的实现

细粒度访问控制（Fine-Grained Access Control）是指对资源、操作和字段进行精确的权限控制。与传统的粗粒度控制（如"可以访问文档"）不同，细粒度控制允许更精确的授权，如"可以查看文档的标题和内容，但不能查看价格字段"、"可以编辑文档但不能删除"等。

### 8.3.1 细粒度控制策略

OpenFGA 提供了多种实现细粒度访问控制的策略，我们可以根据业务需求选择合适的方式。

#### 策略一：资源级细粒度控制

在授权模型中为每个资源定义细粒度的权限关系。

**示例：文档的细粒度权限**

```openfga
type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor

    # 细粒度权限
    define can_view_title: viewer
    define can_view_content: viewer
    define can_view_metadata: owner or editor
    define can_view_price: owner  # 只有所有者可以查看价格

    define can_edit_content: editor
    define can_edit_metadata: owner
    define can_delete: owner
    define can_share: owner or editor
```

**权限检查实现：**

```python
async def check_field_access(user_id: str, document_id: str, field_name: str) -> bool:
    """
    检查用户对文档特定字段的访问权限
    
    参数:
        user_id: 用户ID
        document_id: 文档ID
        field_name: 字段名称
        
    返回:
        bool: 是否允许访问该字段
    """
    from openfga_sdk import ClientCheckRequest
    
    # 映射字段名到权限关系
    field_relation_map = {
        "title": "can_view_title",
        "content": "can_view_content",
        "metadata": "can_view_metadata",
        "price": "can_view_price",
    }
    
    relation = field_relation_map.get(field_name)
    if not relation:
        return False
    
    body = ClientCheckRequest(
        user=f"user:{user_id}",
        relation=relation,
        object=f"document:{document_id}",
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：实现字段级权限控制，不同用户可以查看不同的字段
> 2. **关键步骤**：使用字典映射字段名到权限关系
> 3. **注意事项**：未定义的字段默认拒绝访问
> 4. **扩展方向**：可以使用配置文件或数据库存储字段权限映射

#### 策略二：操作级权限控制

为不同的操作定义独立的权限关系。

**示例：项目管理系统的操作权限**

```openfga
type project
  relations
    define owner: [user]
    define member: [user]
    define viewer: [user]

    # 操作级权限
    define can_create_task: owner or member
    define can_assign_task: owner or member
    define can_complete_task: owner or member
    define can_delete_task: owner
    define can_view_reports: owner or member
    define can_export_data: owner
    define can_invite_member: owner
    define can_remove_member: owner
```

**实现：**

```python
# 操作权限映射字典
OPERATION_PERMISSIONS = {
    "create_task": "can_create_task",
    "assign_task": "can_assign_task",
    "complete_task": "can_complete_task",
    "delete_task": "can_delete_task",
    "view_reports": "can_view_reports",
    "export_data": "can_export_data",
    "invite_member": "can_invite_member",
    "remove_member": "can_remove_member",
}


async def check_operation_permission(user_id: str, project_id: str, operation: str) -> bool:
    """
    检查用户对项目特定操作的权限
    
    参数:
        user_id: 用户ID
        project_id: 项目ID
        operation: 操作名称
        
    返回:
        bool: 是否允许执行该操作
        
    异常:
        ValueError: 当操作名称未知时抛出
    """
    from openfga_sdk import ClientCheckRequest
    
    relation = OPERATION_PERMISSIONS.get(operation)
    if not relation:
        raise ValueError(f"Unknown operation: {operation}")
    
    body = ClientCheckRequest(
        user=f"user:{user_id}",
        relation=relation,
        object=f"project:{project_id}",
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：实现操作级权限控制，细化到具体的业务操作
> 2. **关键步骤**：使用常量字典映射操作名到权限关系
> 3. **注意事项**：对未知操作抛出异常，确保安全性
> 4. **最佳实践**：使用常量定义权限映射，便于维护和修改

### 8.3.2 字段级权限控制

字段级权限控制是指在数据返回时，根据用户的权限过滤敏感字段。

#### 方法一：应用层字段过滤

在应用层根据权限检查结果过滤返回的字段。

```python
import asyncio
from typing import Dict, Any, Optional

async def get_document(user_id: str, document_id: str) -> Dict[str, Any]:
    """
    获取文档并根据用户权限过滤字段
    
    参数:
        user_id: 用户ID
        document_id: 文档ID
        
    返回:
        dict: 根据权限过滤后的文档数据
    """
    from openfga_sdk import ClientCheckRequest
    
    # 获取文档数据（假设有一个文档服务）
    document = await document_service.get_by_id(document_id)
    
    # 并发检查各字段的访问权限
    check_tasks = [
        fga_client.check(
            ClientCheckRequest(
                user=f"user:{user_id}",
                relation="can_view_title",
                object=f"document:{document_id}"
            ),
            {"authorization_model_id": "MODEL_ID"}
        ),
        fga_client.check(
            ClientCheckRequest(
                user=f"user:{user_id}",
                relation="can_view_content",
                object=f"document:{document_id}"
            ),
            {"authorization_model_id": "MODEL_ID"}
        ),
        fga_client.check(
            ClientCheckRequest(
                user=f"user:{user_id}",
                relation="can_view_metadata",
                object=f"document:{document_id}"
            ),
            {"authorization_model_id": "MODEL_ID"}
        ),
        fga_client.check(
            ClientCheckRequest(
                user=f"user:{user_id}",
                relation="can_view_price",
                object=f"document:{document_id}"
            ),
            {"authorization_model_id": "MODEL_ID"}
        ),
    ]
    
    # 并发执行所有权限检查
    permissions = await asyncio.gather(*check_tasks)
    
    # 根据权限过滤字段
    result = {"id": document_id}
    
    if permissions[0].allowed:
        result["title"] = document.title
    if permissions[1].allowed:
        result["content"] = document.content
    if permissions[2].allowed:
        result["metadata"] = document.metadata
    if permissions[3].allowed:
        result["price"] = document.price
    
    return result
```

> **代码说明：**
>
> 1. **功能说明**：获取文档并根据用户权限过滤敏感字段
> 2. **关键步骤**：
>    - 并发检查多个字段的访问权限
>    - 根据检查结果动态构建返回数据
> 3. **注意事项**：使用 `asyncio.gather` 并发执行权限检查以提高性能
> 4. **扩展方向**：可以使用装饰器模式简化字段过滤逻辑
> 5. **实际应用**：适用于API响应、报表生成等场景

#### 方法二：使用 BatchCheck API 优化性能

对于需要检查多个字段权限的场景，使用 BatchCheck API 可以显著提升性能。

```python
from openfga_sdk import ClientBatchCheckRequest
from typing import List, Dict, Any

async def get_document_with_field_permissions(user_id: str, document_id: str) -> Dict[str, Any]:
    """
    使用BatchCheck API获取文档并过滤字段
    
    参数:
        user_id: 用户ID
        document_id: 文档ID
        
    返回:
        dict: 根据权限过滤后的文档数据
    """
    document = await document_service.get_by_id(document_id)
    
    # 批量检查所有字段权限
    body = ClientBatchCheckRequest(
        checks=[
            {
                "user": f"user:{user_id}",
                "relation": "can_view_title",
                "object": f"document:{document_id}",
            },
            {
                "user": f"user:{user_id}",
                "relation": "can_view_content",
                "object": f"document:{document_id}",
            },
            {
                "user": f"user:{user_id}",
                "relation": "can_view_metadata",
                "object": f"document:{document_id}",
            },
            {
                "user": f"user:{user_id}",
                "relation": "can_view_price",
                "object": f"document:{document_id}",
            },
        ],
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.batch_check(body, options)
    
    # 构建返回结果
    result = {"id": document_id}
    
    if response.responses[0].allowed:
        result["title"] = document.title
    if response.responses[1].allowed:
        result["content"] = document.content
    if response.responses[2].allowed:
        result["metadata"] = document.metadata
    if response.responses[3].allowed:
        result["price"] = document.price
    
    return result
```

> **代码说明：**
>
> 1. **功能说明**：使用BatchCheck API批量检查权限，提升性能
> 2. **关键步骤**：一次请求检查多个权限，减少网络往返
> 3. **注意事项**：BatchCheck按照请求顺序返回结果
> 4. **性能优化**：相比单独调用Check API，可以减少网络延迟
> 5. **实际应用**：适用于需要检查大量权限的场景

#### 方法三：使用 GraphQL Field-level 授权

如果使用 GraphQL，可以实现字段级的授权解析器。

```python
from typing import Optional
import strawberry
from strawberry.types import Info

@strawberry.type
class Document:
    id: str
    _title: str = strawberry.field(name="title")
    _content: str = strawberry.field(name="content")
    _price: Optional[float] = strawberry.field(name="price")
    
    @strawberry.field
    async def title(self, info: Info) -> Optional[str]:
        """
        标题字段解析器，包含权限检查
        """
        user_id = info.context["user_id"]
        
        body = ClientCheckRequest(
            user=f"user:{user_id}",
            relation="can_view_title",
            object=f"document:{self.id}",
        )
        
        response = await fga_client.check(body, {"authorization_model_id": "MODEL_ID"})
        return self._title if response.allowed else None
    
    @strawberry.field
    async def content(self, info: Info) -> Optional[str]:
        """
        内容字段解析器，包含权限检查
        """
        user_id = info.context["user_id"]
        
        body = ClientCheckRequest(
            user=f"user:{user_id}",
            relation="can_view_content",
            object=f"document:{self.id}",
        )
        
        response = await fga_client.check(body, {"authorization_model_id": "MODEL_ID"})
        return self._content if response.allowed else None
    
    @strawberry.field
    async def price(self, info: Info) -> Optional[float]:
        """
        价格字段解析器，包含权限检查
        """
        user_id = info.context["user_id"]
        
        body = ClientCheckRequest(
            user=f"user:{user_id}",
            relation="can_view_price",
            object=f"document:{self.id}",
        )
        
        response = await fga_client.check(body, {"authorization_model_id": "MODEL_ID"})
        return self._price if response.allowed else None


@strawberry.type
class Query:
    @strawberry.field
    async def document(self, id: str) -> Optional[Document]:
        """
        查询文档
        """
        doc_data = await document_service.get_by_id(id)
        return Document(
            id=doc_data.id,
            _title=doc_data.title,
            _content=doc_data.content,
            _price=doc_data.price,
        )
```

> **代码说明：**
>
> 1. **功能说明**：使用Strawberry GraphQL实现字段级授权
> 2. **关键步骤**：在每个字段的解析器中进行权限检查
> 3. **注意事项**：
>    - 使用私有字段存储实际数据
>    - 在字段解析器中检查权限
>    - 无权限时返回None
> 4. **扩展方向**：可以使用装饰器统一权限检查逻辑
> 5. **实际应用**：适用于GraphQL API的细粒度权限控制

### 8.3.3 操作级权限控制

操作级权限控制是指对不同的操作（如创建、读取、更新、删除）进行独立的权限控制。

#### RESTful API 操作权限映射

为 RESTful API 的操作设计权限模型：

```openfga
type resource
  relations
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor

    # RESTful 操作权限映射
    define can_read: viewer
    define can_create: owner or editor  # 创建子资源
    define can_update: editor
    define can_delete: owner
    define can_patch: editor  # 部分更新
```

#### 中间件实现

在 FastAPI 中实现操作权限检查中间件：

```python
from fastapi import FastAPI, Request, HTTPException, Depends
from typing import Callable

app = FastAPI()

# HTTP方法到权限关系的映射
OPERATION_RELATIONS = {
    "GET": "can_read",
    "POST": "can_create",
    "PUT": "can_update",
    "PATCH": "can_patch",
    "DELETE": "can_delete",
}


async def check_operation_permission(request: Request) -> bool:
    """
    检查操作权限的依赖函数
    
    参数:
        request: FastAPI请求对象
        
    返回:
        bool: 是否允许访问
        
    异常:
        HTTPException: 当权限检查失败或无权限时抛出
    """
    # 从请求中获取用户信息（假设已经通过身份验证中间件）
    user_id = request.state.user_id
    
    # 从路径参数或请求体中获取资源ID
    resource_id = request.path_params.get("id")
    if not resource_id and request.method in ["POST", "PUT", "PATCH"]:
        body = await request.json()
        resource_id = body.get("resourceId")
    
    # 根据HTTP方法获取对应的权限关系
    relation = OPERATION_RELATIONS.get(request.method)
    if not relation:
        return True  # 不需要权限检查的方法
    
    if not resource_id:
        raise HTTPException(status_code=400, detail="Resource ID is required")
    
    try:
        body = ClientCheckRequest(
            user=f"user:{user_id}",
            relation=relation,
            object=f"resource:{resource_id}",
        )
        
        options = {"authorization_model_id": "MODEL_ID"}
        response = await fga_client.check(body, options)
        
        if not response.allowed:
            raise HTTPException(status_code=403, detail="Permission denied")
        
        return True
        
    except Exception as e:
        raise HTTPException(
            status_code=500, 
            detail=f"Authorization check failed: {str(e)}"
        )


# 使用依赖注入的方式添加权限检查
@app.get("/api/resources/{id}", dependencies=[Depends(check_operation_permission)])
async def get_resource(id: str):
    """获取资源"""
    return {"message": f"Resource {id} retrieved"}


@app.post("/api/resources", dependencies=[Depends(check_operation_permission)])
async def create_resource(resource_data: dict):
    """创建资源"""
    return {"message": "Resource created"}


@app.put("/api/resources/{id}", dependencies=[Depends(check_operation_permission)])
async def update_resource(id: str, resource_data: dict):
    """更新资源"""
    return {"message": f"Resource {id} updated"}


@app.delete("/api/resources/{id}", dependencies=[Depends(check_operation_permission)])
async def delete_resource(id: str):
    """删除资源"""
    return {"message": f"Resource {id} deleted"}
```

> **代码说明：**
>
> 1. **功能说明**：使用FastAPI依赖注入实现RESTful API的操作级权限控制
> 2. **关键步骤**：
>    - 将HTTP方法映射到权限关系
>    - 从请求中提取用户和资源信息
>    - 执行权限检查
> 3. **注意事项**：
>    - 需要配合身份验证中间件使用
>    - 资源ID的提取方式需要根据实际API设计调整
> 4. **扩展方向**：可以添加权限缓存、审计日志等功能
> 5. **实际应用**：适用于RESTful API的统一权限控制

#### 细粒度权限最佳实践

1. **合理设计权限层级**：避免过度细化导致的模型复杂度
2. **批量检查优化**：对多个权限检查使用 BatchCheck API
3. **缓存策略**：对频繁检查的权限进行适当缓存
4. **默认拒绝**：遵循最小权限原则，默认拒绝，明确允许
5. **统一权限接口**：在应用层提供统一的权限检查接口，便于维护

---

## 8.4 层级权限和继承关系

层级权限是指资源之间存在层级关系，子资源可以继承父资源的权限。这是许多企业应用中的常见需求，如文件系统（文件夹-文件）、组织架构（部门-子部门-项目）、文档系统（文件夹-子文件夹-文档）等。

### 8.4.1 层级权限设计

#### 基础层级模型

最简单的层级权限模型是单层继承：

```openfga
model
  schema 1.1

type user

type folder
  relations
    define parent: [folder]        # 父文件夹关系
    define owner: [user]
    define viewer: [user] or viewer from parent  # 继承父文件夹的查看权限

type document
  relations
    define parent: [folder]       # 文档的父文件夹
    define owner: [user]
    define viewer: [user] or owner or viewer from parent  # 继承父文件夹权限
```

在这个模型中，文档会自动继承父文件夹的查看权限。如果文件夹 A 的查看者是用户 Alice，那么文件夹 A 中的所有文档也会对 Alice 可见。

#### 多层继承模型

对于更复杂的场景，我们需要支持多层级的权限继承：

```openfga
model
  schema 1.1

type user

type organization
  relations
    define admin: [user]
    define member: [user]

type department
  relations
    define organization: [organization]
    define parent: [department]   # 部门可以有父部门
    define manager: [user]
    define member: [organization#member] or member from parent  # 继承父部门的成员

type project
  relations
    define department: [department]  # 项目属于部门
    define parent: [project]         # 项目可以有子项目
    define owner: [department#manager, department#member]
    define editor: [user] or owner or editor from parent  # 继承父项目的编辑权限
    define viewer: [user] or editor or viewer from parent  # 继承父项目的查看权限

type document
  relations
    define project: [project]
    define owner: [user]
    define editor: [user] or owner or editor from project  # 继承项目的编辑权限
    define viewer: [user] or editor or viewer from project   # 继承项目的查看权限
```

#### 权限继承路径示例

假设有以下层级结构：

```
organization:acme
  └── department:engineering
        ├── project:website
        │     └── document:homepage
        └── project:mobile-app
              └── document:spec
```

如果设置以下权限：

```javascript
// Alice 是工程部门的成员
await fgaClient.write({
  writes: [
    { user: "user:alice", relation: "member", object: "organization:acme" },
    {
      user: "department:engineering",
      relation: "department",
      object: "organization:acme",
    },
    {
      user: "project:website",
      relation: "project",
      object: "department:engineering",
    },
    {
      user: "document:homepage",
      relation: "project",
      object: "project:website",
    },
  ],
});
```

那么 Alice 自动拥有：

- `document:homepage` 的查看权限（通过 organization → department → project → document）
- `project:website` 的查看权限（通过 organization → department → project）
- `department:engineering` 的成员关系

### 8.4.2 权限继承机制

#### 继承方向

OpenFGA 支持两种继承方向：

**1. 向上继承（From Parent）**
子资源继承父资源的权限。

```openfga
type document
  relations
    define parent: [folder]
    define viewer: [user] or viewer from parent  # 继承父文件夹的查看者
```

**2. 向下传播（To Children）**
父资源的权限传播到子资源。

```openfga
type folder
  relations
    define viewer: [user]
    define children: [document]  # 文件夹包含文档

type document
  relations
    define folder: [folder]
    define viewer: [folder#viewer]  # 继承文件夹的查看者
```

实际应用中，通常使用向上继承模式，因为它更符合直觉。

#### 多重继承

资源可以同时从多个来源继承权限：

```openfga
type document
  relations
    define folder: [folder]
    define project: [project]
    define team: [team]

    # 从多个来源继承权限
    define viewer: [user]
      or viewer from folder
      or viewer from project
      or viewer from team
```

#### 权限覆盖

子资源可以定义更严格的权限，覆盖继承的权限：

```openfga
type folder
  relations
    define viewer: [user]

type document
  relations
    define parent: [folder]
    define restricted: [document]  # 受限制标记

    # 受限文档不继承父文件夹权限
    define viewer: [user] or (viewer from parent and not restricted)
```

### 8.4.3 继承关系优化

#### 性能优化策略

深度继承可能导致权限检查时遍历大量关系。以下策略可以帮助优化性能：

**1. 扁平化层级结构**

在特定层级设置直接关系，避免过深的继承链：

```openfga
type organization
  relations
    define member: [user]

type document
  relations
    define organization: [organization]
    define folder: [folder]

    # 同时继承组织和文件夹权限，但组织权限更直接
    define viewer: [user]
      or organization#member
      or viewer from folder
```

**2. 使用计算关系缓存中间结果**

```openfga
type project
  relations
    define organization: [organization]
    define can_view_documents: organization#member  # 计算关系，缓存组织成员关系

type document
  relations
    define project: [project]
    define viewer: [user] or project#can_view_documents  # 直接引用计算关系
```

**3. 限制继承深度**

在授权模型中限制继承的最大深度，避免无限递归：

```openfga
type folder
  relations
    define parent: [folder]
    define level_1_viewer: [user]  # 一级查看者
    define level_2_viewer: level_1_viewer or level_1_viewer from parent  # 二级继承
    define viewer: level_2_viewer  # 最多继承两级
```

#### 查询优化

**使用 ListObjects API 时指定类型过滤：**

```javascript
// 列出用户有查看权限的所有文档（包括通过继承获得的）
const { objects } = await fgaClient.listObjects(
  {
    user: "user:alice",
    relation: "viewer",
    type: "document",
  },
  {
    authorizationModelId: MODEL_ID,
  }
);
```

**查询特定层级的资源：**

```javascript
// 只查询直接分配的权限，不包括继承的
async function getDirectPermissions(userId, type) {
  // 需要使用 Read API 查询直接关系
  const { tuples } = await fgaClient.read({
    user: `user:${userId}`,
    type: type,
  });

  return tuples.map((t) => t.key.object);
}
```

#### 层级权限最佳实践

1. **合理设计层级深度**：避免过深的继承层级影响性能
2. **明确继承规则**：在授权模型中清晰地定义继承关系
3. **使用计算关系**：对复杂的继承路径使用计算关系简化
4. **定期验证**：定期检查继承关系的正确性
5. **文档化**：记录层级关系和继承规则的业务含义

---

## 8.5 复杂业务场景的建模方法

在实际项目中，授权需求往往非常复杂，涉及多种实体类型、多层次的权限关系和动态的权限规则。如何分析业务场景并设计出合适的授权模型，是本章要解决的核心问题。

### 8.5.1 场景分析方法

#### 步骤一：识别实体和类型

首先，我们需要识别系统中的所有实体类型。常见的实体类型包括：

- **用户相关**：user、group、role、team
- **资源相关**：document、file、project、workspace
- **组织相关**：organization、department、tenant
- **容器相关**：folder、category、collection

**示例：文档协作系统**

识别出的实体类型：

- user（用户）
- organization（组织）
- workspace（工作空间）
- folder（文件夹）
- document（文档）
- comment（评论）

#### 步骤二：识别关系

识别实体之间的所有可能关系：

**文档协作系统的关系：**

```
user ↔ organization: member, admin
user ↔ workspace: owner, member, viewer
user ↔ folder: owner, viewer
user ↔ document: owner, editor, viewer, commenter
user ↔ comment: author
organization ↔ workspace: owns
workspace ↔ folder: contains
folder ↔ document: contains
folder ↔ folder: parent
document ↔ comment: has
```

#### 步骤三：识别权限需求

分析每种实体需要哪些权限操作：

**文档的权限需求：**

- 查看文档（view）
- 编辑文档（edit）
- 删除文档（delete）
- 分享文档（share）
- 评论文档（comment）
- 下载文档（download）
- 打印文档（print）

#### 步骤四：识别业务规则

分析权限的业务规则和约束：

**示例规则：**

1. 文档所有者可以执行所有操作
2. 编辑者可以编辑文档，但不能删除
3. 查看者只能查看，不能修改
4. 文档继承父文件夹的查看权限
5. 组织管理员可以管理组织内的所有资源
6. 工作空间成员默认拥有工作空间内所有文档的查看权限

### 8.5.2 模型设计步骤

#### 步骤一：定义基础类型和关系

从最基础的类型开始定义：

```openfga
model
  schema 1.1

type user

type organization
  relations
    define member: [user]
    define admin: [user]
```

#### 步骤二：逐步扩展类型

逐步添加更多类型和关系：

```openfga
type workspace
  relations
    define organization: [organization]
    define owner: [user]
    define member: [organization#member]
    define viewer: [user] or member
```

#### 步骤三：添加权限计算规则

为权限关系添加计算规则：

```openfga
type document
  relations
    define workspace: [workspace]
    define folder: [folder]
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor or viewer from folder or workspace#viewer

    # 权限映射
    define can_view: viewer
    define can_edit: editor
    define can_delete: owner
    define can_share: owner or editor
    define can_comment: viewer
```

#### 步骤四：验证和优化

使用测试用例验证模型的正确性：

```javascript
async function validateModel() {
  // 测试用例 1：文档所有者可以删除
  const test1 = await fgaClient.check({
    user: "user:alice",
    relation: "can_delete",
    object: "document:1",
  });
  console.assert(test1.allowed === true);

  // 测试用例 2：编辑者不能删除
  const test2 = await fgaClient.check({
    user: "user:bob",
    relation: "can_delete",
    object: "document:1",
  });
  console.assert(test2.allowed === false);

  // 测试用例 3：文件夹的查看者可以查看子文档
  const test3 = await fgaClient.check({
    user: "user:charlie",
    relation: "can_view",
    object: "document:2",
  });
  console.assert(test3.allowed === true);
}
```

### 8.5.3 案例分析

#### 案例一：GitHub 风格的代码仓库系统

**业务场景：**

- 用户可以创建组织
- 组织可以有多个代码仓库
- 仓库可以有协作者（collaborator）
- 仓库可以被组织成员访问
- 仓库可以有分支和保护规则

**授权模型设计：**

```openfga
model
  schema 1.1

type user

type organization
  relations
    define member: [user]
    define owner: [user]

type repository
  relations
    define organization: [organization]
    define owner: [user]
    define collaborator: [user]
    define member: [organization#member]

    # 基础权限
    define can_read: owner or collaborator or member
    define can_write: owner or collaborator
    define can_admin: owner
    define can_maintain: owner or collaborator

    # 细粒度权限
    define can_create_branch: can_write
    define can_delete_branch: owner
    define can_push: can_write
    define can_merge: can_write
    define can_manage_settings: can_admin

type branch
  relations
    define repository: [repository]
    define protected: [branch]  # 保护标记
    define can_push: [repository#can_write] and not protected  # 非保护分支可以推送
    define can_merge: [repository#can_merge]
    define can_delete: [repository#can_admin] and not protected  # 只有管理员可以删除非保护分支
```

**实现代码：**

```javascript
// 检查是否可以推送到分支
async function canPushToBranch(userId, branchId, repositoryId) {
  const { allowed } = await fgaClient.check(
    {
      user: `user:${userId}`,
      relation: "can_push",
      object: `branch:${branchId}`,
      contextualTuples: [
        {
          user: `branch:${branchId}`,
          relation: "repository",
          object: `repository:${repositoryId}`,
        },
      ],
    },
    {
      authorizationModelId: MODEL_ID,
    }
  );

  return allowed;
}
```

#### 案例二：Slack 风格的团队协作系统

**业务场景：**

- 工作空间（Workspace）包含多个频道（Channel）
- 频道可以是公开的或私有的
- 用户可以加入/离开频道
- 频道有管理员
- 用户可以发送消息、编辑自己的消息、删除消息

**授权模型设计：**

```openfga
model
  schema 1.1

type user

type workspace
  relations
    define owner: [user]
    define admin: [user]
    define member: [user]

type channel
  relations
    define workspace: [workspace]
    define public: [channel]  # 标记为公开频道
    define member: [user]
    define admin: [user] or workspace#admin

    # 公开频道所有工作空间成员可以查看，私有频道只有成员可以查看
    define can_view: (workspace#member and public) or member or admin
    define can_join: workspace#member
    define can_leave: member
    define can_invite: admin or member
    define can_manage: admin

type message
  relations
    define channel: [channel]
    define author: [user]
    define can_view: [channel#can_view]
    define can_create: [channel#member]
    define can_edit: author
    define can_delete: author or channel#can_manage
    define can_react: can_view  # 可以查看就可以反应
```

#### 案例三：AWS IAM 风格的多账户系统

**业务场景：**

- 多个账户（Account）
- 账户下有角色（Role）和策略（Policy）
- 用户可以承担角色
- 角色有权限策略
- 资源有资源策略

**授权模型设计：**

```openfga
model
  schema 1.1

type user

type account
  relations
    define owner: [user]
    define user: [user]

type role
  relations
    define account: [account]
    define principal: [user, role#principal]  # 可以承担角色的主体
    define assumed_by: [user]  # 当前承担该角色的用户

    define can_assume: principal and account#user

type policy
  relations
    define attached_to_role: [role]
    define attached_to_user: [user]

    define effect_allow: attached_to_role#can_assume or attached_to_user

type resource
  relations
    define account: [account]
    define resource_policy: [policy]

    # 权限检查：主体权限或资源策略允许
    define can_access: account#user or resource_policy#effect_allow
```

### 复杂场景建模最佳实践

1. **自下而上设计**：从基础类型开始，逐步添加复杂关系
2. **用例驱动**：根据实际用例设计权限模型，避免过度设计
3. **迭代优化**：先实现核心功能，再逐步完善细节
4. **测试验证**：为每个业务规则编写测试用例
5. **文档化**：记录设计决策和业务规则的含义

---

## 8.6 与身份提供者（IdP）的集成

在现代企业应用中，身份认证和授权通常由不同的系统负责。身份提供者（Identity Provider, IdP）负责用户认证，而授权系统（如 OpenFGA）负责权限管理。如何将两者无缝集成，是构建企业级授权系统的关键。

### 8.6.1 IdP 集成概述

#### 身份提供者的作用

身份提供者（IdP）的主要职责：

1. **用户认证**：验证用户身份（用户名密码、SSO、OAuth 等）
2. **身份信息管理**：管理用户属性、角色、组织等信息
3. **单点登录（SSO）**：提供跨应用的统一登录体验
4. **用户生命周期管理**：用户的创建、更新、删除等

#### OpenFGA 与 IdP 的集成模式

常见的集成模式包括：

**模式一：IdP → OpenFGA 单向同步**

- IdP 将用户、角色、组织信息同步到 OpenFGA
- OpenFGA 仅负责权限检查
- 适用于 IdP 作为主数据源的场景

**模式二：OpenFGA 主动查询 IdP**

- OpenFGA 在权限检查时查询 IdP 获取用户信息
- 使用上下文元组传递 IdP 信息
- 适用于实时性要求高的场景

**模式三：混合模式**

- 基础用户信息同步到 OpenFGA
- 动态信息（如当前组织上下文）通过上下文元组传递
- 平衡性能和灵活性

### 8.6.2 OAuth2/OIDC 集成

OAuth 2.0 和 OpenID Connect（OIDC）是现代应用最常用的认证协议。

#### OAuth2/OIDC 流程概述

典型的 OAuth2/OIDC 流程：

1. 用户在 IdP 登录
2. IdP 返回访问令牌（Access Token）和 ID 令牌（ID Token）
3. 应用验证令牌并提取用户信息
4. 使用用户信息进行 OpenFGA 权限检查

#### 集成实现

**步骤一：解析 JWT Token**

```python
import jwt
from jwt import PyJWKClient
from typing import Dict
import os

# 初始化 JWKS 客户端
jwks_client = PyJWKClient("https://your-idp.com/.well-known/jwks.json")


async def verify_token(token: str) -> Dict:
    """
    验证并解析JWT token
    
    参数:
        token: JWT token字符串
        
    返回:
        dict: 解码后的token payload
        
    异常:
        jwt.InvalidTokenError: token无效时抛出
    """
    try:
        # 获取签名密钥
        signing_key = jwks_client.get_signing_key_from_jwt(token)
        
        # 验证并解码token
        decoded = jwt.decode(
            token,
            signing_key.key,
            algorithms=["RS256"],
            audience=os.getenv("OAUTH_CLIENT_ID"),
            issuer=os.getenv("OAUTH_ISSUER"),
        )
        
        return decoded
        
    except jwt.InvalidTokenError as e:
        raise ValueError(f"Invalid token: {str(e)}")
```

> **代码说明：**
>
> 1. **功能说明**：使用PyJWT库验证和解析JWT token
> 2. **关键步骤**：
>    - 从JWKS端点获取公钥
>    - 验证token签名、audience和issuer
>    - 解码token获取payload
> 3. **注意事项**：
>    - 需要安装PyJWT库：`pip install PyJWT cryptography`
>    - 签名验证确保token来自可信的IdP
> 4. **扩展方向**：可以添加token缓存以提升性能

**步骤二：提取用户和上下文信息**

```python
from typing import Dict, List

async def extract_user_context(token: str) -> Dict:
    """
    从token中提取用户上下文信息
    
    参数:
        token: JWT token字符串
        
    返回:
        dict: 包含用户ID、email、组织、角色和组信息的字典
    """
    decoded = await verify_token(token)
    
    return {
        'user_id': decoded['sub'],
        'email': decoded.get('email'),
        'organizations': decoded.get('org_ids', []),
        'roles': decoded.get('roles', []),
        'groups': decoded.get('groups', []),
    }
```

> **代码说明：**
>
> 1. **功能说明**：从验证过的token中提取用户和上下文信息
> 2. **关键步骤**：解析token的标准声明和自定义声明
> 3. **注意事项**：使用 `get()` 方法避免缺少可选字段时抛出异常

**步骤三：同步用户信息到 OpenFGA**

```python
from openfga_sdk import ClientWriteRequest, ClientTuple
from typing import Dict, List

async def sync_user_to_openfga(user_context: Dict):
    """
    同步用户信息到OpenFGA
    
    参数:
        user_context: 用户上下文信息字典
    """
    # 确保用户存在（OpenFGA 用户会在首次关系元组中自动创建）
    
    writes: List[ClientTuple] = []
    
    # 同步组织成员关系
    for org_id in user_context['organizations']:
        writes.append(
            ClientTuple(
                user=f"user:{user_context['user_id']}",
                relation="member",
                object=f"organization:{org_id}"
            )
        )
    
    # 同步角色关系（假设角色属于第一个组织）
    if user_context['organizations'] and user_context['roles']:
        first_org = user_context['organizations'][0]
        for role in user_context['roles']:
            writes.append(
                ClientTuple(
                    user=f"user:{user_context['user_id']}",
                    relation=role,
                    object=f"organization:{first_org}"
                )
            )
    
    if writes:
        body = ClientWriteRequest(writes=writes)
        options = {"authorization_model_id": "MODEL_ID"}
        response = await fga_client.write(body, options)
        return response
```

> **代码说明：**
>
> 1. **功能说明**：将token中的用户信息同步到OpenFGA
> 2. **关键步骤**：
>    - 创建组织成员关系
>    - 创建用户角色关系
>    - 批量写入OpenFGA
> 3. **注意事项**：
>    - 应该定期同步，而不是每次请求都同步
>    - 考虑使用后台任务或webhook触发同步
> 4. **扩展方向**：可以添加增量同步逻辑，只更新变化的关系

**步骤四：使用上下文元组进行权限检查**

```python
from openfga_sdk import ClientCheckRequest, ClientTuple
from typing import List

async def check_permission_with_oauth(token: str, resource_id: str, relation: str) -> bool:
    """
    使用OAuth上下文进行权限检查
    
    参数:
        token: JWT token
        resource_id: 资源ID
        relation: 关系名称
        
    返回:
        bool: 是否允许访问
    """
    user_context = await extract_user_context(token)
    
    # 构建上下文元组
    contextual_tuples: List[ClientTuple] = []
    
    # 添加组织成员关系
    for org_id in user_context['organizations']:
        contextual_tuples.extend([
            ClientTuple(
                user=f"user:{user_context['user_id']}",
                relation="member",
                object=f"organization:{org_id}"
            ),
            # 当前组织上下文
            ClientTuple(
                user=f"user:{user_context['user_id']}",
                relation="user_in_context",
                object=f"organization:{org_id}"
            ),
        ])
    
    # 添加角色关系
    if user_context['organizations'] and user_context['roles']:
        first_org = user_context['organizations'][0]
        for role in user_context['roles']:
            contextual_tuples.append(
                ClientTuple(
                    user=f"user:{user_context['user_id']}",
                    relation=role,
                    object=f"organization:{first_org}"
                )
            )
    
    body = ClientCheckRequest(
        user=f"user:{user_context['user_id']}",
        relation=relation,
        object=resource_id,
        contextual_tuples=contextual_tuples,
    )
    
    options = {"authorization_model_id": "MODEL_ID"}
    response = await fga_client.check(body, options)
    
    return response.allowed
```

> **代码说明：**
>
> 1. **功能说明**：使用OAuth token上下文进行权限检查
> 2. **关键步骤**：
>    - 提取token中的用户上下文
>    - 构建上下文元组数组（包含组织成员关系和当前上下文）
>    - 添加角色关系到上下文元组
>    - 执行权限检查
> 3. **注意事项**：
>    - 上下文元组不会持久化到数据库
>    - 适合频繁变化的上下文信息
>    - 每个请求都会重新构建上下文元组
> 4. **扩展方向**：
>    - 可以添加缓存机制优化性能
>    - 可以增加更多上下文信息（如IP、设备类型等）
> 5. **实际应用**：这是Web应用中OAuth2集成的标准模式

#### FastAPI 中间件示例

```python
from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Optional, Callable
import functools

app = FastAPI()
security = HTTPBearer()


async def openfga_auth_middleware(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    """
    OpenFGA认证中间件
    
    参数:
        credentials: HTTP Bearer认证凭据
        
    返回:
        dict: 用户上下文信息
        
    异常:
        HTTPException: 认证失败时抛出
    """
    try:
        # 1. 获取并验证 token
        token = credentials.credentials
        if not token:
            raise HTTPException(status_code=401, detail="Missing token")
        
        # 2. 解析用户上下文
        user_context = await extract_user_context(token)
        
        # 3. 同步用户信息到 OpenFGA（可选，可以定期同步）
        # await sync_user_to_openfga(user_context)
        
        return user_context
        
    except ValueError as e:
        raise HTTPException(status_code=401, detail=f"Invalid token: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=401, detail="Authentication failed")


def check_permission(relation: str):
    """
    权限检查装饰器工厂
    
    参数:
        relation: 需要检查的权限关系
        
    返回:
        装饰器函数
    """
    def decorator(func: Callable):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # 从kwargs中获取request和user_context
            request: Request = kwargs.get('request')
            user_context: dict = kwargs.get('user_context')
            
            # 获取资源ID
            resource_id = kwargs.get('id') or kwargs.get('resource_id')
            if not resource_id:
                raise HTTPException(status_code=400, detail="Resource ID required")
            
            try:
                # 获取token
                auth_header = request.headers.get('authorization', '')
                token = auth_header.replace('Bearer ', '')
                
                # 检查权限
                allowed = await check_permission_with_oauth(
                    token,
                    f"document:{resource_id}",
                    relation
                )
                
                if not allowed:
                    raise HTTPException(status_code=403, detail="Permission denied")
                
                return await func(*args, **kwargs)
                
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(
                    status_code=500,
                    detail=f"Authorization check failed: {str(e)}"
                )
        
        return wrapper
    return decorator


# 使用示例
@app.get("/api/documents/{id}")
async def get_document(
    id: str,
    request: Request,
    user_context: dict = Depends(openfga_auth_middleware)
):
    """获取文档"""
    # 检查权限
    token = request.headers.get('authorization', '').replace('Bearer ', '')
    allowed = await check_permission_with_oauth(token, f"document:{id}", "can_view")
    
    if not allowed:
        raise HTTPException(status_code=403, detail="Permission denied")
    
    return {"message": f"Document {id} retrieved"}


@app.put("/api/documents/{id}")
async def update_document(
    id: str,
    request: Request,
    user_context: dict = Depends(openfga_auth_middleware)
):
    """更新文档"""
    token = request.headers.get('authorization', '').replace('Bearer ', '')
    allowed = await check_permission_with_oauth(token, f"document:{id}", "can_edit")
    
    if not allowed:
        raise HTTPException(status_code=403, detail="Permission denied")
    
    return {"message": f"Document {id} updated"}
```

> **代码说明：**
>
> 1. **功能说明**：使用FastAPI实现完整的OAuth2/OIDC集成
> 2. **关键步骤**：
>    - 使用HTTPBearer自动处理Bearer token
>    - 认证中间件提取和验证用户上下文
>    - 在路由处理函数中进行权限检查
> 3. **注意事项**：
>    - 使用Depends实现依赖注入
>    - 异常处理确保返回正确的HTTP状态码
> 4. **扩展方向**：
>    - 可以实现装饰器简化权限检查
>    - 添加权限缓存机制
>    - 集成请求日志和审计
> 5. **实际应用**：适用于生产环境的完整OAuth2集成方案

### 8.6.3 SAML 集成

SAML（Security Assertion Markup Language）是企业级 SSO 常用的协议。

#### SAML 断言处理

```python
from onelogin.saml2.auth import OneLogin_Saml2_Auth
from onelogin.saml2.settings import OneLogin_Saml2_Settings
from typing import Dict
import os

async def process_saml_response(saml_response: str, request_data: Dict) -> Dict:
    """
    处理SAML响应并提取用户信息
    
    参数:
        saml_response: SAML响应字符串
        request_data: HTTP请求数据
        
    返回:
        dict: 包含用户信息的字典
        
    异常:
        ValueError: SAML验证失败时抛出
    """
    # SAML配置
    saml_settings = {
        'sp': {
            'entityId': os.getenv('SAML_ENTITY_ID'),
            'assertionConsumerService': {
                'url': os.getenv('SAML_ASSERT_ENDPOINT'),
                'binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST'
            },
            'x509cert': os.getenv('SAML_CERTIFICATE'),
            'privateKey': os.getenv('SAML_PRIVATE_KEY'),
        },
        'idp': {
            'entityId': os.getenv('SAML_IDP_ENTITY_ID'),
            'singleSignOnService': {
                'url': os.getenv('SAML_SSO_URL'),
                'binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'
            },
            'singleLogoutService': {
                'url': os.getenv('SAML_SLO_URL'),
                'binding': 'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect'
            },
            'x509cert': os.getenv('SAML_IDP_CERTIFICATE'),
        },
        'security': {
            'wantAssertionsEncrypted': False,
            'wantMessagesSigned': True,
        }
    }
    
    # 初始化SAML认证
    auth = OneLogin_Saml2_Auth(request_data, saml_settings)
    
    # 处理SAML响应
    auth.process_response()
    
    # 验证响应
    errors = auth.get_errors()
    if errors:
        raise ValueError(f"SAML validation failed: {', '.join(errors)}")
    
    if not auth.is_authenticated():
        raise ValueError("SAML authentication failed")
    
    # 提取用户属性
    attributes = auth.get_attributes()
    
    return {
        'user_id': auth.get_nameid(),
        'email': attributes.get('email', [None])[0],
        'organizations': attributes.get('organization_ids', []),
        'roles': attributes.get('roles', []),
    }
```

> **代码说明：**
>
> 1. **功能说明**：使用python3-saml库处理SAML断言
> 2. **关键步骤**：
>    - 配置SAML服务提供者和身份提供者
>    - 验证SAML响应的签名和有效性
>    - 提取用户属性
> 3. **注意事项**：
>    - 需要安装python3-saml: `pip install python3-saml`
>    - SAML证书需要正确配置
>    - 务必验证响应的签名
> 4. **扩展方向**：可以添加自定义属性映射逻辑

#### SAML 与 OpenFGA 集成

```python
import secrets
from datetime import datetime, timedelta
from typing import Dict

async def authenticate_with_saml(saml_response: str, request_data: Dict) -> Dict:
    """
    使用SAML进行认证并集成OpenFGA
    
    参数:
        saml_response: SAML响应字符串
        request_data: HTTP请求数据
        
    返回:
        dict: 包含会话token和用户ID的字典
    """
    # 1. 处理 SAML 响应
    user_context = await process_saml_response(saml_response, request_data)
    
    # 2. 同步到 OpenFGA
    await sync_user_to_openfga(user_context)
    
    # 3. 生成会话 token（可选）
    session_token = generate_session_token(user_context)
    
    return {
        'session_token': session_token,
        'user_id': user_context['user_id'],
    }


def generate_session_token(user_context: Dict) -> str:
    """
    生成会话token
    
    参数:
        user_context: 用户上下文信息
        
    返回:
        str: 会话token
    """
    # 生成安全的随机token
    token = secrets.token_urlsafe(32)
    
    # 这里应该将token存储到Redis或数据库中
    # 并关联用户上下文和过期时间
    # 示例：
    # await redis.setex(
    #     f"session:{token}",
    #     timedelta(hours=24),
    #     json.dumps(user_context)
    # )
    
    return token
```

> **代码说明：**
>
> 1. **功能说明**：完整的SAML认证与OpenFGA集成流程
> 2. **关键步骤**：
>    - 处理和验证SAML响应
>    - 同步用户信息到OpenFGA
>    - 生成会话token
> 3. **注意事项**：
>    - 会话token应该安全存储（如Redis）
>    - 设置合理的token过期时间
>    - 考虑token刷新机制
> 4. **扩展方向**：
>    - 实现token刷新逻辑
>    - 添加单点登出（SLO）支持
>    - 集成会话管理
> 5. **实际应用**：适用于企业级SAML SSO集成

### IdP 集成最佳实践

1. **Token 验证**：始终验证 IdP 返回的 token 签名和有效期
2. **定期同步**：定期同步用户信息到 OpenFGA，避免实时查询延迟
3. **错误处理**：妥善处理 IdP 不可用的情况，考虑降级策略
4. **缓存策略**：缓存用户信息和权限检查结果，提升性能
5. **审计日志**：记录所有认证和授权活动，便于审计和问题排查

---

## 本章小结

本章深入探讨了 OpenFGA 的高级授权模式，为读者提供了应对复杂授权需求的完整解决方案。

**核心内容回顾：**

首先，我们学习了**多租户系统的授权设计**。多租户是现代 SaaS 应用的标准架构，本章介绍了单 Store 多租户和多 Store 多租户两种策略，重点讲解了如何在单个 Store 中通过类型级别的租户关系实现严格的数据隔离和权限隔离。通过租户关联、权限组合验证和上下文提供等方法，我们可以构建安全可靠的多租户授权架构。

接下来，我们探讨了**基于上下文的动态权限控制**。通过上下文元组和条件关系元组，OpenFGA 支持依赖动态上下文信息（如时间、IP 地址、组织上下文）的权限决策。我们学习了组织上下文授权、基于时间和 IP 的访问控制、JWT Token 声明集成等实际应用场景，掌握了动态权限控制的实现方法和最佳实践。

然后，我们研究了**细粒度访问控制的实现**。细粒度控制允许对资源、字段和操作进行精确的权限管理。通过资源级、字段级和操作级的权限设计，结合应用层的过滤逻辑，我们可以实现灵活且安全的细粒度访问控制。我们还学习了使用 BatchCheck API 优化性能、GraphQL 字段级授权等高级技巧。

随后，我们深入探讨了**层级权限和继承关系**。层级权限使得子资源可以继承父资源的权限，这是文件系统、组织架构等场景中的常见需求。我们学习了基础层级模型、多层继承、权限继承机制和查询优化策略，掌握了如何设计高效且正确的权限继承关系。

接着，我们介绍了**复杂业务场景的建模方法**。通过场景分析、模型设计和案例分析，我们学习了如何系统性地分析业务需求并设计合适的授权模型。GitHub 风格的代码仓库系统、Slack 风格的团队协作系统、AWS IAM 风格的多账户系统等案例展示了不同场景下的模型设计思路。

最后，我们讲解了**与身份提供者（IdP）的集成**。在现代应用中，身份认证和授权通常由不同系统负责。本章介绍了 OAuth2/OIDC 和 SAML 两种主流协议的集成方法，包括 token 解析、用户信息同步、上下文元组使用和中间件实现等实践。

**关键要点：**

1. 多租户隔离是 SaaS 应用的核心安全要求，需要严格的租户关联和权限组合验证
2. 上下文权限使得授权系统能够适应动态的业务需求，但需要注意性能和缓存策略
3. 细粒度访问控制提供了精确的权限管理能力，但需要平衡模型复杂度和性能
4. 层级权限继承简化了权限管理，但需要合理设计层级深度和继承规则
5. 复杂场景建模需要系统性的分析方法，用例驱动和迭代优化是关键
6. IdP 集成实现了认证和授权的分离，需要妥善处理 token 验证、同步策略和错误处理

**学习路径：**

在下一章中，我们将学习 OpenFGA 的性能优化与扩展策略，包括授权决策的性能优化、缓存机制设计、数据库查询优化、高可用性架构设计等，帮助读者构建高性能、可扩展的授权系统。

---

## 实践练习

### 基础练习

1. **设计题：多租户 SaaS 应用的授权模型设计**

   设计一个多租户项目管理系统的授权模型，要求：

   - 支持组织（Organization）、项目（Project）、任务（Task）三层结构
   - 实现严格的租户数据隔离
   - 支持项目所有者、成员、查看者三种角色
   - 任务继承项目的权限

   请完成：

   - 编写完整的授权模型
   - 提供初始化关系元组的代码示例
   - 实现权限检查函数

2. **实现题：基于上下文的动态权限控制**

   实现一个基于时间的文档访问控制系统：

   - 文档只能在指定时间段内访问（如 9:00-18:00）
   - 需要从 JWT token 中提取当前时间
   - 使用上下文元组提供时间上下文

   请完成：

   - 设计授权模型（使用条件关系元组或上下文元组）
   - 实现权限授予和检查的完整代码
   - 编写测试用例验证功能

### 进阶练习

3. **综合题：细粒度权限控制系统**

   设计并实现一个支持字段级和操作级权限的文档管理系统：

   - 支持字段级权限（标题、内容、元数据、价格等）
   - 支持操作级权限（查看、编辑、删除、分享等）
   - 使用 BatchCheck API 优化性能
   - 实现 RESTful API 中间件

   要求：

   - 完整的授权模型设计
   - 字段过滤和操作检查的实现代码
   - API 中间件和路由配置

4. **架构题：层级权限系统设计**

   设计一个多层级组织的权限管理系统：

   - 支持组织、部门、团队三级结构
   - 权限可以继承和覆盖
   - 支持跨层级的权限查询

   要求：

   - 设计支持多级继承的授权模型
   - 实现权限继承查询函数
   - 提供性能优化方案

### 挑战练习

5. **企业级集成题：OAuth2/OIDC 集成**

   实现一个完整的 OAuth2/OIDC 与 OpenFGA 集成方案：

   - JWT token 验证
   - 用户信息同步
   - 上下文元组提取
   - Express.js 中间件实现
   - 错误处理和降级策略

   要求：

   - 完整的集成代码
   - 错误处理机制
   - 性能优化（缓存、批量同步）
   - 单元测试和集成测试

6. **综合案例：GitHub 风格的代码仓库系统**

   设计并实现一个完整的代码仓库授权系统：

   - 组织、仓库、分支的多层级结构
   - 协作者权限管理
   - 分支保护规则
   - 细粒度操作权限

   要求：

   - 完整的授权模型（参考案例一）
   - 所有权限检查函数的实现
   - RESTful API 设计
   - 完整的测试用例

---

## 延伸阅读

### 官方文档

- **多租户最佳实践**：[https://openfga.dev/docs/getting-started/implementation-best-practices](https://openfga.dev/docs/getting-started/implementation-best-practices)

  - OpenFGA 多租户系统的实现指南和最佳实践

- **上下文元组文档**：[https://openfga.dev/docs/modeling/token-claims-contextual-tuples](https://openfga.dev/docs/modeling/token-claims-contextual-tuples)

  - 上下文元组的使用场景和实现方法

- **组织上下文授权**：[https://openfga.dev/docs/modeling/organization-context-authorization](https://openfga.dev/docs/modeling/organization-context-authorization)

  - 多组织系统的授权设计模式

- **条件关系元组**：[https://openfga.dev/docs/modeling/conditions](https://openfga.dev/docs/modeling/conditions)
  - 条件关系元组和 ABAC 实现

### 相关技术文档

- **OAuth 2.0 规范**：[RFC 6749](https://tools.ietf.org/html/rfc6749)

  - OAuth 2.0 授权框架标准规范

- **OpenID Connect 规范**：[OpenID Connect Core](https://openid.net/specs/openid-connect-core-1_0.html)

  - OIDC 身份认证协议规范

- **SAML 2.0 规范**：[SAML 2.0 Technical Overview](https://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html)
  - SAML 2.0 技术概览

### 学习建议

在实践过程中，建议：

1. **从简单场景开始**：先实现基础的多租户隔离，再逐步添加复杂功能
2. **重视性能测试**：对权限检查进行性能测试，识别瓶颈并优化
3. **完善错误处理**：考虑各种异常情况，实现健壮的错误处理机制
4. **编写测试用例**：为每个授权规则编写测试用例，确保正确性
5. **关注安全最佳实践**：遵循最小权限原则，实现严格的租户隔离
