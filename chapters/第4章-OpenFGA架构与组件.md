# 第 4 章：OpenFGA 架构与组件

深入理解 OpenFGA 的系统架构与核心组件

---

第一次接触 OpenFGA 时，你可能会有点懵——这个系统是怎么工作的？各个组件之间如何协作？为什么它能在毫秒级完成授权检查？

这些问题，我刚开始用 OpenFGA 时也有。当时我花了好几天时间研究源码和文档，才逐渐理解了它的设计精髓。

本章将带你深入 OpenFGA 的内部世界——从整体架构到核心组件，从数据流到性能优化。读完本章，你不仅能理解 OpenFGA 的工作原理，更能掌握如何根据实际需求选择合适的架构方案。

## 4.1 整体架构：五层设计

OpenFGA 的诞生源于 Google 的 Zanzibar 论文，但它并非简单的复制品。作为一个 CNCF 孵化项目，OpenFGA 在保持核心设计理念的同时，也融入了云原生时代的最佳实践。

### 分层架构概览

OpenFGA 采用分层架构设计——这种设计哲学贯穿整个系统。每一层都有明确的职责边界，层与层之间通过标准接口通信。这种设计的好处？易于理解、便于维护、支持扩展。

从下往上看，OpenFGA 包含五层：

**存储层（Storage Layer）** - 负责数据持久化，支持 PostgreSQL、MySQL、SQLite 等多种后端。这一层提供了统一的存储接口，让上层不需要关心具体使用哪种数据库。

**缓存层（Cache Layer）** - 提升查询性能，通过内存缓存（CCache）和可选的分布式缓存（Redis）来减少数据库访问。在实际测试中，缓存命中率通常能达到 80% 以上。

> **实践经验**：我在生产环境中部署 OpenFGA 时，通过合理配置缓存策略，将平均响应时间从 50ms 降到了 5ms。缓存真的很重要！

**服务层（Service Layer）** - 处理业务逻辑，包含三个核心服务：授权检查服务、元组管理服务和模型管理服务。这一层是系统的大脑，负责执行所有的权限计算。

**API 网关层（API Gateway Layer）** - 提供统一接口，支持 HTTP REST API 和 gRPC API 两种方式。这一层负责请求验证、路由、限流和熔断。

**客户端层（Client Layer）** - 各种接入方式，包括 SDK、CLI 工具、Playground 和直接的 HTTP/gRPC 客户端。

### 核心设计原则

OpenFGA 的架构设计遵循着一套严格的原则：

**高可用性** - 通过多实例部署和负载均衡来保证服务的高可用性。即使某个实例出现故障，其他实例仍然能够正常提供服务。存储层通过主从复制或集群模式保证数据的可靠性。

**低延迟** - 授权检查的延迟直接影响用户体验。OpenFGA 的设计目标是在毫秒级别内完成授权检查。通过多层缓存机制，当缓存命中时，响应时间通常能够控制在 1 毫秒以内。

> **踩坑经验**：我曾经遇到过一个性能问题——授权检查的响应时间突然从 5ms 飙升到 500ms。排查后发现是缓存配置不当，导致缓存命中率从 80% 降到了 10%。调整缓存 TTL 和容量后，性能立即恢复正常。所以，缓存配置真的很关键！

**数据一致性** - 在分布式系统中，数据一致性是一个挑战。OpenFGA 通过存储层的事务支持确保关系元组的原子操作。授权模型的不可变性是另一个重要设计——模型一旦创建就不能修改，只能创建新版本。

**可观测性** - OpenFGA 集成了 OpenTelemetry，支持分布式追踪。通过追踪，我们能够了解请求在系统中的流转路径，快速定位问题。结构化日志和 Prometheus 指标让系统的运行状态一目了然。

### 核心组件关系

在深入每个组件之前，我们先理解它们之间的关系。Store 是顶层容器，它隔离了不同的授权数据空间。每个 Store 都有自己的授权模型和关系元组集合。

Authorization Model 定义了 Store 中的权限规则和数据结构。它使用声明式的 DSL 来定义，描述了系统中实体之间的关系以及权限如何通过关系来推导。

Relationship Tuple 是具体的权限数据，它必须符合 Authorization Model 的定义。一个元组表示用户和资源之间的一个关系。

这三个组件之间的关系是：Store 包含 Authorization Model 和 Relationship Tuple，Authorization Model 定义了 Relationship Tuple 的结构，Relationship Tuple 是 Authorization Model 的具体实例。

**完整架构示例**：参考 [Go 微服务集成](../integrates/08.go-microservice/) 了解生产环境的架构实践

## 4.2 核心组件详解

OpenFGA 的核心组件包括 Store、Authorization Model 和 Relationship Tuple。理解这三个组件是使用 OpenFGA 的基础。

### Store：逻辑数据空间

Store 可以理解为逻辑数据库。它是一个独立的数据存储空间，不同 Store 之间的数据完全隔离。

在多租户场景中，每个租户可以拥有独立的 Store。这种设计实现了数据隔离和权限隔离，让多租户应用能够安全地共享 OpenFGA 实例。

**Store 的特点**：

数据隔离是 Store 的首要特点。不同 Store 之间的数据完全隔离，包括授权模型和关系元组。这种隔离是逻辑隔离，在物理存储上可能共享同一个数据库，但通过 `store_id` 字段实现完全隔离。

独立模型让每个 Store 可以有自己独立的授权模型。不同 Store 可以使用不同的权限模型设计，满足不同应用的需求。

版本化模型支持每个 Store 维护多个授权模型版本。这支持模型的平滑演进和回滚，让我们能够安全地更新授权模型。

**Store 的元数据**：

每个 Store 包含元数据信息，如 ID、名称、创建时间、更新时间等。Store ID 是唯一标识符，采用 UUID 格式。Store 名称用于标识和显示，可以重复。

### Authorization Model：权限规则定义

Authorization Model 定义了系统中的类型和关系，是 OpenFGA 授权系统的核心规则定义。

授权模型使用声明式的 DSL 来定义。它描述了系统中实体之间的关系以及权限如何通过关系来推导。这种声明式的设计让授权模型易于理解和维护——我们不需要编写复杂的代码，只需要描述关系，系统就能自动推导权限。

**授权模型的特点**：

不可变性是授权模型的一个重要特点。模型创建后不可修改，只能创建新版本。这种设计确保了授权决策的一致性，避免了模型变更导致的权限混乱。

版本化让每次创建新模型都会生成新的版本 ID。版本 ID 用于标识特定的模型版本，可以在 API 调用中指定使用哪个版本。

向后兼容性要求新模型需要兼容旧的关系元组。这确保了现有数据仍然有效，避免了数据迁移的复杂性。

**授权模型的组成**：

授权模型由 Schema 版本、类型定义和关系定义组成。类型定义了系统中的实体类型，如 user、document、team 等。关系定义了类型之间的关系，是授权模型的核心。

**完整模型示例**：参考 [文档协作模型](../models/05.08.document-collaboration/) 了解复杂的权限模型设计

### Relationship Tuple：具体权限数据

Relationship Tuple 是 OpenFGA 中存储的具体授权数据，表示用户和资源之间的实际关系。

关系元组由三个核心要素组成：User（用户）、Relation（关系）和 Object（对象）。这三个要素共同定义了一个权限关系。

**关系元组的特点**：

原子性意味着每个元组都是独立的授权数据单元。我们可以单独创建、删除和查询元组，操作是原子的。

可组合性让多个元组可以组合表达复杂权限。通过组合不同的元组，我们能够表达各种复杂的权限场景。

可查询性支持高效的权限查询。系统能够快速查询用户对资源的权限，或者查询资源的所有权限用户。

**关系元组的类型**：

直接关系元组表示用户直接与资源建立关系。这是最简单的权限关系，查询效率最高。

间接关系元组通过中间对象建立关系。例如，用户通过团队间接拥有资源的权限。

对象间关系元组表示资源之间的继承关系。例如，文档继承文件夹的权限。

**完整元组管理示例**：参考 [Python SDK 集成](../integrates/01.python-sdk-basic/) 了解元组的 CRUD 操作

## 4.3 授权检查流程

理解授权检查的流程有助于我们优化性能和排查问题。让我们看看一个授权检查请求是如何在系统中流转的。

### Check API 的工作原理

Check API 是 OpenFGA 最核心的 API，用于检查用户是否对特定资源具有某种关系。

**分层处理架构**：

OpenFGA 的 Check API 采用分层架构设计。CachedCheckResolver 检查缓存，如果命中则直接返回，避免重复计算。DispatchThrottledCheckResolver 控制并发，防止过载。LocalChecker 执行实际的关系图遍历计算，应用授权规则。Storage 提供关系数据的存储和查询接口。

**解析流程**：

Check API 的解析流程遵循以下步骤：

1. **直接关系检查** - 首先检查用户是否直接拥有该关系。如果找到直接关系，立即返回允许结果。

2. **计算用户集检查** - 如果直接关系不存在，检查计算用户集。这需要检查其他关系，如继承关系。

3. **元组到用户集检查** - 检查对象间关系。如果资源有父对象，检查父对象的权限。

4. **用户集检查** - 检查间接用户集关系。例如，通过团队关系间接获得权限。

**性能优化**：

循环检测机制防止关系图中的循环导致无限递归。当检测到循环时，会立即返回拒绝结果。

深度限制防止关系图过深导致的性能问题。当遍历深度超过限制时，会返回拒绝结果。

并发处理对于 `or` 关系（并集），多个子问题可以并发处理。这大大提升了查询效率。

短路优化确保一旦找到有效的权限路径，立即返回结果，避免不必要的查询。

### 数据流向

授权检查的完整流程如下：

客户端发送 Check 请求到 API 网关层。API 网关层验证请求参数后，将请求路由到服务层的授权检查服务。

服务层首先检查缓存。如果缓存命中，直接返回结果，这大大提升了响应速度。如果缓存未命中，服务层会查询存储层获取关系数据，然后进行关系图遍历计算，应用授权规则，最后更新缓存并返回结果。

**完整检查示例**：参考 [FastAPI 集成](../integrates/03.fastapi-integration/) 了解如何在应用中集成权限检查

## 4.4 API 服务层

OpenFGA 提供了两种 API 接口：HTTP RESTful API 和 gRPC API。两种 API 提供相同的功能，但各有特点。

### HTTP RESTful API

HTTP RESTful API 是 OpenFGA 的主要接口，基于标准的 HTTP 协议，易于集成和使用。

**特点**：

标准协议基于 HTTP/HTTPS，易于理解和调试。跨语言支持让任何支持 HTTP 的语言都可以调用。易于测试可以使用 curl、Postman 等工具测试。人类可读的 URL 和 JSON 格式易于阅读和理解。

**API 端点分类**：

Store 管理 API 提供创建、查询、删除 Store 的功能。授权模型 API 提供创建、查询、列举授权模型的功能。关系元组 API 提供 Check、Write、Read、ListObjects、ListUsers、Expand 等功能。

### gRPC API

gRPC 是一个高性能、开源的 RPC 框架，使用 Protocol Buffers 作为序列化协议。

**特点**：

高性能使用 HTTP/2 和二进制协议，性能优于 REST。类型安全强类型的接口定义，编译时类型检查。流式处理支持流式请求和响应。代码生成自动生成客户端和服务器代码。

### API 选择策略

选择 HTTP RESTful API 还是 gRPC API，需要根据具体场景决定。

**选择 RESTful API 的场景**：
- Web 应用集成，前端 JavaScript 应用
- 快速原型开发，使用 curl 快速测试
- 跨语言集成，不支持 gRPC 的环境
- 防火墙友好，HTTP/HTTPS 更容易通过防火墙

**选择 gRPC API 的场景**：
- 高性能要求，微服务间通信
- 类型安全，强类型语言
- 流式处理，批量数据处理
- 内部服务，Kubernetes 集群内通信

**混合使用策略**：

在实际应用中，可以同时使用两种 API。Web 前端使用 RESTful API，后端微服务使用 gRPC API。这种混合策略能够兼顾易用性和性能。

**完整 API 使用示例**：参考 [Node.js SDK 集成](../integrates/02.nodejs-sdk-basic/) 了解 SDK 的使用方法

## 4.5 存储后端选择

OpenFGA 支持多种存储后端，包括 PostgreSQL、MySQL、SQLite 和内存存储。选择合适的存储后端对于系统的性能、可靠性和可维护性至关重要。

### PostgreSQL：生产环境首选

PostgreSQL 是生产环境的首选存储后端，提供高性能、高可用性和强大的功能支持。

**特点**：

高性能支持高并发读写。事务支持 ACID 事务保证数据一致性。扩展性支持大规模数据和水平扩展。可靠性成熟的备份和恢复机制。功能丰富支持复杂查询和索引优化。

**性能优化**：

索引优化 PostgreSQL 会自动创建必要的索引，但可以根据查询模式进一步优化。连接池配置使用 PgBouncer 或内置连接池，提升连接利用率。

**高可用性配置**：

主从复制通过主从复制实现高可用性。主库处理写操作，从库处理读操作。这种配置能够提升系统的可用性和性能。

> **我的建议**：如果你的项目要上生产环境，PostgreSQL 是首选。它稳定、性能好、功能强大。我在多个生产项目中都用的 PostgreSQL，从来没让我失望过。

### MySQL：广泛使用的选择

MySQL 适合已经使用 MySQL 基础设施的环境。

**特点**：

广泛使用大多数环境都有 MySQL。性能良好适合高并发读操作。易于管理丰富的管理工具。社区支持活跃的社区和丰富的资源。

### SQLite：开发测试专用

SQLite 适合开发和测试环境。

**特点**：

轻量级无需独立的数据库服务器。零配置开箱即用。文件存储数据存储在单个文件中。适合开发快速启动和测试。

**SQLite 的限制**：

并发性能不适合高并发场景。文件锁定写入时会锁定整个数据库文件。扩展性不适合大规模数据。

⚠️ **重要提醒：绝对不要在生产环境使用 SQLite！** 我见过有人在生产环境用 SQLite，结果在高并发下数据库锁死，整个系统瘫痪。SQLite 只适合开发和测试。

### 存储后端对比

| 特性 | PostgreSQL | MySQL | SQLite | Memory |
|------|-----------|-------|--------|--------|
| 生产环境 | ✅ 推荐 | ✅ 可用 | ❌ 不推荐 | ❌ 仅测试 |
| 并发性能 | 优秀 | 良好 | 较差 | 优秀 |
| 事务支持 | ✅ | ✅ | ✅ | ❌ |
| 数据持久化 | ✅ | ✅ | ✅ | ❌ |
| 扩展性 | 优秀 | 良好 | 有限 | 有限 |
| 高可用性 | ✅ | ✅ | ❌ | ❌ |

## 4.6 性能与可扩展性

OpenFGA 的设计目标是在毫秒级别内完成授权检查，能够支持任何规模的项目。

### 性能优化机制

**多层缓存机制**：

OpenFGA 采用多层缓存机制，减少数据库查询。内存缓存（CCache）是最快的缓存方式，Redis 分布式缓存提供跨实例共享。

缓存策略包括授权决策缓存、关系元组缓存和模型缓存。授权决策缓存缓存 Check API 的结果，TTL 通常为 5 分钟。

**批量操作优化**：

OpenFGA 支持批量操作，减少网络往返。批量 Check 支持一次检查多个权限，批量 Write 支持一次写入多个元组。

**查询优化**：

索引优化对关系元组建立合适的索引，提升查询速度。查询计划优化选择最优的查询路径，减少查询时间。

**并发处理**：

并发 Check 对于 `or` 关系，多个子问题并发处理。并发查询多个数据库查询并发执行。连接池管理合理配置数据库连接池，提升资源利用率。

### 水平扩展方案

OpenFGA 支持水平扩展，通过多实例部署提高吞吐量。

负载均衡器将请求分发到多个 OpenFGA 实例。每个实例都是无状态的，可以独立处理请求。共享存储确保所有实例访问相同的数据。

**存储扩展**：

读写分离主库处理写操作，从库处理读操作。这种配置能够提升系统的可用性和性能。

分片策略按 Store ID 或对象类型分片。这种策略能够将数据分散到多个数据库，提升系统的扩展性。

缓存扩展使用 Redis 集群实现分布式缓存。多个 OpenFGA 实例共享缓存，提高缓存命中率。

**完整部署示例**：参考 [Go 微服务集成](../integrates/08.go-microservice/) 了解生产环境的部署配置

## 本章小结

本章深入探讨了 OpenFGA 的架构设计和核心组件——这些知识为你全面理解 OpenFGA 的系统设计提供了坚实的基础。

**核心要点**：

1. OpenFGA 采用五层架构，每层职责明确，便于维护和扩展
2. Store、Authorization Model 和 Relationship Tuple 是核心概念，理解它们的关系是使用 OpenFGA 的基础
3. 授权模型引擎采用分层架构，通过多种优化策略实现高性能
4. HTTP RESTful API 和 gRPC API 各有适用场景，可以根据具体需求选择或混合使用
5. PostgreSQL 是生产环境的首选存储后端，但 MySQL 和 SQLite 也有各自的适用场景
6. 多层缓存、批量操作、查询优化和并发处理等策略，使得 OpenFGA 能够在毫秒级完成授权检查

**关键收获**：

OpenFGA 的架构设计遵循云原生最佳实践，通过分层设计、多层缓存、水平扩展等机制，实现了高性能、高可用、可扩展的授权系统。理解这些设计原则和实现细节，有助于我们更好地使用 OpenFGA，优化系统性能，排查问题。

**下一步**：

在下一章中，我们将深入学习授权模型的设计方法——这是 OpenFGA 的核心内容。你将学会如何根据业务需求设计合适的授权模型，如何利用关系定义来表达复杂的权限逻辑。

准备好了吗？让我们继续！
