# 第 16 章：AI 应用实践案例与最佳实践

通过真实案例掌握 AI 场景下的权限管理

---

理论和实践之间总有差距。这一章我会分享四个真实的 AI 应用案例——有些成功了，有些踩了坑，但都给了我宝贵的经验。

你将看到：如何为 AI 应用设计权限模型、如何处理多 Agent 协作、如何控制工具访问、如何管理数据权限。这些都是我在实际项目中遇到的问题和解决方案。

> **完整代码**：本章案例的完整实现见 [../integrates/09.agentscope-mcp-integration/](../integrates/09.agentscope-mcp-integration/)

## 16.1 设计原则

在设计 AI 应用的权限模型之前，先理解几个核心原则。

### 最小权限原则

Agent 只应该拥有完成任务所需的最小权限。

我见过一个项目，给所有 Agent 都授予了 `admin` 权限，理由是"方便开发"。结果一个 Bug 导致 Agent 删除了生产数据库的表。

正确做法：

```openfga
type agent
  relations
    define owner: [user]
    define can_read: owner
    define can_write: owner
    # 不要给 can_delete 权限，除非明确需要
```

### 职责分离原则

敏感操作应该由多个 Agent 协作完成，而不是单个 Agent。

示例：财务审批流程

```openfga
type payment
  relations
    define initiator: [agent]
    define approver: [agent]
    define can_initiate: initiator
    define can_approve: approver but not initiator
    define can_execute: can_approve
```

这个模型确保：发起支付的 Agent 不能自己审批。

### 动态权限原则

权限应该根据上下文动态授予和撤销。

```python
# 授予临时权限
await grant_temporary_permission(
    agent_id="assistant",
    resource_id="document:sensitive",
    duration_minutes=30
)
# 30分钟后自动撤销
```

### 审计优先原则

所有 Agent 操作都应该被记录和审计。

```python
async def agent_action_with_audit(agent_id, action, resource_id):
    # 检查权限
    allowed = await check_permission(agent_id, action, resource_id)

    # 记录审计日志（无论成功还是失败）
    await log_audit({
        "agent_id": agent_id,
        "action": action,
        "allowed": allowed,
        "timestamp": datetime.now()
    })

    if allowed:
        return await execute_action(action, resource_id)
    raise PermissionDeniedError()
```

### 默认拒绝原则

如果没有明确授权，默认拒绝访问。OpenFGA 天然支持这个原则——如果没有关系元组，Check API 会返回 `false`。

## 16.2 案例一：智能客服系统

这是我实际参与的一个项目。我们为一家电商公司开发了智能客服系统，使用 LangChain 构建。

### 业务场景

**系统功能**：
- 回答用户问题
- 查询订单信息
- 处理退款请求
- 修改订单地址

**权限需求**：
- 客服 Agent 只能查询用户自己的订单
- 退款需要主管 Agent 审批
- 修改订单地址需要用户确认
- 敏感信息（如支付密码）不能被 Agent 访问

### 权限模型设计

```openfga
model
  schema 1.1

type user

type agent
  relations
    define owner: [user]
    define supervisor: [agent]
    define can_act_as: owner
    define can_approve: supervisor

type order
  relations
    define customer: [user]
    define viewer: [agent]
    define can_query: viewer and customer
    define can_refund: can_approve from viewer

type sensitive_info
  relations
    define owner: [user]
    define can_access: owner  # Agent 不能访问
```

**设计要点**：
1. Agent 通过 `owner` 关系关联到用户
2. 通过 `supervisor` 关系实现主管审批
3. Agent 只能查询所属用户的订单
4. 敏感信息只有用户本人可以访问

### 核心实现

**权限检查工具**：

```python
from langchain.tools import BaseTool

class OrderQueryTool(BaseTool):
    name = "query_order"
    description = "查询订单信息"

    async def _arun(self, agent_id: str, order_id: str) -> str:
        # 权限检查
        allowed = await self.permission_checker.check_permission(
            user=f"agent:{agent_id}",
            relation="can_query",
            object=f"order:{order_id}"
        )

        if not allowed:
            return f"权限被拒绝：无法查询订单 {order_id}"

        # 查询订单并脱敏
        order = await self.order_service.get_order(order_id)
        return self.mask_sensitive_info(order)
```

**退款审批流程**：

```python
class RefundTool(BaseTool):
    async def _arun(self, agent_id: str, order_id: str, amount: float):
        # 大额退款需要主管审批
        if amount > 1000:
            supervisor_approved = await self.check_supervisor_approval(
                agent_id, order_id
            )
            if not supervisor_approved:
                return "大额退款需要主管审批"

        # 权限检查
        allowed = await self.permission_checker.check_permission(
            user=f"agent:{agent_id}",
            relation="can_refund",
            object=f"order:{order_id}"
        )

        if not allowed:
            return "权限被拒绝：无法处理退款"

        # 执行退款并记录审计日志
        result = await self.order_service.process_refund(order_id, amount)
        await self.audit_log(agent_id, "refund", order_id, amount)

        return f"退款成功：{amount} 元"
```

> **完整代码**：见 [examples/01_document_permissions.py](../integrates/09.agentscope-mcp-integration/examples/01_document_permissions.py)

### 最佳实践

**1. 用户隔离** - 每个客服 Agent 只能访问所服务用户的数据，通过 `customer` 关系实现订单隔离。

**2. 敏感信息保护** - 自动脱敏敏感字段，Agent 无法访问支付密码等敏感信息。

**3. 审批流程** - 大额退款需要主管审批，通过 `supervisor` 关系实现层级管理。

**4. 审计追溯** - 记录所有操作日志，便于问题排查和合规审计。

## 16.3 案例二：数据分析 Agent

这个案例来自一个数据分析平台项目。我们需要让 AI Agent 帮助用户分析数据，但要确保数据安全。

### 业务场景

**系统功能**：
- 查询数据库
- 生成数据报表
- 执行数据分析
- 导出数据

**权限需求**：
- Agent 只能访问用户授权的数据表
- 敏感字段需要脱敏
- 不能执行 DELETE、UPDATE 等危险操作
- 导出数据需要审批

### 权限模型设计

```openfga
model
  schema 1.1

type user

type agent
  relations
    define owner: [user]

type database
  relations
    define owner: [user]
    define viewer: [user, agent]
    define can_access: viewer or owner

type table
  relations
    define parent: [database]
    define owner: [user]
    define viewer: [user, agent]
    define can_query: viewer or viewer from parent
    define can_export: owner  # 只有 owner 可以导出

type column
  relations
    define parent: [table]
    define sensitive: [user]  # 标记为敏感字段
    define can_view: can_query from parent but not sensitive
```

**设计要点**：
1. 数据库 → 表 → 字段的层级结构
2. Agent 只能查询，不能修改
3. 敏感字段需要特殊标记
4. 只有数据所有者可以导出

### 核心实现

**安全的 SQL 执行器**：

```python
class SecureSQLExecutor:
    async def execute_query(self, agent_id: str, table_name: str, query: str):
        # 检查是否为只读查询
        if not self.is_read_only(query):
            raise SecurityError("只允许 SELECT 查询")

        # 检查表权限
        allowed = await self.permission_checker.check_permission(
            user=f"agent:{agent_id}",
            relation="can_query",
            object=f"table:{table_name}"
        )

        if not allowed:
            raise PermissionDeniedError(f"无权访问表 {table_name}")

        # 执行查询并脱敏
        result = await self.db.execute(query)
        sensitive_columns = await self.get_sensitive_columns(table_name)
        return self.mask_sensitive_columns(result, sensitive_columns)

    def is_read_only(self, query):
        dangerous = ["DELETE", "UPDATE", "INSERT", "DROP", "ALTER", "CREATE"]
        return not any(kw in query.upper() for kw in dangerous)
```

**数据导出工具**：

```python
class DataExportTool(BaseTool):
    async def _arun(self, agent_id: str, table_name: str, format: str = "csv"):
        # 检查导出权限（只有 owner 可以导出）
        allowed = await self.permission_checker.check_permission(
            user=f"agent:{agent_id}",
            relation="can_export",
            object=f"table:{table_name}"
        )

        if not allowed:
            return "数据导出需要所有者授权"

        # 执行导出并记录审计日志
        data = await self.sql_executor.execute_query(
            agent_id, table_name, f"SELECT * FROM {table_name}"
        )
        file_path = await self.export_to_file(data, format)
        await self.audit_log(agent_id, "export", table_name, file_path)

        return f"导出成功：{file_path}"
```

### 最佳实践

**1. SQL 注入防护** - 解析 SQL 查询，只允许 SELECT，使用参数化查询。

**2. 字段级权限** - 敏感字段自动脱敏，通过 `sensitive` 关系标记敏感字段。

**3. 导出限制** - 只有数据所有者可以导出，所有导出操作都记录审计日志。

**4. 性能优化** - 缓存权限检查结果，批量检查字段权限。

## 16.4 案例三：自动化工作流

这个案例来自一个企业自动化平台。我们使用 LangGraph 构建了一个自动化工作流系统。

### 业务场景

**系统功能**：
- 自动处理审批流程
- 自动生成报告
- 自动发送通知
- 自动同步数据

**权限需求**：
- 不同的工作流有不同的权限要求
- 某些步骤需要人工审批
- 敏感操作需要多重验证
- 工作流执行需要审计

### 权限模型设计

```openfga
model
  schema 1.1

type user

type agent
  relations
    define owner: [user]

type workflow
  relations
    define creator: [user]
    define executor: [agent]
    define approver: [user]
    define can_execute: executor and (creator or approver)

type workflow_step
  relations
    define parent: [workflow]
    define executor: [agent]
    define requires_approval: [user]
    define can_execute: executor and can_execute from parent
    define can_approve: requires_approval
```

**设计要点**：
1. 工作流级权限：整个工作流需要授权
2. 步骤级权限：每个步骤可以有独立的权限要求
3. 审批机制：敏感步骤需要人工审批
4. 权限继承：步骤继承工作流的权限

### 核心实现

**权限检查节点**：

```python
from langgraph.graph import StateGraph

async def permission_check_node(state, permission_checker, step_name):
    agent_id = state["agent_id"]
    workflow_id = state["workflow_id"]

    # 检查工作流权限
    workflow_allowed = await permission_checker.check_permission(
        user=f"agent:{agent_id}",
        relation="can_execute",
        object=f"workflow:{workflow_id}"
    )

    if not workflow_allowed:
        state["permission_granted"] = False
        return state

    # 检查步骤权限
    step_allowed = await permission_checker.check_permission(
        user=f"agent:{agent_id}",
        relation="can_execute",
        object=f"workflow_step:{step_name}"
    )

    if not step_allowed:
        state["permission_granted"] = False
        return state

    # 检查是否需要审批
    needs_approval = await permission_checker.check_permission(
        user=f"workflow_step:{step_name}",
        relation="requires_approval",
        object=f"workflow:{workflow_id}"
    )

    if needs_approval and step_name not in state["approval_status"]:
        state["permission_granted"] = False
        state["messages"].append("步骤需要审批")
        return state

    state["permission_granted"] = True
    return state
```

**构建工作流图**：

```python
async def create_approval_workflow(permission_checker):
    workflow = StateGraph(WorkflowState)

    # 添加权限检查节点
    workflow.add_node("check_permission",
        partial(permission_check_node,
                permission_checker=permission_checker,
                step_name="data_collection"))
    workflow.add_node("collect_data", data_collection_step)

    # 添加边
    workflow.set_entry_point("check_permission")
    workflow.add_edge("check_permission", "collect_data")

    return workflow.compile()
```

> **完整代码**：见 [examples/02_multi_agent_collaboration.py](../integrates/09.agentscope-mcp-integration/examples/02_multi_agent_collaboration.py)

### 最佳实践

**1. 分层权限检查** - 工作流级权限、步骤级权限、操作级权限。

**2. 审批机制** - 敏感步骤需要人工审批，审批状态持久化，审批超时处理。

**3. 工作流暂停和恢复** - 等待审批时暂停工作流，审批通过后自动恢复。

**4. 审计追溯** - 记录每个步骤的执行情况和审批决策。

## 16.5 案例四：多 Agent 协作系统

这是最复杂的案例，来自一个企业知识管理系统。多个 Agent 需要协作完成任务。

### 业务场景

**系统功能**：
- 文档 Agent：管理文档
- 搜索 Agent：搜索信息
- 总结 Agent：生成摘要
- 审核 Agent：审核内容

**权限需求**：
- Agent 之间需要协作
- 每个 Agent 有不同的权限
- Agent 之间的通信需要授权
- 数据在 Agent 间传递需要权限检查

### 权限模型设计

```openfga
model
  schema 1.1

type user

type agent
  relations
    define owner: [user]
    define can_communicate_with: [agent]
    define can_delegate_to: [agent]

type document
  relations
    define owner: [user]
    define manager: [agent]
    define searcher: [agent]
    define summarizer: [agent]
    define reviewer: [agent]
    define can_manage: manager
    define can_search: searcher or manager
    define can_summarize: summarizer or manager
    define can_review: reviewer

type task
  relations
    define creator: [agent]
    define executor: [agent]
    define can_create: creator
    define can_execute: executor
    define can_delegate: creator and can_communicate_with from creator
```

**设计要点**：
1. Agent 通信权限：Agent 之间需要授权才能通信
2. 任务委托：Agent 可以将任务委托给其他 Agent
3. 角色分离：不同 Agent 有不同的职责
4. 数据传递：数据在 Agent 间传递需要权限检查

### 核心实现

**Agent 通信机制**：

```python
class AgentCommunicator:
    async def send_message(self, from_agent: str, to_agent: str, message: dict):
        # 检查通信权限
        allowed = await self.permission_checker.check_permission(
            user=f"agent:{from_agent}",
            relation="can_communicate_with",
            object=f"agent:{to_agent}"
        )

        if not allowed:
            raise PermissionDeniedError(
                f"Agent {from_agent} 无权与 Agent {to_agent} 通信"
            )

        # 发送消息并记录审计日志
        await self.deliver_message(to_agent, message)
        await self.audit_log(from_agent, to_agent, message)

    async def delegate_task(self, from_agent: str, to_agent: str, task: dict):
        # 检查委托权限
        allowed = await self.permission_checker.check_permission(
            user=f"agent:{from_agent}",
            relation="can_delegate_to",
            object=f"agent:{to_agent}"
        )

        if not allowed:
            raise PermissionDeniedError(
                f"Agent {from_agent} 无权委托任务给 Agent {to_agent}"
            )

        await self.create_task(to_agent, task)
```

**协作 Agent**：

```python
class DocumentManagerAgent:
    async def process_document(self, document_id: str):
        # 检查管理权限
        allowed = await self.permission_checker.check_permission(
            user=f"agent:{self.agent_id}",
            relation="can_manage",
            object=f"document:{document_id}"
        )

        if not allowed:
            return "无权管理文档"

        # 委托搜索任务给搜索 Agent
        await self.communicator.delegate_task(
            from_agent=self.agent_id,
            to_agent="search_agent",
            task={"type": "search", "document_id": document_id}
        )

        # 委托总结任务给总结 Agent
        await self.communicator.delegate_task(
            from_agent=self.agent_id,
            to_agent="summary_agent",
            task={"type": "summarize", "document_id": document_id}
        )

        return "任务已委托"
```

### 最佳实践

**1. Agent 通信授权** - Agent 之间的通信需要明确授权，防止未授权的 Agent 窃取信息。

**2. 任务委托控制** - 只有授权的 Agent 可以委托任务，委托关系需要明确定义。

**3. 角色分离** - 每个 Agent 只负责特定的任务，避免权限过大。

**4. 数据传递安全** - 数据在 Agent 间传递时需要权限检查，敏感数据需要加密传输。

## 16.6 常见陷阱和解决方案

### 陷阱1：权限过大

❌ **错误做法**：
```python
# 给所有 Agent 授予 admin 权限
await grant_permission("agent:*", "admin", "resource:*")
```

✅ **正确做法**：
```python
# 为每个 Agent 单独授予必需的权限
await grant_permission("agent:assistant", "viewer", "document:doc1")
```

### 陷阱2：忘记权限检查

❌ **错误做法**：
```python
async def execute_tool(tool_name, params):
    # 直接执行，没有权限检查
    return await tool.execute(params)
```

✅ **正确做法**：
```python
async def execute_tool(agent_id, tool_name, params):
    # 先检查权限
    if not await check_permission(agent_id, "can_execute", f"tool:{tool_name}"):
        raise PermissionDeniedError()
    return await tool.execute(params)
```

### 陷阱3：权限检查性能问题

❌ **错误做法**：
```python
# 每次都查询数据库
for item in items:
    if await check_permission(agent_id, "can_view", item.id):
        results.append(item)
```

✅ **正确做法**：
```python
# 使用批量检查或缓存
allowed_items = await batch_check_permissions(agent_id, "can_view", item_ids)
results = [item for item in items if item.id in allowed_items]
```

### 陷阱4：敏感信息泄露

❌ **错误做法**：
```python
# 直接返回所有数据
return await fetch_user_data(user_id)
```

✅ **正确做法**：
```python
# 脱敏处理
data = await fetch_user_data(user_id)
return mask_sensitive_fields(data, agent_sensitivity_level)
```

### 陷阱5：缺少审计日志

❌ **错误做法**：
```python
# 只记录成功的操作
if allowed:
    await log_action(agent_id, action, resource_id)
```

✅ **正确做法**：
```python
# 记录所有操作（成功和失败）
await log_action(agent_id, action, resource_id, allowed)
```

## 16.7 性能优化建议

### 启用缓存

```python
# OpenFGA 配置
config = ClientConfiguration(
    api_url="http://localhost:8080",
    store_id=store_id,
    cache_ttl=300  # 5分钟
)
```

### 批量权限检查

```python
# 批量检查多个资源的权限
async def batch_check(agent_id, relation, resource_ids):
    tasks = [
        check_permission(agent_id, relation, rid)
        for rid in resource_ids
    ]
    results = await asyncio.gather(*tasks)
    return [rid for rid, allowed in zip(resource_ids, results) if allowed]
```

### 权限预加载

```python
# 在 Agent 启动时预加载权限
async def preload_permissions(agent_id):
    permissions = await list_agent_permissions(agent_id)
    cache.set(f"permissions:{agent_id}", permissions, ttl=300)
```

## 16.8 安全建议

### 定期审计

```python
async def audit_permissions():
    # 查找权限过大的 Agent
    over_privileged = await find_over_privileged_agents()

    # 查找长期未使用的权限
    unused = await find_unused_permissions(days=90)

    # 生成审计报告
    return generate_audit_report(over_privileged, unused)
```

### 权限过期

```python
async def grant_temporary_permission(
    agent_id, relation, resource_id, duration_minutes
):
    # 授予权限
    await grant_permission(agent_id, relation, resource_id)

    # 设置过期时间
    expire_at = datetime.now() + timedelta(minutes=duration_minutes)

    # 调度撤销任务
    schedule_revoke(agent_id, relation, resource_id, expire_at)
```

### 异常检测

```python
async def detect_anomalies(agent_id):
    history = await get_agent_history(agent_id, days=30)
    anomalies = []

    # 访问频率异常
    if history.access_count > history.avg_access_count * 3:
        anomalies.append("访问频率异常")

    # 访问时间异常
    if is_unusual_time(history.access_times):
        anomalies.append("访问时间异常")

    return anomalies
```

## 16.9 本章小结

本章通过四个真实的 AI 应用案例，深入学习了 AI 场景下的权限管理最佳实践。

**核心要点**：

1. **设计原则** - 最小权限、职责分离、动态权限、审计优先、默认拒绝
2. **智能客服** - 用户隔离、敏感信息保护、审批流程、审计追溯
3. **数据分析** - SQL 注入防护、字段级权限、导出限制、性能优化
4. **自动化工作流** - 分层权限检查、审批机制、工作流暂停和恢复
5. **多 Agent 协作** - Agent 通信授权、任务委托控制、角色分离

**实践建议**：

1. **从简单开始** - 先实现基本的权限检查，再逐步完善
2. **参考案例** - 本章的四个案例可以作为你项目的参考
3. **持续优化** - 根据实际使用情况不断优化权限模型
4. **定期审计** - 定期检查权限配置，清理不必要的权限
5. **记录文档** - 详细记录权限模型的设计决策和使用方法

**下一步**：

恭喜你完成了本书的核心内容！在第 17 章中，我们将回顾全书的核心知识点，展望 AI 时代权限管理的发展趋势，并为你提供学习路径建议。

> **完整代码**：本章所有案例的完整实现见 [../integrates/09.agentscope-mcp-integration/](../integrates/09.agentscope-mcp-integration/)
