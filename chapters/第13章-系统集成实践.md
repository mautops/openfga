# 第 13 章：系统集成实践

将 OpenFGA 集成到现有系统中，实现统一的授权管理

---

OpenFGA 很少单独使用。在实际项目中，它需要与认证系统、API 网关、应用框架等其他系统集成。这一章，我会分享如何将 OpenFGA 集成到现有系统中——这些都是我在实际项目中踩过坑、总结出来的经验。

## 13.1 与认证系统集成

OpenFGA 负责授权（Authorization），但不负责认证（Authentication）。理解这两者的区别很重要：

**认证（Authentication）**：回答"你是谁"的问题
- 验证用户身份
- 常见方式：用户名密码、OAuth、OIDC、SAML

**授权（Authorization）**：回答"你能做什么"的问题
- 确定访问权限
- OpenFGA 的职责

**典型流程**：

```
1. 用户登录 → 认证系统验证身份 → 返回 Token
2. 用户访问资源 → 应用从 Token 中提取用户 ID
3. 应用调用 OpenFGA → 检查用户是否有权限
4. 根据权限结果 → 允许或拒绝访问
```

### OAuth 2.0 集成

OAuth 2.0 是最常用的认证协议。集成的关键是从 Token 中提取用户 ID，然后传递给 OpenFGA。

**核心代码**：

```python
from flask import request, jsonify
import jwt

def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        try:
            payload = jwt.decode(token, PUBLIC_KEY, algorithms=['RS256'])
            request.user_id = payload['sub']  # 提取用户 ID
        except jwt.InvalidTokenError:
            return jsonify({'error': '无效的 Token'}), 401
        return f(*args, **kwargs)
    return decorated

@app.route('/api/documents/<doc_id>')
@require_auth
async def get_document(doc_id):
    # 检查权限
    allowed = await fga_client.check({
        'user': f'user:{request.user_id}',
        'relation': 'can_view',
        'object': f'document:{doc_id}'
    })

    if not allowed['allowed']:
        return jsonify({'error': '无权访问'}), 403

    return jsonify(get_document_data(doc_id))
```

关键点：
- 从 Token 中提取用户 ID（通常是 `sub` 字段）
- 将用户 ID 传递给 OpenFGA
- 根据权限检查结果决定是否允许访问

> **实践经验**：我最初忘记验证 Token 的签名，直接信任了 Token 中的用户 ID。结果被安全团队发现，任何人都可以伪造 Token 访问资源。所以，一定要验证 Token 的签名！

**完整集成示例**：参考 [FastAPI 集成](../integrates/03.fastapi-integration/)

### OIDC 集成

OIDC（OpenID Connect）是基于 OAuth 2.0 的身份层。它提供了标准化的用户信息端点。

**核心思路**：

```python
# 从 OIDC 获取用户信息
async def get_user_info(access_token):
    response = await httpx.get(
        f'{OIDC_ISSUER}/userinfo',
        headers={'Authorization': f'Bearer {access_token}'}
    )
    return response.json()

# 同步用户信息到 OpenFGA
async def sync_user_to_fga(user_info):
    # 如果用户有特定角色，在 OpenFGA 中建立关系
    if 'admin' in user_info.get('roles', []):
        await fga_client.write({
            'writes': [{
                'user': f'user:{user_info["sub"]}',
                'relation': 'member',
                'object': 'role:admin'
            }]
        })
```

关键点：
- OIDC 提供了标准化的用户信息
- 可以从用户信息中提取角色、组织等信息
- 将这些信息同步到 OpenFGA 中

### SAML 集成

SAML 常用于企业环境。集成思路类似，从 SAML 断言中提取用户信息。

**核心代码**：

```python
from onelogin.saml2.auth import OneLogin_Saml2_Auth

def saml_callback():
    auth = OneLogin_Saml2_Auth(request_data, saml_settings)
    auth.process_response()

    if auth.is_authenticated():
        user_id = auth.get_nameid()  # 提取用户 ID
        attributes = auth.get_attributes()  # 提取用户属性

        # 同步到 OpenFGA
        sync_user_attributes_to_fga(user_id, attributes)

        return redirect('/dashboard')
    else:
        return 'Authentication failed', 401
```

> **踩坑经验**：SAML 的用户 ID 格式可能很奇怪（比如 `user@domain.com` 或 `CN=User,OU=Org`）。我们最初直接用这个 ID 作为 OpenFGA 的用户 ID，结果发现有些特殊字符导致查询失败。后来我们对用户 ID 做了标准化处理（转换为小写、移除特殊字符），问题才解决。

## 13.2 与 API 网关集成

API 网关是微服务架构的入口。在网关层进行权限检查，可以统一管理授权逻辑。

### Kong 集成

Kong 是流行的 API 网关。我们可以编写 Kong 插件来集成 OpenFGA。

**核心思路**：

```lua
-- Kong 插件
function plugin:access(conf)
    -- 从请求中提取用户 ID
    local user_id = kong.request.get_header("X-User-ID")

    -- 从路由中提取资源信息
    local resource_type = kong.router.get_route().name
    local resource_id = kong.request.get_path_with_query():match("/(%w+)$")

    -- 调用 OpenFGA
    local res = http.post(conf.fga_url .. "/check", {
        body = json.encode({
            user = "user:" .. user_id,
            relation = "can_view",
            object = resource_type .. ":" .. resource_id
        })
    })

    if not res.body.allowed then
        return kong.response.exit(403, {message = "无权访问"})
    end
end
```

关键点：
- 在网关层统一进行权限检查
- 从请求头或 Token 中提取用户 ID
- 从路由信息中提取资源类型和 ID
- 调用 OpenFGA 检查权限

**完整插件代码**：参考 [Kong 插件集成](../integrates/06.kong-plugin/)

### Traefik 集成

Traefik 支持中间件机制。我们可以编写中间件来集成 OpenFGA。

**核心代码**：

```go
// Traefik 中间件
func (a *AuthMiddleware) ServeHTTP(rw http.ResponseWriter, req *http.Request, next http.HandlerFunc) {
    // 提取用户 ID
    userID := req.Header.Get("X-User-ID")

    // 提取资源信息
    resourceType, resourceID := extractResource(req.URL.Path)

    // 检查权限
    allowed, err := a.fgaClient.Check(context.Background(), &ClientCheckRequest{
        User:     fmt.Sprintf("user:%s", userID),
        Relation: "can_view",
        Object:   fmt.Sprintf("%s:%s", resourceType, resourceID),
    })

    if err != nil || !allowed.Allowed {
        http.Error(rw, "无权访问", http.StatusForbidden)
        return
    }

    next(rw, req)
}
```

> **实践经验**：在网关层进行权限检查有个好处——所有服务都不需要关心授权逻辑。但也有个问题：网关层只能做粗粒度的权限检查（比如"能否访问这个资源"），无法做细粒度的检查（比如"能否修改这个字段"）。所以，我们通常在网关层做基础权限检查，在服务层做细粒度检查。

## 13.3 与应用框架集成

不同的应用框架有不同的集成方式。核心思路都是：在请求处理前进行权限检查。

### Spring Boot 集成

Spring Boot 可以使用拦截器或 AOP 来集成 OpenFGA。

**使用拦截器**：

```java
@Component
public class AuthorizationInterceptor implements HandlerInterceptor {
    @Autowired
    private OpenFgaClient fgaClient;

    @Override
    public boolean preHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler) throws Exception {
        // 提取用户 ID
        String userId = request.getHeader("X-User-ID");

        // 提取资源信息
        String resourceType = extractResourceType(request);
        String resourceId = extractResourceId(request);

        // 检查权限
        CheckResponse checkResponse = fgaClient.check(
            new CheckRequest()
                .user("user:" + userId)
                .relation("can_view")
                ._object(resourceType + ":" + resourceId)
        ).get();

        if (!checkResponse.getAllowed()) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            return false;
        }

        return true;
    }
}
```

**使用注解**：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String relation();
    String resourceType();
}

@RestController
public class DocumentController {
    @GetMapping("/documents/{id}")
    @RequirePermission(relation = "can_view", resourceType = "document")
    public Document getDocument(@PathVariable String id) {
        return documentService.getDocument(id);
    }
}
```

关键点：
- 使用拦截器在请求处理前检查权限
- 使用注解声明权限要求
- 使用 AOP 实现权限检查逻辑

**完整集成示例**：参考 [Spring Boot 集成](../integrates/04.spring-boot-integration/)

### Django 集成

Django 可以使用装饰器或中间件来集成 OpenFGA。

**使用装饰器**：

```python
from functools import wraps
from django.http import JsonResponse

def require_permission(relation, resource_type):
    def decorator(view_func):
        @wraps(view_func)
        async def wrapped_view(request, *args, **kwargs):
            user_id = request.user.id
            resource_id = kwargs.get('pk') or kwargs.get('id')

            allowed = await fga_client.check({
                'user': f'user:{user_id}',
                'relation': relation,
                'object': f'{resource_type}:{resource_id}'
            })

            if not allowed['allowed']:
                return JsonResponse({'error': '无权访问'}, status=403)

            return await view_func(request, *args, **kwargs)
        return wrapped_view
    return decorator

@require_permission('can_view', 'document')
async def get_document(request, pk):
    document = await Document.objects.aget(pk=pk)
    return JsonResponse({'id': document.id, 'title': document.title})
```

**使用中间件**：

```python
class OpenFGAMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    async def __call__(self, request):
        # 对需要权限检查的路径进行检查
        if request.path.startswith('/api/'):
            if not await self.check_permission(request):
                return JsonResponse({'error': '无权访问'}, status=403)

        response = await self.get_response(request)
        return response

    async def check_permission(self, request):
        # 提取用户和资源信息
        user_id = request.user.id
        resource_type, resource_id = extract_resource(request.path)

        # 检查权限
        allowed = await fga_client.check({
            'user': f'user:{user_id}',
            'relation': 'can_view',
            'object': f'{resource_type}:{resource_id}'
        })

        return allowed['allowed']
```

### Express.js 集成

Express.js 使用中间件机制，集成很简单。

**权限检查中间件**：

```javascript
const checkPermission = (relation, resourceType) => {
    return async (req, res, next) => {
        const userId = req.user.id;
        const resourceId = req.params.id;

        try {
            const { allowed } = await fgaClient.check({
                user: `user:${userId}`,
                relation: relation,
                object: `${resourceType}:${resourceId}`
            });

            if (!allowed) {
                return res.status(403).json({ error: '无权访问' });
            }

            next();
        } catch (error) {
            console.error('权限检查失败:', error);
            return res.status(500).json({ error: '权限检查失败' });
        }
    };
};

// 使用中间件
app.get('/api/documents/:id',
    checkPermission('can_view', 'document'),
    async (req, res) => {
        const document = await getDocument(req.params.id);
        res.json(document);
    }
);
```

**完整集成示例**：参考 [Node.js SDK 集成](../integrates/02.nodejs-sdk-basic/)

> **实践经验**：我们最初在每个路由中手动调用 OpenFGA，代码重复严重。后来改用中间件，代码量减少了 60%，而且更容易维护。所以，一定要利用框架的中间件机制！

## 13.4 与身份提供者集成

身份提供者（IdP）管理用户身份和属性。将 IdP 的用户信息同步到 OpenFGA，可以实现基于用户属性的授权。

### Auth0 集成

Auth0 是流行的身份提供者。集成的关键是同步用户角色和组织信息。

**核心思路**：

```javascript
// Auth0 Hook：用户登录后同步到 OpenFGA
module.exports = async function (user, context, callback) {
    const fgaClient = new OpenFgaClient({
        apiUrl: process.env.FGA_API_URL,
        storeId: process.env.FGA_STORE_ID
    });

    // 同步用户角色
    if (user.app_metadata && user.app_metadata.roles) {
        const writes = user.app_metadata.roles.map(role => ({
            user: `user:${user.user_id}`,
            relation: 'member',
            object: `role:${role}`
        }));

        await fgaClient.write({ writes });
    }

    // 同步组织关系
    if (user.org_id) {
        await fgaClient.write({
            writes: [{
                user: `user:${user.user_id}`,
                relation: 'member',
                object: `organization:${user.org_id}`
            }]
        });
    }

    callback(null, user, context);
};
```

关键点：
- 使用 Auth0 Hook 在用户登录时同步信息
- 从用户元数据中提取角色和组织信息
- 将这些信息写入 OpenFGA

### Okta 集成

Okta 提供了丰富的用户属性和组管理功能。

**核心代码**：

```python
from okta.client import Client as OktaClient

async def sync_okta_user_to_fga(user_id):
    # 从 Okta 获取用户信息
    okta_client = OktaClient({'orgUrl': OKTA_ORG_URL, 'token': OKTA_TOKEN})
    user = await okta_client.get_user(user_id)

    # 获取用户所属的组
    groups = await user.list_groups()

    # 同步到 OpenFGA
    writes = []
    for group in groups:
        writes.append({
            'user': f'user:{user_id}',
            'relation': 'member',
            'object': f'group:{group.id}'
        })

    await fga_client.write({'writes': writes})
```

### Keycloak 集成

Keycloak 是开源的身份提供者。可以使用事件监听器来同步用户信息。

**核心思路**：

```java
public class OpenFGASyncEventListener implements EventListenerProvider {
    @Override
    public void onEvent(Event event) {
        if (event.getType() == EventType.REGISTER ||
            event.getType() == EventType.UPDATE_PROFILE) {

            String userId = event.getUserId();
            UserModel user = session.users().getUserById(realm, userId);

            // 同步用户角色
            Set<RoleModel> roles = user.getRoleMappings();
            for (RoleModel role : roles) {
                syncRoleToOpenFGA(userId, role.getName());
            }

            // 同步用户组
            Set<GroupModel> groups = user.getGroups();
            for (GroupModel group : groups) {
                syncGroupToOpenFGA(userId, group.getName());
            }
        }
    }
}
```

> **踩坑经验**：我们最初只在用户注册时同步信息到 OpenFGA，结果发现用户角色变更后，OpenFGA 中的数据没有更新。后来我们添加了事件监听器，在用户信息变更时自动同步，问题才解决。所以，一定要监听用户信息变更事件！

## 13.5 集成最佳实践

通过多个项目的实践，我总结出以下最佳实践：

### 1. 统一用户 ID 格式

不同系统的用户 ID 格式可能不同：
- OAuth: `sub` 字段（可能是 UUID 或邮箱）
- SAML: `NameID`（可能是 DN 或邮箱）
- 内部系统: 数字 ID

**建议**：
- 定义统一的用户 ID 格式（如 `user:{uuid}`）
- 在集成层进行 ID 转换
- 维护 ID 映射表（如果需要）

```python
def normalize_user_id(user_id, source):
    """统一用户 ID 格式"""
    if source == 'oauth':
        return f'user:{user_id}'
    elif source == 'saml':
        # SAML 的 NameID 可能是邮箱
        return f'user:{hashlib.sha256(user_id.encode()).hexdigest()[:16]}'
    elif source == 'internal':
        return f'user:{user_id}'
    else:
        raise ValueError(f'Unknown source: {source}')
```

### 2. 缓存权限检查结果

权限检查可能成为性能瓶颈。合理的缓存策略很重要。

**建议**：
- 缓存 TTL 设置为 5-10 分钟
- 使用 Redis 或内存缓存
- 权限变更时主动失效缓存

```python
import redis
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

async def check_permission_cached(user_id, relation, object_id):
    cache_key = f'perm:{user_id}:{relation}:{object_id}'

    # 检查缓存
    cached = redis_client.get(cache_key)
    if cached:
        return json.loads(cached)

    # 调用 OpenFGA
    result = await fga_client.check({
        'user': user_id,
        'relation': relation,
        'object': object_id
    })

    # 缓存结果（5 分钟）
    redis_client.setex(cache_key, 300, json.dumps(result))
    return result
```

### 3. 错误处理和降级

OpenFGA 不可用时，需要有降级策略。

**建议**：
- 设置合理的超时时间（如 100ms）
- 实现重试机制（最多 3 次）
- 降级策略：拒绝访问或使用本地权限检查

```python
async def check_permission_with_fallback(user_id, relation, object_id):
    try:
        result = await asyncio.wait_for(
            fga_client.check({
                'user': user_id,
                'relation': relation,
                'object': object_id
            }),
            timeout=0.1  # 100ms 超时
        )
        return result['allowed']
    except asyncio.TimeoutError:
        logger.error('OpenFGA 超时，使用降级策略')
        return check_permission_local(user_id, relation, object_id)
    except Exception as e:
        logger.error(f'OpenFGA 检查失败: {e}')
        return False  # 默认拒绝访问
```

### 4. 监控和日志

完整的监控和日志有助于问题排查。

**建议**：
- 记录所有权限检查请求
- 监控权限检查延迟
- 监控权限检查失败率
- 记录权限拒绝事件（可能是攻击）

```python
import logging
import time

logger = logging.getLogger(__name__)

async def check_permission_with_logging(user_id, relation, object_id):
    start_time = time.time()

    try:
        result = await fga_client.check({
            'user': user_id,
            'relation': relation,
            'object': object_id
        })

        duration = time.time() - start_time

        # 记录日志
        logger.info(f'权限检查: user={user_id}, relation={relation}, '
                   f'object={object_id}, allowed={result["allowed"]}, '
                   f'duration={duration:.3f}s')

        # 记录指标
        metrics.histogram('fga.check.duration', duration)
        metrics.increment('fga.check.total')
        if result['allowed']:
            metrics.increment('fga.check.allowed')
        else:
            metrics.increment('fga.check.denied')

        return result['allowed']
    except Exception as e:
        logger.error(f'权限检查失败: {e}')
        metrics.increment('fga.check.error')
        raise
```

### 5. 测试策略

集成测试很重要，确保权限检查逻辑正确。

**建议**：
- 单元测试：测试权限检查逻辑
- 集成测试：测试与 OpenFGA 的集成
- 端到端测试：测试完整的认证授权流程

```python
import pytest

@pytest.mark.asyncio
async def test_permission_check():
    # 创建测试数据
    await fga_client.write({
        'writes': [{
            'user': 'user:alice',
            'relation': 'owner',
            'object': 'document:doc1'
        }]
    })

    # 测试权限检查
    allowed = await check_permission('user:alice', 'can_edit', 'document:doc1')
    assert allowed == True

    # 测试无权限
    allowed = await check_permission('user:bob', 'can_edit', 'document:doc1')
    assert allowed == False
```

## 本章小结

本章介绍了 OpenFGA 与各种系统的集成方法：

**与认证系统集成**：
- OAuth 2.0、OIDC、SAML
- 关键：从 Token 中提取用户 ID
- 经验：一定要验证 Token 签名

**与 API 网关集成**：
- Kong、Traefik
- 关键：在网关层统一进行权限检查
- 经验：网关层做粗粒度检查，服务层做细粒度检查

**与应用框架集成**：
- Spring Boot、Django、Express.js
- 关键：使用中间件或拦截器
- 经验：利用框架机制，避免代码重复

**与身份提供者集成**：
- Auth0、Okta、Keycloak
- 关键：同步用户信息到 OpenFGA
- 经验：监听用户信息变更事件

**集成最佳实践**：
1. 统一用户 ID 格式
2. 缓存权限检查结果
3. 错误处理和降级
4. 监控和日志
5. 完整的测试

在实际项目中，需要根据具体情况选择合适的集成方式。记住：集成不是一次性的工作，需要持续优化和维护。

**下一步**：

在下一章中，我们将学习授权系统对比与迁移策略——了解不同授权系统的特点，以及如何从其他系统迁移到 OpenFGA。

准备好了吗？让我们继续！
