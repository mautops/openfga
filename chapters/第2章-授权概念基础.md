# 第 2 章：授权概念基础

在第 1 章中, 我们看到了传统授权系统面临的挑战, 也了解了 OpenFGA 如何解决这些问题. 但你可能还在思考: 授权到底是什么? 为什么需要细粒度授权? RBAC、ABAC、ReBAC 这些模型有什么区别? 本章将回答这些问题, 帮助你理解授权的核心概念和各种授权模型, 为学习 OpenFGA 奠定理论基础.

## 2.1 授权的基本概念

在第 1 章中, 我们已经了解了授权系统的重要性以及传统授权系统面临的挑战. 本节将简要回顾授权的基本概念, 重点介绍授权的核心要素, 为后续学习授权模型奠定基础.

**授权**是指对信息安全或计算机安全相关的资源定义与授予访问权限的过程. 授权过程在用户完成身份认证(Authentication)之后进行, 是访问控制的第二个阶段. 认证解决的是"你是谁", 授权解决的是"你能做什么".

**授权的核心要素：**

1. **主体(Subject)**: 请求访问资源的实体, 通常是用户, 也可以是应用程序、服务或其他系统实体. 在 OpenFGA 中, 主体可以是用户(`user:alice`)、组织(`organization:acme`)、团队(`team:engineering`)等.

2. **资源(Resource/Object)**: 被访问的目标, 可以是数据、文件、API 端点、功能模块等. 在 OpenFGA 中, 资源通过类型和标识符表示, 如 `document:report`、`folder:project`.

3. **权限(Permission)**: 主体对资源可以执行的操作, 如读取、写入、删除、执行等. 在 OpenFGA 中, 权限通过关系(Relation)来表达, 如 `viewer`、`editor`、`owner`.

4. **授权策略(Authorization Policy)**: 定义主体、资源和权限之间关系的规则集合. 在 OpenFGA 中, 授权策略通过授权模型(Authorization Model)来定义.

**授权的基本流程：** 用户请求 → 身份认证 → 授权检查 → 访问决策 → 允许/拒绝. 授权不是一次性的操作, 而是动态的、持续的过程, 每当用户请求访问资源时, 系统都需要重新进行授权检查.

## 2.2 主流授权模型

在授权系统的发展过程中, 业界提出了多种授权模型, 每种模型都有其适用的场景和特点. 本节将介绍三种主流的授权模型: RBAC、ABAC 和 ReBAC.

### 2.2.1 RBAC（角色基础访问控制）

RBAC(Role-Based Access Control), 即基于角色的访问控制, 是目前应用最广泛的授权模型之一. RBAC 通过角色(Role)作为用户和权限之间的中介, 简化了权限管理. RBAC 模型的基本思想是: 用户被分配到角色, 角色被赋予权限, 用户通过角色间接获得权限, 形成"用户 → 角色 → 权限 → 资源"的授权链.

RBAC 模型可以分为四个层次: RBAC0(基础 RBAC)提供用户-角色-权限的基本关系; RBAC1(层次化 RBAC)支持角色层次结构(角色继承); RBAC2(约束 RBAC)支持静态职责分离(SSD)和动态职责分离(DSD); RBAC3(完整 RBAC)结合 RBAC1 和 RBAC2 的所有特性.

RBAC 的优势包括: 简化权限管理, 通过角色管理权限, 避免了直接为用户分配权限的复杂性; 易于理解和实现, 概念直观, 适合大多数企业场景; 便于审计, 角色的权限变更影响所有用户, 便于统一管理; 支持职责分离, 通过角色约束实现职责分离.

RBAC 的局限性包括: 粒度受限, 难以实现基于资源实例的细粒度权限控制; 动态权限支持不足, 难以处理基于时间、位置、上下文等的动态权限; 关系型权限困难, 难以表达用户之间的复杂关系; 角色爆炸, 在复杂场景下需要的角色数量急剧增长.

### 2.2.2 ABAC（属性基础访问控制）

ABAC(Attribute-Based Access Control), 即基于属性的访问控制, 是一种灵活的授权模型, 它使用主体(Subject)、资源(Resource)、操作(Action)和环境(Environment)的属性来定义访问策略. ABAC 模型的决策基于四个维度的属性: 主体属性包括用户的身份、角色、部门、安全级别等; 资源属性包括资源的所有者、敏感级别、分类等; 操作属性包括操作类型、时间戳等; 环境属性包括时间、位置、IP 地址、设备类型等. ABAC 决策规则遵循"IF (主体属性 AND 资源属性 AND 操作属性 AND 环境属性) THEN 允许/拒绝"的逻辑.

ABAC 的典型应用场景包括: 时间限制访问, 只有在工作时间内才能访问敏感数据; 位置限制访问, 只有从公司内部网络才能访问管理系统; 数据分类访问, 用户只能访问自己安全级别以下的资源.

ABAC 的优势包括: 高度灵活, 可以表达非常复杂的授权规则; 细粒度控制, 支持基于资源实例、上下文等的细粒度权限控制; 动态决策, 支持基于环境属性的动态权限决策; 策略集中管理, 授权策略可以集中定义和管理.

ABAC 的局限性包括: 复杂度高, 策略定义和管理复杂, 需要专业的知识; 性能挑战, 复杂的属性评估可能影响性能; 标准化不足, 缺乏统一的标准, 不同实现之间差异较大; 调试困难, 策略复杂时难以理解和调试授权决策.

### 2.2.3 ReBAC（关系基础访问控制）

ReBAC(Relationship-Based Access Control), 即基于关系的访问控制, 是 Google Zanzibar 和 OpenFGA 采用的授权模型. ReBAC 通过定义实体之间的关系来表达权限, 将授权问题转化为关系图的查询问题. 传统 RBAC 模型通过角色作为中介来分配权限: `用户 → 角色 → 权限 → 资源`. ReBAC 模型直接通过关系来表达权限: `用户 → 关系 → 资源`. 这种直接的关系表达方式使得 ReBAC 能够更灵活地处理复杂的权限场景, 特别适合需要表达复杂用户关系和资源关系的协作场景, 如文档协作、代码托管等.

### 2.2.4 授权模型对比分析

三种授权模型各有优劣, 适用于不同的场景. 以下从多个维度对比它们的差异:

| 维度         | RBAC         | ABAC         | ReBAC          |
| ------------ | ------------ | ------------ | -------------- |
| **复杂度**   | 低           | 高           | 中             |
| **灵活性**   | 中           | 高           | 高             |
| **性能**     | 高           | 中           | 高             |
| **粒度控制** | 粗粒度       | 细粒度       | 细粒度         |
| **动态权限** | 弱           | 强           | 中             |
| **关系建模** | 弱           | 中           | 强             |
| **适用场景** | 企业内部门户 | 安全敏感系统 | 协作平台、SaaS |

**选择建议：**

- **选择 RBAC 的场景**: 传统企业内部系统, 权限结构相对固定, 需要快速实现, 团队对授权模型不熟悉.

- **选择 ABAC 的场景**: 需要基于时间、位置、上下文等的动态权限控制, 安全级别要求高, 有专业的策略管理团队.

- **选择 ReBAC 的场景**: 协作类应用(文档协作、代码托管等), 多租户 SaaS 应用, 权限模型需要频繁演进, 需要高性能的权限查询.

在实际应用中, 不同的授权模型可以组合使用, 例如第一层使用 RBAC 进行快速过滤, 第二层使用 ReBAC 进行关系检查, 第三层使用 ABAC 进行属性检查, 通过多层授权检查实现更细粒度和灵活的权限控制.

## 2.3 传统授权系统的局限性

在第 1 章中, 我们已经详细介绍了传统授权系统面临的挑战, 包括角色爆炸、策略管理复杂性、分布式架构中的授权困境、测试与调试困境、性能问题、安全风险和开发资源浪费等. 这些局限性促使我们寻求更好的授权解决方案, 也为 OpenFGA 的诞生提供了契机.

## 2.4 OpenFGA 的关系型访问控制模型

在第 1 章中, 我们已经了解了 OpenFGA 的诞生背景和核心价值. OpenFGA 采用关系型访问控制(ReBAC)模型, 这是 Google Zanzibar 的核心设计理念. 本节将深入介绍 ReBAC 的核心思想和 OpenFGA 的实现方式.

### 2.4.1 ReBAC 的核心思想

ReBAC 的核心思想是将授权问题转化为关系图的查询问题. 在 ReBAC 模型中, **关系(Relation)**是连接用户和资源、资源与资源之间的纽带, 关系具有类型化、方向性、可传递性和组合性等特点. 这些关系形成一个关系图(Relationship Graph), 授权决策就是在这个图上进行查询和计算. ReBAC 的核心原则包括: 权限通过关系来表达, 而不是直接赋予用户; 关系可以继承和组合; 关系图支持高效的查询和计算. OpenFGA 使用高效的图遍历算法来查找权限路径, 并采用短路计算、并发处理、缓存机制、循环检测等优化策略.

### 2.4.2 OpenFGA 的实现方式

OpenFGA 通过授权模型(Authorization Model)和关系元组(Relationship Tuple)来实现 ReBAC.

**授权模型(Authorization Model)**定义了系统中的**类型(Type)**和**关系(Relation)**. 模型使用声明式的 DSL(领域特定语言)来定义:

```openfga
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define editor: [user, team#member]
    define viewer: [user, team#member] or editor

type team
  relations
    define member: [user]

type folder
  relations
    define parent: [folder]
    define owner: [user]
    define editor: [user] or editor from parent
    define viewer: [user] or editor or viewer from parent
```

**关系元组(Relationship Tuple)**表示具体的关系数据, 是授权模型的数据实例. 关系元组遵循 `user:relation:object` 的格式, 例如: `user:alice` 与 `document:report` 之间存在 `owner` 关系, `user:bob` 与 `document:report` 之间存在 `editor` 关系, `team:engineering` 与 `document:report` 之间存在 `editor` 关系.

**OpenFGA 权限检查**是通过 Check API 进行的. Check API 的处理流程包括: 接收请求, 提取请求信息(用户、关系、对象), 加载授权模型, 查询关系数据, 在关系图上进行遍历计算, 应用授权规则, 生成授权决策, 记录审计日志, 返回授权结果. OpenFGA 还提供了批量检查 API, 允许在单个请求中执行多个授权检查.

**关系的继承和组合**: OpenFGA 支持复杂的关系继承和组合. 关系继承如 `viewer: [user] or editor` 表示 viewer 继承 editor; 间接关系如 `editor: [user, team#member]` 表示编辑者可以是用户或团队成员; 对象间关系如 `viewer: [user] or viewer from parent` 表示继承父文件夹的查看权限.

## 2.5 OpenFGA 如何实现 RBAC 和 ABAC

虽然 OpenFGA 的核心是 ReBAC 模型, 但它也支持通过关系模型来实现传统的 RBAC 和 ABAC 模式.

### 2.5.1 在 OpenFGA 中实现 RBAC

RBAC 模型可以通过 OpenFGA 的关系模型来实现. 核心思想是将角色(Role)建模为关系, 权限(Permission)通过关系来表达:

```openfga
model
  schema 1.1

type user

type resource
  relations
    define admin: [user]
    define editor: [user]
    define viewer: [user]

    # 权限映射：将 RBAC 角色映射为关系
    define can_delete: admin
    define can_edit: admin or editor
    define can_view: admin or editor or viewer
```

支持角色层次结构(角色继承):

```openfga
type resource
  relations
    define admin: [user]
    define editor: [user] or admin  # editor 继承 admin
    define viewer: [user] or editor  # viewer 继承 editor
```

在 OpenFGA 中实现 RBAC 的优势包括: 统一的管理接口, 可以通过关系模型扩展, 支持权限查询和分析. 限制包括: 需要额外的关系定义来映射权限, 不如原生 ReBAC 模型灵活, 对于简单的 RBAC 场景可能过度设计.

### 2.5.2 在 OpenFGA 中实现 ABAC

OpenFGA 通过条件关系(Conditional Relations)和上下文元组(Contextual Tuples)来支持 ABAC 模式.

**基于条件的 ABAC**: OpenFGA 允许在关系定义中使用条件来限制关系:

```openfga
type document
  relations
    define viewer: [user with time_based_access]

condition time_based_access(current_time: timestamp, grant_time: timestamp, duration: duration) {
  current_time < grant_time + duration
}
```

**基于属性的 ABAC**: 可以通过资源类型和关系来建模资源属性. **基于环境的 ABAC**: 使用上下文元组来传递环境属性(如 IP 地址、地理位置等).

在 OpenFGA 中实现 ABAC 存在一些限制: 条件表达能力有限, 属性数据管理需要将用户和资源的属性转换为关系或条件上下文, 复杂的条件评估可能影响性能.

**混合模式**: 在实际应用中, 可以将 RBAC、ABAC 和 ReBAC 组合使用, 在 OpenFGA 的统一框架下实现复杂的授权需求.

**建议**: 优先使用原生 ReBAC; 条件关系用于简单 ABAC; 复杂 ABAC 结合应用层; RBAC 用于简单场景, 但考虑是否过度设计.

## 2.6 授权决策的基本流程

授权决策是一个复杂的计算过程, 涉及请求验证、权限查询、决策计算和结果返回等多个步骤.

### 2.6.1 授权检查流程

授权检查流程包括以下步骤: 接收授权请求, 提取请求信息(用户、资源、操作), 加载授权模型(OpenFGA 中授权模型是不可变的, 每个模型都有唯一的 ID), 查询关系数据(支持多种存储后端, 使用索引和缓存优化), 关系图遍历计算(使用高效的图遍历算法, 包括直接关系检查、间接关系检查、继承关系检查、对象间关系检查, 采用短路计算、并发处理、循环检测、深度限制等优化), 应用授权规则, 生成授权决策, 记录审计日志, 返回授权结果.

### 2.6.2 权限计算原理

权限计算是授权系统的核心. 在 OpenFGA 等关系型授权系统中, 权限关系被建模为图结构: 节点(Node)是实体(用户、资源), 边(Edge)是关系(owner、editor、viewer). 权限计算本质上是图遍历问题, OpenFGA 主要使用深度优先搜索(DFS)算法进行权限计算.

**缓存优化**: OpenFGA 支持多级缓存(内存缓存、Redis 缓存、数据库查询), 缓存策略包括检查内存缓存、检查 Redis 缓存、计算权限并更新缓存、设置合理的缓存过期时间.

**时间复杂度**: 最佳情况 O(1)(直接关系存在, 缓存命中), 平均情况 O(d × b)(d 为关系深度, b 为每个节点的平均分支数), 最坏情况 O(V + E)(需要遍历整个关系图).

**优化策略**: 关系设计避免过深的关系链, 合理使用缓存减少计算, 对关系数据建立合适的索引, 使用 Batch Check API 批量查询, 对于频繁查询的关系可以预计算并缓存结果.

**权限计算原则**: 关系优先(先检查直接关系, 再检查间接关系, 最后检查继承关系), 继承处理(自动处理关系的继承), 短路优化(一旦找到有效路径立即返回), 结果缓存(对计算结果进行缓存), 循环检测(防止循环导致无限递归), 并发处理(对于多个可能的路径使用并发处理).

**Check API 的内部实现**涉及多个层次: CachedCheckResolver(缓存层)检查缓存, DispatchThrottledCheckResolver(调度层)控制并发, LocalChecker(本地计算层)执行实际的关系图遍历计算, Storage(存储层)提供关系数据的存储和查询接口.

## 本章小结

通过本章的学习, 你已经了解了授权的核心概念和各种授权模型, 为后续学习 OpenFGA 奠定了理论基础.

我们首先探讨了授权的基本概念, 包括授权的核心要素(主体、资源、权限、授权策略)和基本流程.

接着, 我们介绍了三种主流的授权模型: RBAC 通过角色作为用户和权限之间的中介, 适合传统企业内部系统, 但在细粒度控制和动态权限支持方面存在局限性; ABAC 使用主体、资源、操作和环境的属性来定义访问策略, 具有高度的灵活性, 但复杂度高; ReBAC 通过定义实体之间的关系来表达权限, 表达能力强, 灵活且可扩展, 特别适合协作平台和 SaaS 应用. 通过对比分析, 可以根据不同场景选择合适的授权模型, 也可以在实际应用中组合使用这些模型.

然后, 我们简要回顾了传统授权系统的局限性, 这些内容在第 1 章中已有详细介绍.

我们介绍了 OpenFGA 的关系型访问控制模型. OpenFGA 采用 ReBAC 模型, 通过授权模型定义类型和关系, 通过关系元组表示具体的关系数据, 支持复杂的关系继承和组合. 我们还展示了如何在 OpenFGA 中实现 RBAC 和 ABAC, 虽然 OpenFGA 的核心是 ReBAC, 但它也支持通过关系模型来实现传统的 RBAC 和 ABAC 模式.

最后, 我们介绍了授权决策的基本流程和权限计算原理. 授权检查是一个多步骤的过程, 权限计算本质上是图遍历问题, OpenFGA 使用高效的图遍历算法和缓存机制来保证性能.

现在, 你已经掌握了授权的基础知识, 了解了不同授权模型的特点和适用场景. 在第 3 章中, 我们将深入学习 OpenFGA 的架构与组件, 了解 OpenFGA 的系统设计、核心组件以及存储后端的配置.
