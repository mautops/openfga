# 第 3 章：快速入门

5 分钟上手 OpenFGA：从安装到第一个授权检查

---

理论讲得再多，不如动手实践来得实在。这一章我们直接上手——通过一个文档协作系统示例，让你在 5 分钟内完成从环境搭建到第一个授权检查的全过程。

当你看到第一个 `allowed: true` 输出时，那种成就感...值了！

## 3.1 环境搭建：一键启动 OpenFGA

在开始之前，我们需要快速搭建一个 OpenFGA 运行环境。用过 Docker？那这个过程对你来说就是小菜一碟。没用过？也不用担心，跟着步骤走就行。

### 启动 OpenFGA 服务

OpenFGA 提供了官方的 Docker 镜像，一条命令就能启动：

```bash
docker run -p 8080:8080 -p 8081:8081 -p 3000:3000 openfga/openfga run
```

这条命令会启动三个服务端口：
- **8080** - HTTP API 端口，用于 REST 接口调用
- **8081** - gRPC API 端口，用于高性能场景
- **3000** - Playground 端口，提供可视化界面

当你看到类似 `🚀 starting HTTP server on '0.0.0.0:8080'` 的输出时，说明服务已经跑起来了。

> **小提示**：有时 Playground 页面创建 Store 时会无法保存（我第一次用的时候就遇到了这个坑），这时候可以直接使用官方的在线版本 `https://play.fga.dev`。

### 安装 CLI 工具

在实际开发中，CLI 工具比 Web 界面更高效。安装过程很简单：

**macOS 用户**（推荐使用 Homebrew）：
```bash
brew install openfga/tap/fga
```

**Linux 用户**：
```bash
curl -L https://github.com/openfga/cli/releases/latest/download/fga-linux-amd64 -o fga
chmod +x fga && sudo mv fga /usr/local/bin/
```

**Windows 用户**：
使用 Chocolatey 安装 `choco install fga`，或从 [GitHub Releases](https://github.com/openfga/cli/releases) 下载可执行文件。

安装完成后，验证一下服务是否正常：

```bash
fga health
# 输出: {"status":"ok"}
```

如果你修改了默认端口或使用远程服务器，可以设置环境变量：

```bash
export FGA_API_URL="http://localhost:8080"
```

### 可视化界面（可选）

想用可视化界面？访问 Playground（`http://localhost:3000`）就行。Playground 提供了图形化的模型编辑器，权限模型会以关系图的形式展示——这个可视化功能非常直观，特别适合理解复杂的权限关系。

不过本章主要用 CLI 工具演示，因为在 CI/CD 和自动化脚本中，CLI 更实用。

## 3.2 创建 Store 和授权模型

服务已经跑起来了，接下来创建第一个 Store（存储空间）和授权模型。

### 理解 Store 的概念

Store 是什么？把它想象成一个独立的数据库——每个 Store 都有自己独立的授权模型和关系元组。在实际项目中，通常会为每个应用或租户创建一个独立的 Store，这样可以实现严格的数据隔离。

比如，你可能会创建：
- `生产环境-电商平台` - 用于生产环境
- `测试环境-文档系统` - 用于测试环境
- `租户A-SaaS应用` - 用于多租户场景

### 创建 Store

用 CLI 创建 Store 非常简单：

```bash
fga store create --name "我的第一个应用"
```

命令会返回 Store ID，保存这个 ID：

```bash
export STORE_ID="01HZ3XK5Y8M9N0P1Q2R3S4T5U"
```

### 设计授权模型

授权模型定义了系统中的实体类型、关系和权限。让我们为文档协作系统设计一个简单的模型。

**业务需求**：
- 用户可以创建文档并成为所有者
- 所有者可以邀请其他用户查看或编辑文档
- 查看者只能查看，编辑者可以查看和编辑

**模型设计**：

```fga
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor
```

这个模型定义了三种关系：
- **owner** - 文档所有者
- **editor** - 编辑者，继承 owner 的权限
- **viewer** - 查看者，继承 editor 的权限

注意这里的继承关系：`owner` → `editor` → `viewer`。这意味着所有者自动拥有编辑和查看权限，编辑者自动拥有查看权限。

将模型保存到文件 `model.fga`，然后写入 OpenFGA：

```bash
fga model write --store-id ${STORE_ID} --file model.fga
```

命令会返回 Model ID，保存它：

```bash
export MODEL_ID="01HZ3XK5Y8M9N0P1Q2R3S4T5U6V"
```

> **实际开发经验**：模型设计往往需要多次迭代。不用担心，OpenFGA 支持模型版本管理，每次修改都会创建新版本，旧版本的关系元组仍然有效——这为你提供了平滑的迁移路径。

**完整模型示例**：参考 [文档基础权限模型](../models/05.01.document-basic/)

## 3.3 建立权限关系

关系元组（Relationship Tuple）定义了实体之间的实际关系。在实际项目中，这些关系元组通常由应用代码在用户执行操作时自动创建——比如用户创建文档时创建 `owner` 关系，用户邀请协作者时创建 `viewer` 或 `editor` 关系。

### 创建关系元组

让我们模拟一个真实的协作场景：

```bash
# alice 创建文档，成为所有者
fga tuple write --store-id ${STORE_ID} user:alice owner document:doc1

# alice 邀请 bob 查看文档
fga tuple write --store-id ${STORE_ID} user:bob viewer document:doc1

# alice 邀请 charlie 编辑文档
fga tuple write --store-id ${STORE_ID} user:charlie editor document:doc1
```

关系元组的格式为 `user:alice#owner@document:doc1`，表示"用户 alice 是文档 doc1 的所有者"。

> **实践建议**：确保用户标识和对象标识的格式一致。我建议使用 `type:id` 的格式，比如 `user:123`、`document:abc-123`。这样在调试时会清晰很多。

### 查看关系元组

创建关系元组后，你可以查看已创建的关系：

```bash
# 查询特定对象的所有关系
fga tuple read --store-id ${STORE_ID} --object document:doc1
```

输出会显示所有与 `document:doc1` 相关的关系元组。

> **调试技巧**：这个查询命令在调试权限问题时非常有用。当用户报告"我没有权限访问某个资源"时，第一步就是查看关系元组，确认关系是否正确创建。

## 3.4 执行权限检查

激动人心的时刻到了！我们已经创建了授权模型和关系元组，现在来执行第一个授权检查。

### 基本权限检查

用 CLI 进行权限检查：

```bash
# 检查 alice 是否有编辑权限
fga query check --store-id ${STORE_ID} user:alice editor document:doc1
# 输出: allowed: true
```

成功了！alice 确实拥有编辑权限——因为她是文档的所有者，而 `editor` 关系继承了 `owner` 的权限。

再检查一下 bob 的权限：

```bash
# 检查 bob 是否有编辑权限
fga query check --store-id ${STORE_ID} user:bob editor document:doc1
# 输出: allowed: false
```

bob 没有编辑权限，因为他只是查看者。

### 验证权限继承

OpenFGA 的强大之处在于它的权限继承机制。让我们验证一下：

```bash
# alice 作为 owner，自动拥有 viewer 权限
fga query check --store-id ${STORE_ID} user:alice viewer document:doc1
# 输出: allowed: true

# charlie 作为 editor，自动拥有 viewer 权限
fga query check --store-id ${STORE_ID} user:charlie viewer document:doc1
# 输出: allowed: true
```

即使我们没有为 alice 和 charlie 创建 `viewer` 关系元组，但由于权限继承机制，他们自动拥有查看权限。

这就是 OpenFGA 关系继承的魅力所在——你只需要定义核心关系，OpenFGA 会自动处理权限的传播。

> **实践经验**：这种继承机制大大简化了权限管理。不需要为每个用户显式创建所有关系，只需要创建核心关系，OpenFGA 会自动计算派生权限。我在实际项目中用这个特性省了不少事。

### 简化命令（可选）

每次都要输入 `--store-id` 和 `--model-id` 参数？太麻烦了。创建配置文件 `~/.fga.yaml`：

```yaml
api-url: http://localhost:8080
store-id: ${STORE_ID}
model-id: ${MODEL_ID}
```

配置后，命令就简化了：

```bash
fga query check user:alice editor document:doc1
```

清爽多了！

**完整集成示例**：参考 [Python SDK 基础集成](../integrates/01.python-sdk-basic/)

## 3.5 常见问题排查

在快速入门过程中，你可能会遇到一些常见问题。这里提供快速排查方法。

### 授权检查返回 false

当授权检查返回 `allowed: false` 时，按以下步骤排查：

1. **检查关系元组是否存在**
   ```bash
   fga tuple read --store-id ${STORE_ID} --object document:doc1
   ```

2. **检查授权模型**
   ```bash
   fga model get --store-id ${STORE_ID} --model-id ${MODEL_ID}
   ```

3. **验证模型语法**
   ```bash
   fga model validate --file model.fga
   ```

> **踩坑经验**：我第一次用 OpenFGA 时，权限检查一直返回 false。排查了半天才发现是 Model ID 用错了——我用的是旧版本的 Model ID，而关系元组是在新版本模型下创建的。所以记得每次更新模型后，都要更新 MODEL_ID 环境变量！

### Docker 启动失败

如果 Docker 容器无法启动：

1. 检查 Docker 是否运行：`docker ps`
2. 检查端口是否被占用：`lsof -i :8080`（macOS/Linux）
3. 查看容器日志：`docker logs <container_id>`

端口被占用？修改端口映射，比如用 `-p 8082:8080`。

### Store ID 或 Model ID 错误

遇到 "store not found" 或 "model not found" 错误？

```bash
# 列出所有 Store
fga store list

# 查看当前 Store 的 Model ID
fga model get --store-id ${STORE_ID} --field id
```

## 本章小结

通过本章的学习，你已经完成了 OpenFGA 的快速入门，掌握了从环境搭建到第一个授权检查的完整流程。

**核心要点**：

- OpenFGA 使用 Docker 一键启动，CLI 工具简化日常操作
- Store 提供数据隔离，每个应用或租户使用独立的 Store
- 授权模型定义类型和关系，支持权限继承机制
- 关系元组建立实体间的实际关系
- 权限检查验证用户是否有权限执行操作

**关键收获**：

OpenFGA 的权限模型设计非常灵活。当业务需求变化时，只需要修改授权模型，不需要修改应用代码。权限继承机制大大简化了权限管理——你只需要定义核心关系，OpenFGA 会自动处理权限的传播。

**下一步**：

现在你已经掌握了 OpenFGA 的基本使用方法。在第 4 章中，我们将深入学习 OpenFGA 的架构与组件——了解 OpenFGA 的系统设计、核心组件以及存储后端的配置。这将帮助你更好地理解 OpenFGA 的工作原理，为后续的高级应用打下坚实的基础。

准备好了吗？让我们继续深入探索 OpenFGA 的世界！
