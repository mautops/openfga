# 第 3 章：快速入门

5 分钟上手 OpenFGA：从安装到第一个授权检查

---

作为开发者, 你可能已经迫不及待想要开始使用 OpenFGA 了. 理论讲得再多, 不如动手实践来得实在. 这一章我们将通过一个完整的文档协作系统示例, 让你在 5 分钟内完成从环境搭建到第一个授权检查的全过程. 相信我, 当你看到第一个 `allowed: true` 输出时, 那种成就感会让你觉得之前的等待都是值得的.

## 3.1 环境准备与快速启动

在开始之前, 我们需要快速搭建一个 OpenFGA 运行环境. 如果你之前用过 Docker, 这个过程对你来说应该轻车熟路. 如果你还没接触过 Docker, 也不用担心, 跟着步骤一步步来就行.

**前置要求：**

- 已安装 Docker（版本 20.10 或更高）
- 确保 Docker 服务正在运行

**一键启动 OpenFGA：**

OpenFGA 提供了官方的 Docker 镜像, 开发者只需要一条命令就能启动服务:

```bash
docker pull openfga/openfga && \
docker run -p 8080:8080 -p 8081:8081 -p 3000:3000 openfga/openfga run
```

命令说明: `-p 8080:8080` 映射 HTTP API 端口, `-p 8081:8081` 映射 gRPC API 端口, `-p 3000:3000` 映射 Playground 端口（可选, 用于可视化测试）. 当开发者看到类似以下输出时, 表示服务已成功启动:

```
{"level":"info","ts":1234567890.123,"msg":"starting openfga service..."}
{"level":"info","ts":1234567890.456,"msg":"grpc server listening","addr":"0.0.0.0:8081"}
{"level":"info","ts":1234567890.789,"msg":"http server listening","addr":"0.0.0.0:8080"}
```

**安装 fga CLI 工具：**

在实际开发中, 开发者会发现 CLI 工具比 Web 界面更高效. 安装 fga CLI 的过程很简单, 但不同操作系统略有差异.

**macOS/Linux 系统：**

```bash
curl -L https://github.com/openfga/cli/releases/latest/download/fga-darwin-amd64 -o fga
chmod +x fga
sudo mv fga /usr/local/bin/
fga version
```

如果开发者使用 Homebrew, 安装会更简单:

```bash
brew install openfga/tap/fga
```

**Windows 系统：**

Windows 开发者可以使用 Chocolatey: `choco install fga`, 或从 [GitHub Releases](https://github.com/openfga/cli/releases) 手动下载可执行文件.

**配置 fga CLI：**

安装完成后, 开发者需要告诉 CLI 工具 OpenFGA 服务在哪里. 如果使用默认地址（localhost:8080）, 可以跳过这一步. 如果开发者修改了端口或使用远程服务器, 需要设置环境变量:

```bash
export FGA_API_URL="http://localhost:8080"
```

**验证服务运行状态：**

现在开发者可以使用 fga CLI 验证服务是否正常运行:

```bash
fga health
```

如果服务正常, 开发者会看到类似 `{"status":"ok"}` 的输出. 或者打开浏览器访问 `http://localhost:8080/healthz`, 也能看到相同的响应. 如果开发者想使用可视化界面, 可以访问 Playground（`http://localhost:3000`）进行可视化测试.

**注意**: 本章主要使用 fga CLI 命令行工具进行操作, Playground 作为辅助工具. 如果你更喜欢可视化界面, 也可以全程使用 Playground, 但建议开发者掌握 CLI 的使用方法, 因为在 CI/CD 和自动化脚本中, CLI 工具更加实用.

---

## 3.2 创建第一个 Store 和授权模型

现在我们已经启动了 OpenFGA 服务, 接下来创建第一个 Store（存储空间）和授权模型. Store 是 OpenFGA 中用于隔离不同应用或租户数据的逻辑容器, 每个 Store 都有自己独立的授权模型和关系元组. 在实际项目中, 开发者通常会为每个应用或租户创建一个独立的 Store, 这样可以实现严格的数据隔离.

**创建 Store：**

使用 fga CLI 创建 Store 非常简单:

```bash
fga store create --name "我的第一个应用"
```

输出示例会显示 Store ID, 开发者需要保存这个 ID 并设置为环境变量:

```bash
export STORE_ID="01HZ3XK5Y8M9N0P1Q2R3S4T5U"
```

在实际项目中, 开发者可能会创建多个 Store, 建议使用有意义的名称, 比如 `"生产环境-电商平台"` 或 `"测试环境-文档系统"`, 这样便于管理和识别.

**创建授权模型：**

授权模型定义了系统中的实体类型、关系和权限. 让我们创建一个简单的文档协作系统模型. 首先将授权模型保存到文件 `model.fga`:

```bash
cat > model.fga << 'EOF'
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define viewer: [user] or owner
    define editor: [user] or owner
EOF
```

然后使用 fga CLI 写入模型:

```bash
fga model write --store-id ${STORE_ID} --file model.fga
```

输出会显示 Model ID, 开发者需要保存它:

```bash
export MODEL_ID="01HZ3XK5Y8M9N0P1Q2R3S4T5U6V"
```

**理解模型的基本结构：**

授权模型由三个核心概念组成: **类型（Type）**是系统中的实体类型, 如 `user`、`document`; **关系（Relation）**是实体之间的关系, 如 `owner`、`viewer`; **权限（Permission）**是通过关系定义的访问权限. 在上面的模型中, `viewer` 和 `editor` 都继承了 `owner` 的权限, 这意味着如果用户是文档的所有者, 自动拥有查看和编辑权限. 这种继承机制让权限模型更加灵活和强大.

在实际开发中, 开发者可能会发现模型设计需要多次迭代. 不用担心, OpenFGA 支持模型版本管理, 每次修改都会创建新版本, 旧版本的关系元组仍然有效, 这为开发者提供了平滑的迁移路径.

---

## 3.3 创建关系元组

关系元组（Relationship Tuple）定义了实体之间的实际关系. 现在让我们创建一些关系元组来建立用户和文档之间的关系. 在实际项目中, 这些关系元组通常由应用代码在用户执行操作时自动创建, 比如用户创建文档时创建 `owner` 关系, 用户邀请协作者时创建 `viewer` 或 `editor` 关系.

**创建关系元组：**

使用 fga CLI 创建单个关系元组:

```bash
# 创建文档所有者关系
fga tuple write --store-id ${STORE_ID} user:alice owner document:doc1

# 创建查看者关系
fga tuple write --store-id ${STORE_ID} user:bob viewer document:doc1
```

在实际项目中, 开发者往往需要一次性创建多个关系元组. 这时可以创建一个 JSON 文件:

```bash
cat > tuples.json << 'EOF'
{
  "tuples": [
    {"user": "user:alice", "relation": "owner", "object": "document:doc1"},
    {"user": "user:bob", "relation": "viewer", "object": "document:doc1"}
  ]
}
EOF

fga tuple write --store-id ${STORE_ID} --file tuples.json
```

**理解关系元组的含义：**

关系元组的格式为 `user:alice#owner@document:doc1`, 其中 `user:alice` 是用户标识, `owner` 是关系类型, `document:doc1` 是文档标识. 这个元组表示用户 alice 是文档 doc1 的所有者. 在实际项目中, 开发者需要确保用户标识和对象标识的格式一致, 建议使用 `type:id` 的格式, 比如 `user:123`、`document:abc-123`.

**查看关系元组：**

创建关系元组后, 开发者可以使用 fga CLI 查看已创建的关系元组:

```bash
# 查询特定对象的所有关系元组
fga tuple read --store-id ${STORE_ID} --object document:doc1
```

输出示例会显示 `user:alice → owner → document:doc1` 和 `user:bob → viewer → document:doc1`. 开发者也可以查询特定用户的所有关系元组:

```bash
# 查询特定用户的所有关系元组
fga tuple read --store-id ${STORE_ID} --user user:alice
```

如果需要 JSON 格式输出, 可以使用 `--format json` 参数:

```bash
fga tuple read --store-id ${STORE_ID} --object document:doc1 --format json
```

在实际开发中, 开发者会发现这些查询命令非常有用, 特别是在调试权限问题时, 能够快速查看用户和资源之间的关系.

---

## 3.4 执行第一个授权检查

现在我们已经创建了授权模型和关系元组, 接下来执行第一个授权检查, 验证权限是否正确. 这是最激动人心的时刻, 开发者将看到 OpenFGA 如何根据关系元组和授权模型进行权限计算.

**使用 fga CLI 进行权限检查：**

使用 fga CLI 进行权限检查非常简单:

```bash
# 检查 alice 是否有编辑权限
fga query check --store-id ${STORE_ID} --model-id ${MODEL_ID} user:alice editor document:doc1
```

如果一切正常, 开发者会看到 `allowed: true` 的输出. 这意味着 alice 确实拥有编辑权限, 因为她被设置为文档的所有者, 而 `editor` 关系继承了 `owner` 的权限.

让我们再检查一下 bob 的权限:

```bash
# 检查 bob 是否有编辑权限
fga query check --store-id ${STORE_ID} --model-id ${MODEL_ID} user:bob editor document:doc1
```

这次开发者会看到 `allowed: false`, 因为 bob 只是查看者, 而 `editor` 关系不继承 `viewer` 的权限.

**使用配置文件简化命令：**

在实际开发中, 开发者会发现每次都要输入 `--store-id` 和 `--model-id` 参数很麻烦. OpenFGA CLI 支持配置文件, 可以避免重复输入参数. 创建 `~/.fga.yaml` 配置文件:

```bash
cat > ~/.fga.yaml << EOF
api-url: http://localhost:8080
store-id: ${STORE_ID}
model-id: ${MODEL_ID}
EOF
```

配置后, 开发者可以简化命令:

```bash
fga query check user:alice editor document:doc1
```

**理解授权检查的结果：**

`allowed: true` 表示用户拥有该权限, `allowed: false` 表示用户不拥有该权限. alice 有编辑权限是因为她是文档的所有者（`owner`）, 而 `editor` 关系继承了 `owner` 的权限. bob 没有编辑权限是因为他只是查看者（`viewer`）, 而 `editor` 关系不继承 `viewer` 的权限.

**验证权限传播机制：**

OpenFGA 的强大之处在于它的权限继承机制. 让我们验证一下:

```bash
# 检查 alice 是否有查看权限
fga query check --store-id ${STORE_ID} --model-id ${MODEL_ID} user:alice viewer document:doc1
```

即使我们没有为 alice 创建 `viewer` 关系元组, 但由于 alice 是 `owner`, 而 `viewer` 继承了 `owner` 的权限, 所以检查结果应该是 `allowed: true`. 这就是 OpenFGA 关系继承的魅力所在, 开发者只需要定义核心关系, OpenFGA 会自动处理权限的传播.

在实际项目中, 开发者会发现这种继承机制大大简化了权限管理. 不需要为每个用户显式创建所有关系, 只需要创建核心关系, OpenFGA 会自动计算派生权限.

---

## 3.5 使用配置文件简化操作

在实际开发中, 开发者会发现频繁输入 `--store-id` 和 `--model-id` 参数很麻烦. OpenFGA CLI 支持多种配置方式, 让开发者的工作更加高效.

**使用配置文件：**

创建 `~/.fga.yaml` 配置文件（全局配置）或项目目录下的 `.fga.yaml` 文件（项目配置）:

```bash
cat > ~/.fga.yaml << EOF
api-url: http://localhost:8080
store-id: ${STORE_ID}
model-id: ${MODEL_ID}
EOF
```

配置后, 开发者可以省略这些参数:

```bash
# 简化后的命令
fga query check user:alice editor document:doc1
fga tuple read --object document:doc1
fga model get
```

**使用环境变量：**

开发者也可以使用环境变量进行配置:

```bash
export FGA_API_URL="http://localhost:8080"
export FGA_STORE_ID="${STORE_ID}"
export FGA_MODEL_ID="${MODEL_ID}"
```

**查看当前配置：**

开发者可以使用以下命令查看当前配置:

```bash
# 查看配置的 Store ID
fga store get --field id

# 查看配置的 Model ID
fga model get --field id
```

在实际开发中, 建议开发者使用配置文件, 这样可以在不同项目间切换, 而不需要每次都设置环境变量.

---

## 3.6 第一个完整示例：文档协作系统

现在让我们完成一个完整的文档协作系统示例, 整合前面学到的所有知识. 场景是一个文档协作系统, 需要支持以下功能: 用户可以创建文档并成为所有者, 所有者可以邀请其他用户查看或编辑文档, 查看者只能查看文档不能编辑, 编辑者可以查看和编辑文档.

**权限模型设计：**

我们已经创建了授权模型, 现在扩展它, 添加明确的权限定义:

```openfga
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define viewer: [user] or owner
    define editor: [user] or owner
    define can_view: viewer or editor
    define can_edit: editor
```

这个模型定义了三个关系（`owner`、`viewer`、`editor`）和两个权限（`can_view`、`can_edit`）. 权限通过关系来定义, `can_view` 权限授予所有 `viewer` 和 `editor`, `can_edit` 权限只授予 `editor`. 由于 `viewer` 和 `editor` 都继承了 `owner` 的权限, 所以 `owner` 自动拥有所有权限.

**更新授权模型：**

使用 fga CLI 更新模型:

```bash
fga model write --store-id ${STORE_ID} --file model.fga
```

记住更新 `MODEL_ID` 环境变量:

```bash
export MODEL_ID=$(fga model get --store-id ${STORE_ID} --field id)
```

**关系元组创建：**

现在创建关系元组, 模拟一个真实的协作场景:

```bash
# alice 创建文档 doc1, 成为所有者
fga tuple write --store-id ${STORE_ID} user:alice owner document:doc1

# alice 邀请 bob 查看文档
fga tuple write --store-id ${STORE_ID} user:bob viewer document:doc1

# alice 邀请 charlie 编辑文档
fga tuple write --store-id ${STORE_ID} user:charlie editor document:doc1
```

或者使用批量写入方式, 这在初始化数据时更高效:

```bash
cat > tuples.json << 'EOF'
{
  "tuples": [
    {"user": "user:alice", "relation": "owner", "object": "document:doc1"},
    {"user": "user:bob", "relation": "viewer", "object": "document:doc1"},
    {"user": "user:charlie", "relation": "editor", "object": "document:doc1"}
  ]
}
EOF

fga tuple write --store-id ${STORE_ID} --file tuples.json
```

**权限检查验证：**

现在使用 fga CLI 验证各种权限（如果已配置 `~/.fga.yaml`, 可以省略 `--store-id` 和 `--model-id` 参数）:

```bash
# alice（所有者）可以查看和编辑
fga query check user:alice can_view document:doc1  # 预期: allowed: true
fga query check user:alice can_edit document:doc1  # 预期: allowed: true

# bob（查看者）只能查看, 不能编辑
fga query check user:bob can_view document:doc1    # 预期: allowed: true
fga query check user:bob can_edit document:doc1    # 预期: allowed: false

# charlie（编辑者）可以查看和编辑
fga query check user:charlie can_view document:doc1  # 预期: allowed: true
fga query check user:charlie can_edit document:doc1   # 预期: allowed: true
```

**验证关系继承：**

让我们验证一下关系继承是否正常工作:

```bash
# 验证 alice 作为 owner, 自动拥有 viewer 和 editor 关系
fga query check user:alice viewer document:doc1  # 预期: allowed: true
fga query check user:alice editor document:doc1  # 预期: allowed: true

# 验证 charlie 作为 editor, 自动拥有 viewer 关系
fga query check user:charlie viewer document:doc1  # 预期: allowed: true
```

**成功标志：** 所有权限检查都返回预期结果, 权限继承机制正常工作, 不同角色的权限正确区分. 恭喜！开发者已经完成了第一个完整的 OpenFGA 应用示例！

在实际项目中, 开发者会发现这种权限模型设计方式非常灵活. 当业务需求变化时, 只需要修改授权模型, 不需要修改应用代码, 这种解耦让权限管理变得简单而高效.

---

## 3.7 常见问题与快速排查

在快速入门过程中, 开发者可能会遇到一些常见问题. 这里提供快速排查方法, 帮助开发者快速定位和解决问题.

**启动失败问题排查：**

如果 Docker 容器无法启动, 开发者可以按照以下步骤排查:

1. 检查 Docker 是否运行: `docker ps`
2. 检查端口是否被占用: `lsof -i :8080`（macOS/Linux）或 `netstat -ano | findstr :8080`（Windows）
3. 查看容器日志: `docker logs <container_id>`

如果端口被占用, 开发者可以修改端口映射, 比如使用 `-p 8082:8080` 将容器内的 8080 端口映射到主机的 8082 端口. 如果 Docker 未运行, 需要启动 Docker 服务.

**授权检查返回 false 的原因分析：**

当授权检查返回 `allowed: false` 时, 开发者需要排查以下几个可能的原因:

1. **关系元组未创建**: 最常见的原因, 开发者可能忘记创建关系元组
2. **授权模型未设置**: 可能使用了错误的 Model ID
3. **关系定义错误**: 授权模型中的关系定义可能有问题
4. **权限继承路径错误**: 关系继承路径可能不正确

排查方法:

```bash
# 1. 检查关系元组是否存在
fga tuple read --store-id ${STORE_ID} --object document:doc1

# 2. 检查授权模型
fga model get --store-id ${STORE_ID} --model-id ${MODEL_ID}

# 3. 验证模型语法
fga model validate --file model.fga

# 4. 使用 Playground 可视化检查（访问 http://localhost:3000）
```

**模型语法错误排查：**

常见语法错误包括:

- 缺少类型定义: 确保所有使用的类型都已定义
- 关系引用错误: 确保关系引用正确, 比如 `editor` 不能引用不存在的 `admin` 关系
- 语法格式错误: 确保缩进和格式正确

开发者可以使用 Playground 的模型验证功能, 或查看 fga CLI 返回的错误信息进行排查. 在实际开发中, 建议开发者使用 VSCode 的 OpenFGA 扩展, 它提供了语法高亮和实时验证功能, 能够帮助开发者快速发现语法错误.

**Store ID 或 Model ID 错误：**

如果开发者遇到 "store not found" 或 "model not found" 错误, 可能是 Store ID 或 Model ID 不正确. 开发者可以使用以下命令查看:

```bash
# 列出所有 Store
fga store list

# 查看当前 Store 的 Model ID
fga model get --store-id ${STORE_ID} --field id
```

**配置文件问题：**

如果开发者使用了配置文件但命令仍然失败, 可以检查配置文件格式是否正确:

```bash
# 查看配置文件内容
cat ~/.fga.yaml

# 测试配置是否生效
fga store get
```

配置文件应该是 YAML 格式, 确保缩进正确, 不要使用 Tab 键.

---

## 本章小结

通过本章的学习, 开发者已经完成了 OpenFGA 的快速入门, 掌握了从环境搭建到第一个授权检查的完整流程.

我们首先搭建了 OpenFGA 运行环境, 使用 Docker 一键启动服务, 并安装了 fga CLI 工具. 然后创建了第一个 Store 和授权模型, 理解了 Store 作为数据隔离容器的作用, 以及授权模型如何定义系统中的类型和关系. 接着创建了关系元组, 建立了用户和文档之间的实际关系. 最后执行了第一个授权检查, 验证了权限是否正确, 并体验了 OpenFGA 的权限继承机制.

我们还完成了一个完整的文档协作系统示例, 整合了所有学到的知识, 验证了不同角色的权限是否正确区分. 在实际项目中, 开发者会发现这种权限模型设计方式非常灵活, 当业务需求变化时, 只需要修改授权模型, 不需要修改应用代码.

现在, 开发者已经掌握了 OpenFGA 的基本使用方法. 在第 4 章中, 我们将深入学习 OpenFGA 的架构与组件, 了解 OpenFGA 的系统设计、核心组件以及存储后端的配置. 这将帮助开发者更好地理解 OpenFGA 的工作原理, 为后续的高级应用打下坚实的基础. 准备好了吗? 让我们继续深入探索 OpenFGA 的世界.
