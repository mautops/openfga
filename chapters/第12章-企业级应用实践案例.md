# 第 12 章：企业级应用实践案例

通过真实案例学习 OpenFGA 在实际项目中的应用

---

理论再完美，也需要实践来检验。这一章，我会带你看四个真实的应用场景——从多租户 SaaS 平台到微服务架构,从系统迁移到云原生部署。这些都是我在实际项目中遇到过的场景，有成功的经验，也有踩过的坑。

## 12.1 多租户 SaaS 平台授权

企业级 SaaS 平台最核心的需求是什么？租户隔离。一个租户的数据绝对不能被另一个租户看到，这是底线。

### 场景分析

我们要构建一个文档协作平台（类似 Notion），需要支持：

**核心需求**：
- 多个企业客户（租户）共享同一平台
- 租户之间数据完全隔离
- 租户内部支持复杂的权限管理：组织 → 工作空间 → 项目 → 文档
- 支持团队协作和权限继承

**技术挑战**：

传统做法是在每个查询中手动添加租户过滤：

```javascript
// 传统方式 - 容易出错
const documents = await db.query(
  "SELECT * FROM documents WHERE tenant_id = ? AND user_id = ?",
  [tenantId, userId]
);
```

这种方式的问题？太容易遗漏租户过滤条件了。我见过不止一次因为忘记加 `tenant_id` 导致的数据泄露事故。

### 模型设计

OpenFGA 的优势在于可以在模型层面保证租户隔离。关键设计思路：

**1. 建立关系链**

每个资源都通过关系链追溯到组织（租户）：
```
document → project → workspace → organization
```

**2. 权限定义中强制验证租户成员**

```openfga
type document
  relations
    define project: [project]
    define organization: [project#organization]
    define owner: [user]
    define editor: [user] or owner

    # 关键：每个权限都验证组织成员
    define can_view: viewer and organization#member
    define can_edit: editor and organization#member
```

这个 `and organization#member` 是关键——无论用户有什么权限，都必须是组织成员才能访问。这在模型层面保证了租户隔离，不需要在代码中手动检查。

> **实践经验**：我第一次设计多租户模型时，忘记在所有权限定义中加 `organization#member` 验证。结果在测试时发现，如果用户知道其他租户的文档 ID，就能直接访问。幸好在上线前发现了这个问题。所以，租户隔离验证一定要在模型层面强制执行！

**完整模型示例**：参考 [文档协作模型](../models/05.08.document-collaboration/)

### 实现要点

**租户初始化**：

当新租户注册时，创建组织并设置管理员：

```javascript
await fgaClient.write({
  writes: [
    { user: `user:${adminId}`, relation: "admin", object: `organization:${orgId}` },
    { user: `user:${adminId}`, relation: "member", object: `organization:${orgId}` }
  ]
});
```

**创建资源时建立关系链**：

```javascript
// 创建文档时
await fgaClient.write({
  writes: [
    { user: `project:${projectId}`, relation: "project", object: `document:${docId}` },
    { user: `user:${userId}`, relation: "owner", object: `document:${docId}` }
  ]
});
```

关系链会自动追溯：`document` → `project` → `workspace` → `organization`

**权限检查自动验证租户**：

```javascript
const { allowed } = await fgaClient.check({
  user: `user:${userId}`,
  relation: "can_view",
  object: `document:${docId}`
});
```

OpenFGA 会自动验证用户是否是组织成员，不需要手动传递 `tenant_id`。

**完整集成示例**：参考 [Node.js SDK 集成](../integrates/02.nodejs-sdk-basic/)

### 关键经验

**1. 租户隔离是最高优先级**

在多租户系统中，租户隔离比性能更重要。宁可慢一点，也不能让数据泄露。

**2. 关系链设计要合理**

- 确保每个资源都能追溯到租户
- 避免过深的层级（影响性能）
- 考虑权限继承的语义是否合理

**3. 性能优化策略**

- 使用批量检查 API
- 合理配置缓存（我们的缓存命中率达到 85%）
- 使用上下文元组减少关系元组数量

> **踩坑经验**：我们最初没有使用批量检查，结果在列表页面加载时，每个文档都要单独检查权限，导致页面加载时间超过 3 秒。改用批量检查后，加载时间降到了 300ms。

## 12.2 微服务架构的集中式授权

微服务架构的一个痛点：每个服务都要实现自己的授权逻辑，导致代码重复、逻辑不一致。OpenFGA 可以作为集中式授权服务，解决这个问题。

### 场景分析

假设我们有一个电商平台，包含多个微服务：
- 用户服务、商品服务、订单服务、支付服务、通知服务

**传统方式的问题**：

每个服务都要实现授权逻辑：

```javascript
// 商品服务中的授权逻辑
async function getProduct(productId, userId) {
  const user = await userService.getUser(userId);
  if (user.role !== "admin" && user.role !== "seller") {
    throw new Error("无权访问");
  }
  return await db.getProduct(productId);
}
```

这种方式导致：
- 授权逻辑分散，难以统一管理
- 不同服务可能实现不一致
- 修改授权策略需要改多个服务

### 架构设计

**集中式授权架构**：

所有微服务通过 OpenFGA SDK 进行权限检查，授权逻辑集中在 OpenFGA 中。

```
API 网关 → 微服务 → OpenFGA 授权服务 → PostgreSQL
```

**优势**：
- 统一管理：所有授权逻辑在一个地方
- 一致性保证：所有服务使用相同的授权模型
- 易于扩展：新服务只需集成 SDK

**授权模型设计**：

```openfga
type product
  relations
    define owner: [user]
    define seller: [seller_role#member]

    define can_view: viewer or seller or admin_role#member
    define can_edit: owner or seller or admin_role#member
    define can_delete: owner or admin_role#member

type order
  relations
    define buyer: [user]
    define seller: [user]
    define product: [product]

    define can_view: buyer or seller or admin_role#member
    define can_cancel: buyer
    define can_process: seller or admin_role#member
```

**完整模型示例**：参考 [电商平台模型](../models/05.09.ecommerce/)

### 实现要点

**在微服务中集成 OpenFGA**：

```javascript
// 权限检查中间件
async function checkPermission(req, res, next) {
  const userId = req.user.id;
  const { productId } = req.params;
  const action = req.method === "GET" ? "can_view" : "can_edit";

  const { allowed } = await fgaClient.check({
    user: `user:${userId}`,
    relation: action,
    object: `product:${productId}`
  });

  if (!allowed) {
    return res.status(403).json({ error: "无权访问" });
  }
  next();
}

// 使用中间件
app.get("/api/products/:productId", checkPermission, async (req, res) => {
  const product = await db.getProduct(req.params.productId);
  res.json(product);
});
```

**跨服务权限检查**：

订单服务需要检查用户是否有权限购买商品：

```javascript
// 创建订单时检查商品权限
const { allowed } = await fgaClient.check({
  user: `user:${userId}`,
  relation: "can_view",
  object: `product:${productId}`
});

if (!allowed) {
  return res.status(403).json({ error: "无权购买此商品" });
}
```

**完整集成示例**：参考 [Go 微服务集成](../integrates/08.go-microservice/)

### 关键经验

**1. 集中式授权简化了架构**

不需要在每个服务中实现授权逻辑，大大减少了代码重复。我们的代码量减少了约 30%。

**2. 服务间解耦**

授权服务的变更不会影响业务服务。我们可以独立升级 OpenFGA，不需要重启业务服务。

**3. 性能优化很重要**

- 在服务层实现权限缓存（5 分钟 TTL）
- 使用批量检查 API
- 对非关键路径使用异步权限检查

> **实践经验**：我们在生产环境中部署了 3 个 OpenFGA 实例，通过负载均衡分发请求。配置了 Redis 缓存后，P99 延迟从 50ms 降到了 10ms。

**4. 错误处理和降级**

当 OpenFGA 不可用时，需要有降级策略：

```javascript
try {
  const { allowed } = await fgaClient.check(...);
  return allowed;
} catch (error) {
  console.error("OpenFGA 不可用，使用降级策略");
  // 降级到本地权限检查或拒绝访问
  return false;
}
```

## 12.3 从传统 RBAC 迁移

很多现有系统已经实现了 RBAC。随着业务复杂度增加，传统 RBAC 可能无法满足需求。如何平滑迁移到 OpenFGA？

### 迁移背景

**现有 RBAC 系统的局限性**：

- 层级关系难以表达（文档 → 项目 → 组织）
- 动态权限困难（"用户可以管理自己的文档"）
- 关系型权限缺失（"用户可以查看其所属团队的所有文档"）

**迁移目标**：

- 保持业务连续性（迁移过程中不影响现有功能）
- 提升灵活性（支持更复杂的权限模型）
- 改善性能（提高权限检查速度）

### 迁移策略：Shadow Mode

Shadow Mode 是最安全的迁移方式。核心思路：

**阶段一：并行运行**
- 现有 RBAC 系统继续作为授权决策的唯一来源
- OpenFGA 并行运行，但结果只用于日志和对比

**阶段二：验证对比**
- 对比 RBAC 和 OpenFGA 的授权结果
- 记录差异并分析原因
- 修复 OpenFGA 模型中的问题

**阶段三：逐步切换**
- 选择低风险功能逐步切换到 OpenFGA
- 继续监控和对比
- 逐步扩大切换范围

**阶段四：完全切换**
- 所有功能切换到 OpenFGA
- 移除旧的 RBAC 代码

### 实现要点

**设计对应的 OpenFGA 模型**：

```openfga
type role
  relations
    define member: [user]

type article
  relations
    define owner: [user]
    define editor: [user] or owner or editor_role#member
    define viewer: [user] or editor or viewer_role#member

    define can_view: viewer or admin_role#member
    define can_edit: editor or admin_role#member
    define can_delete: owner or admin_role#member
```

**实现 Shadow Mode**：

```javascript
async function checkPermissionWithShadow(userId, permission, resourceType, resourceId) {
  // 使用现有 RBAC 系统（主流程）
  const rbacResult = await checkPermissionRBAC(userId, permission, resourceType, resourceId);

  // 并行调用 OpenFGA（不影响决策）
  const fgaResult = await checkPermissionFGA(userId, permission, resourceType, resourceId)
    .catch(err => {
      console.error("OpenFGA 检查失败:", err);
      return null;
    });

  // 记录对比结果
  if (fgaResult !== null && rbacResult !== fgaResult.allowed) {
    console.warn("权限检查结果不一致:", {
      userId, permission, resourceType, resourceId,
      rbac: rbacResult, fga: fgaResult.allowed
    });
  }

  // 返回 RBAC 结果
  return rbacResult;
}
```

**数据迁移**：

```javascript
// 迁移用户角色关联
async function migrateUserRoles() {
  const userRoles = await db.query("SELECT user_id, role_id FROM user_roles");
  const roleMap = await getRoleMap();

  for (const { user_id, role_id } of userRoles) {
    const roleName = roleMap[role_id];
    await fgaClient.write({
      writes: [{
        user: `user:${user_id}`,
        relation: "member",
        object: `role:${roleName}`
      }]
    });
  }
}
```

**逐步切换**：

```javascript
// 使用功能开关控制切换
const USE_FGA = process.env.USE_FGA_FOR_ARTICLE_VIEW === "true";

async function checkPermission(userId, permission, resourceType, resourceId) {
  if (USE_FGA) {
    return await checkPermissionFGA(userId, permission, resourceType, resourceId);
  } else {
    return await checkPermissionRBAC(userId, permission, resourceType, resourceId);
  }
}
```

### 关键经验

**1. Shadow Mode 降低风险**

迁移过程中不影响现有功能，可以逐步验证正确性。发现问题时可以快速回滚。

**2. 充分的测试和验证**

我们写了一个验证脚本，每天自动对比 10000 次权限检查结果。匹配率达到 99.9% 后才开始切换。

**3. 团队培训很重要**

迁移不仅是技术工作，还需要培训团队使用 OpenFGA。我们组织了 3 次培训，确保每个人都理解新的授权模型。

> **踩坑经验**：我们最初没有做充分的验证，直接切换了一个功能。结果发现有些边界情况没有考虑到，导致部分用户无法访问资源。后来我们回滚了，重新验证后才再次切换。所以，验证一定要充分！

## 12.4 云原生应用授权架构

云原生应用需要高可用、可扩展、可观测。如何在 Kubernetes 环境中部署和管理 OpenFGA？

### 场景分析

我们要构建一个云原生的 CI/CD 平台，需要支持：

- 多租户（多个组织使用同一平台）
- 项目隔离（不同项目之间资源隔离）
- 团队协作（团队成员协作开发）
- 资源管理（构建任务、部署环境、代码仓库）

**云原生架构特点**：

- 容器化部署（Kubernetes 编排）
- 微服务架构（服务拆分，独立部署）
- 服务网格（Istio 管理服务间通信）
- 可观测性（Prometheus、Grafana 监控）

### 架构设计

**整体架构**：

```
Ingress Controller
  ↓
OpenFGA Service (3 个 Pod)
  ↓
PostgreSQL (主从复制)
  ↓
Prometheus + Grafana (监控)
```

**授权模型设计**：

```openfga
type organization
  relations
    define member: [user]
    define admin: [user]

type project
  relations
    define organization: [organization]
    define owner: [user]
    define maintainer: [user] or owner
    define developer: [user] or maintainer

    define can_view: developer and organization#member
    define can_edit: developer and organization#member
    define can_manage: maintainer and organization#member

type pipeline
  relations
    define project: [project]
    define organization: [project#organization]
    define owner: [user]

    define can_view: owner or organization#member
    define can_run: owner or organization#member
    define can_cancel: owner or organization#admin
```

**完整模型示例**：参考 [CI/CD 平台模型](../models/05.10.cicd-platform/)

### 实现要点

**使用 Helm 部署 OpenFGA**：

```yaml
# values.yaml
replicaCount: 3

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70

datastore:
  engine: postgres
  uri: postgresql://postgres:password@postgres-service:5432/openfga

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi
```

部署命令：

```bash
helm repo add openfga https://openfga.github.io/helm-charts
helm install openfga openfga/openfga -f values.yaml
```

**配置高可用数据库**：

使用 PostgreSQL 主从复制确保数据可靠性。主库处理写操作，从库处理读操作。

**配置服务网格**：

使用 Istio 实现 mTLS 加密通信：

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: openfga
spec:
  selector:
    matchLabels:
      app: openfga
  mtls:
    mode: STRICT
```

**配置监控告警**：

```yaml
# Prometheus 告警规则
- alert: OpenFGAHighErrorRate
  expr: rate(openfga_http_requests_total{status=~"5.."}[5m]) > 0.1
  for: 5m
  annotations:
    summary: "OpenFGA 错误率过高"

- alert: OpenFGAHighLatency
  expr: histogram_quantile(0.99, rate(openfga_http_request_duration_seconds_bucket[5m])) > 1
  for: 5m
  annotations:
    summary: "OpenFGA 延迟过高"
```

**完整部署配置**：参考 [Go 微服务集成](../integrates/08.go-microservice/deployment/)

### 关键经验

**1. 高可用性设计**

- 多副本部署（至少 3 个 Pod）
- 数据库主从复制
- 配置健康检查和自动恢复

**2. 可扩展性设计**

- 使用 HPA 自动扩缩容
- 读写分离提高数据库性能
- Redis 缓存提高查询性能

**3. 安全性设计**

- mTLS 加密服务间通信
- NetworkPolicy 限制网络访问
- 使用 Secret 管理敏感信息

**4. 可观测性设计**

- 收集所有授权检查日志
- 监控性能指标（延迟、错误率）
- 分布式追踪（Jaeger）

> **实践经验**：我们在生产环境中部署了 3 个 OpenFGA 实例，配置了 HPA。在高峰期，实例数会自动扩展到 8 个。通过 Prometheus 监控，我们发现 P99 延迟稳定在 20ms 以下。

**5. 成本优化**

- 设置合理的资源限制
- 根据负载自动调整资源
- 选择合适的存储类型（SSD vs HDD）

## 本章小结

通过四个实际案例，我们学习了 OpenFGA 在不同场景下的应用：

**案例一：多租户 SaaS 平台**
- 关键：在模型层面保证租户隔离
- 技巧：使用关系链和 `organization#member` 验证
- 经验：租户隔离比性能更重要

**案例二：微服务架构**
- 关键：集中式授权服务
- 技巧：统一管理授权逻辑，服务间解耦
- 经验：配置缓存和降级策略

**案例三：系统迁移**
- 关键：Shadow Mode 降低风险
- 技巧：并行运行、验证对比、逐步切换
- 经验：充分测试和团队培训

**案例四：云原生部署**
- 关键：高可用、可扩展、可观测
- 技巧：Kubernetes + Istio + Prometheus
- 经验：多副本、自动扩缩容、完整监控

**核心经验总结**：

1. **模型设计是关键** - 合理的授权模型是成功的基础
2. **性能优化重要** - 缓存、批量操作、异步处理
3. **安全性优先** - 租户隔离、mTLS 加密、审计日志
4. **可观测性必要** - 监控、日志、追踪
5. **渐进式实施** - 降低风险，逐步优化

在实际项目中，需要根据具体业务场景调整设计方案，不断积累经验，持续改进。

**下一步**：

在下一章中，我们将学习系统集成实践——如何将 OpenFGA 与各种系统和框架集成，包括认证系统、API 网关、消息队列等。

准备好了吗？让我们继续！
