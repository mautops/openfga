# 第 10 章：部署与运维

掌握 OpenFGA 在生产环境中的部署与运维

## 章节概述

生产环境的部署与运维是确保 OpenFGA 授权系统高效、稳定、安全运行的关键环节。本章将介绍生产环境部署的最佳实践，涵盖 Docker、Kubernetes、CI/CD 集成、监控告警、备份恢复等核心主题，帮助读者构建企业级的授权系统基础设施。

**学习目标：**

完成本章学习后，你将能够：

1. 掌握 Docker 和 Kubernetes 等多种生产环境部署方式
2. 配置 Helm Chart 和 Terraform Provider 实现基础设施即代码
3. 集成 GitHub Actions 实现 CI/CD 自动化部署
4. 配置 Prometheus 和 Grafana 实现全面监控
5. 实施日志管理和分析策略
6. 制定备份与恢复方案确保数据安全
7. 掌握故障排查和问题诊断方法
8. 使用 Python SDK 进行运维自动化

**预计字数：** 10000-12000 字

**前置知识要求：**

- 第 3 章：OpenFGA 架构与组件
- 第 7 章：SDK 集成实战
- 基础的 Docker 和 Kubernetes 知识
- 基础的 Python 编程能力

---

## 10.1 生产环境部署概述

生产环境的部署是 OpenFGA 从开发到实际应用的关键转折点。根据官方最佳实践和社区经验，合理的部署策略不仅能确保系统的稳定运行，还能为后续的扩展和维护奠定良好基础。

### 10.1.1 部署架构选择

OpenFGA 作为一个无状态的授权服务，天然适合容器化和云原生部署。根据不同的业务规模和需求，可以选择以下几种部署架构：

#### 单实例部署架构

单实例部署适用于开发测试环境或小规模应用，部署简单但缺乏高可用性。

**架构特点：**

- 单台服务器运行 OpenFGA 实例
- 数据库可以是单实例或主从复制
- 部署成本低，运维简单
- 存在单点故障风险

**适用场景：**

- 开发和测试环境
- 小规模生产应用（QPS < 100）
- 对可用性要求不高的场景
- 快速原型验证

**使用 Docker Compose 部署示例：**

```yaml
# docker-compose.yml
version: "3.8"
services:
  openfga:
    image: openfga/openfga:latest
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://fga:password@postgres:5432/fga
      - OPENFGA_LOG_FORMAT=json
      - OPENFGA_LOG_LEVEL=info
      - OPENFGA_PLAYGROUND_ENABLED=false
      - OPENFGA_METRICS_ENABLED=true
    ports:
      - "8080:8080"
      - "2112:2112" # 指标端口
    depends_on:
      - postgres

  postgres:
    image: postgres:17
    environment:
      - POSTGRES_USER=fga
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=fga
    volumes:
      - postgres_data:/var/lib/postgresql/data
```

#### 高可用部署架构

高可用部署通过多实例、负载均衡和数据库集群确保系统的高可用性。

**架构组成：**

1. **OpenFGA 服务层**：多个 OpenFGA 实例，通过负载均衡器分发流量
2. **数据库层**：主从复制或集群模式，保证数据冗余
3. **负载均衡器**：分发请求并实现健康检查
4. **监控和日志**：集中式监控和日志收集

**架构图：**

```mermaid
graph TB
    LB[负载均衡器<br/>Nginx/HAProxy]
    FGA1[OpenFGA实例1]
    FGA2[OpenFGA实例2]
    FGA3[OpenFGA实例3]
    PG_MASTER[(PostgreSQL主节点)]
    PG_REPLICA[(PostgreSQL从节点)]
    MONITOR[监控系统]

    LB --> FGA1
    LB --> FGA2
    LB --> FGA3
    FGA1 --> PG_MASTER
    FGA2 --> PG_MASTER
    FGA3 --> PG_MASTER
    PG_MASTER --> PG_REPLICA
    FGA1 --> MONITOR
    FGA2 --> MONITOR
    FGA3 --> MONITOR
```

**高可用部署配置：**

```yaml
# 使用 Kubernetes Deployment 部署多个实例
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openfga
spec:
  replicas: 3
  selector:
    matchLabels:
      app: openfga
  template:
    metadata:
      labels:
        app: openfga
    spec:
      containers:
        - name: openfga
          image: openfga/openfga:latest
          env:
            - name: OPENFGA_DATASTORE_ENGINE
              value: "postgres"
            - name: OPENFGA_DATASTORE_URI
              valueFrom:
                secretKeyRef:
                  name: openfga-secrets
                  key: datastore-uri
            - name: OPENFGA_LOG_FORMAT
              value: "json"
            - name: OPENFGA_LOG_LEVEL
              value: "info"
            - name: OPENFGA_PLAYGROUND_ENABLED
              value: "false"
            - name: OPENFGA_METRICS_ENABLED
              value: "true"
          ports:
            - containerPort: 8080
            - containerPort: 2112
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "2000m"
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
```

#### 数据库连接池配置

在高并发场景下，合理配置数据库连接池至关重要。根据官方推荐：

```yaml
# 数据库连接池配置
environment:
  # 设置最大打开连接数，应与数据库的最大连接数匹配
  # 如果有多个 OpenFGA 实例，需要将数据库最大连接数平均分配
  - OPENFGA_DATASTORE_MAX_OPEN_CONNS=50

  # 设置最大空闲连接数，不应超过 MAX_OPEN_CONNS
  - OPENFGA_DATASTORE_MAX_IDLE_CONNS=25

  # 设置空闲连接的最大存活时间
  # 如果空闲连接频繁被回收，可以增加这个值以提高性能
  - OPENFGA_DATASTORE_CONN_MAX_IDLE_TIME=10m
```

**配置建议：**

- 如果运行多个 OpenFGA 实例，将数据库的 `max_connections` 平均分配给各实例
- `MAX_IDLE_CONNS` 应小于 `MAX_OPEN_CONNS`，避免频繁创建连接
- 如果观察到空闲连接频繁被回收，增加 `CONN_MAX_IDLE_TIME` 值

#### 集群部署建议

根据官方最佳实践，生产环境建议使用少量大容量服务器，而非大量小容量服务器：

**推荐配置：**

- **服务器数量**：3-5 个实例
- **内存**：每个实例 8-16 GB（取决于缓存配置）
- **CPU**：每个实例 4-8 核
- **优势**：提高缓存命中率，简化管理，降低成本

**不推荐配置：**

- 大量小容量服务器（如 10+ 个 2GB 内存实例）
- **劣势**：缓存命中率低，管理复杂，资源浪费

### 11.1.2 部署流程

生产环境的部署流程应遵循标准化、自动化和可回滚的原则，确保部署过程的安全性和可靠性。

#### 部署前准备

**1. 环境检查清单**

在进行生产部署前，需要完成以下检查：

```bash
#!/bin/bash
# 部署前检查脚本

echo "=== OpenFGA 生产部署检查 ==="

# 1. 检查系统资源
echo "检查系统资源..."
free -h
df -h
nproc

# 2. 检查数据库连接
echo "检查数据库连接..."
psql $DATABASE_URI -c "SELECT version();"

# 3. 检查端口占用
echo "检查端口占用..."
netstat -tuln | grep -E '(8080|2112)'

# 4. 检查 Docker/Kubernetes 环境
echo "检查容器环境..."
docker version || kubectl version --client

# 5. 检查配置文件
echo "检查配置文件..."
if [ -f "config.yaml" ]; then
    echo "配置文件存在"
    # 验证 YAML 格式
    python3 -c "import yaml; yaml.safe_load(open('config.yaml'))" && echo "配置格式正确"
else
    echo "警告: 配置文件不存在"
    exit 1
fi

echo "=== 检查完成 ==="
```

**2. 配置文件准备**

创建生产环境配置文件：

```yaml
# config/production.yaml
log:
  format: json # 生产环境使用 JSON 格式便于日志分析
  level: info # 生产环境使用 info 级别

authn:
  method: preshared
  preshared:
    keys:
      - "${OPENFGA_API_KEY_1}" # 从环境变量或密钥管理系统获取
      - "${OPENFGA_API_KEY_2}"

http:
  tls:
    enabled: true
    cert: /etc/openfga/tls/server.crt
    key: /etc/openfga/tls/server.key

playground:
  enabled: false # 生产环境必须禁用

metrics:
  enabled: true
  addr: 0.0.0.0:2112
  enableRPCHistograms: true

trace:
  enabled: true
  otlp:
    endpoint: otel-collector:4317
    tls:
      enabled: true
  sampleRatio: 0.3 # 30% 采样率，平衡性能与可观测性

datastore:
  engine: postgres
  uri: "${DATABASE_URI}"
  maxOpenConns: 50
  maxIdleConns: 25
  connMaxIdleTime: 10m
```

#### 部署步骤

**步骤 1：数据库准备**

```bash
# 创建数据库和用户
psql -h $DB_HOST -U postgres <<EOF
CREATE DATABASE openfga_production;
CREATE USER openfga_user WITH PASSWORD '${DB_PASSWORD}';
GRANT ALL PRIVILEGES ON DATABASE openfga_production TO openfga_user;
\q
EOF

# 验证数据库连接
export OPENFGA_DATASTORE_URI="postgres://openfga_user:${DB_PASSWORD}@${DB_HOST}:5432/openfga_production?sslmode=require"
```

**步骤 2：密钥和证书准备**

```bash
# 生成 API 密钥（使用安全随机数生成器）
export OPENFGA_API_KEY=$(openssl rand -hex 32)

# 使用证书管理器（如 cert-manager）或手动配置 TLS 证书
# 确保证书有效且未过期
```

**步骤 3：Docker Compose 部署**

```bash
# 部署 OpenFGA
docker-compose -f docker-compose.production.yml up -d

# 等待服务启动
sleep 30

# 验证健康检查
curl -f http://localhost:8080/healthz || exit 1

# 验证指标端点
curl -f http://localhost:2112/metrics || exit 1
```

**步骤 4：Kubernetes Helm 部署**

```bash
# 添加 Helm 仓库
helm repo add openfga https://openfga.github.io/helm-charts
helm repo update

# 创建命名空间
kubectl create namespace openfga

# 创建密钥
kubectl create secret generic openfga-secrets \
  --from-literal=datastore-uri="$DATABASE_URI" \
  --from-literal=api-key="$OPENFGA_API_KEY" \
  -n openfga

kubectl create secret tls openfga-tls \
  --cert=tls/server.crt \
  --key=tls/server.key \
  -n openfga

# 部署 OpenFGA
helm install openfga openfga/openfga \
  --namespace openfga \
  --set datastore.engine=postgres \
  --set datastore.uriFromSecret.name=openfga-secrets \
  --set datastore.uriFromSecret.key=datastore-uri \
  --set authn.method=preshared \
  --set authn.preshared.keysFromSecret.name=openfga-secrets \
  --set authn.preshared.keysFromSecret.key=api-key \
  --set http.tls.enabled=true \
  --set http.tls.certFromSecret.name=openfga-tls \
  --set playground.enabled=false \
  --set metrics.enabled=true \
  --set log.format=json \
  --set log.level=info \
  --set replicaCount=3

# 验证部署
kubectl rollout status deployment/openfga -n openfga
kubectl get pods -n openfga
```

**步骤 5：部署后验证**

```bash
#!/bin/bash
# 部署后验证脚本

API_URL="https://openfga.example.com"
STORE_ID="your-store-id"

# 1. 健康检查
echo "测试健康检查..."
curl -f "${API_URL}/healthz" || exit 1

# 2. 创建测试 Store
echo "创建测试 Store..."
STORE_RESPONSE=$(curl -s -X POST "${API_URL}/stores" \
  -H "Authorization: Bearer ${OPENFGA_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"name": "deployment-test-store"}')

STORE_ID=$(echo $STORE_RESPONSE | jq -r '.id')
echo "创建的 Store ID: ${STORE_ID}"

# 3. 测试授权模型创建
echo "测试授权模型创建..."
curl -s -X POST "${API_URL}/stores/${STORE_ID}/authorization-models" \
  -H "Authorization: Bearer ${OPENFGA_API_KEY}" \
  -H "Content-Type: application/json" \
  -d @test-model.json

# 4. 清理测试数据
echo "清理测试数据..."
curl -s -X DELETE "${API_URL}/stores/${STORE_ID}" \
  -H "Authorization: Bearer ${OPENFGA_API_KEY}"

echo "部署验证完成！"
```

#### 蓝绿部署策略

对于零停机部署，可以采用蓝绿部署策略：

```yaml
# 蓝绿部署流程
# 1. 部署绿色环境（新版本）
helm install openfga-green openfga/openfga \
  --namespace openfga \
  --set service.labels.version=green \
  --values production-values.yaml

# 2. 验证绿色环境
# 执行完整的健康检查和功能测试

# 3. 切换流量（通过更新负载均衡器配置或 Service selector）
kubectl patch service openfga -n openfga -p '{"spec":{"selector":{"version":"green"}}}'

# 4. 监控一段时间后，删除蓝色环境（旧版本）
helm uninstall openfga-blue -n openfga
```

#### 滚动更新策略

Kubernetes 的滚动更新可以实现零停机更新：

```yaml
# Deployment 配置支持滚动更新
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openfga
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1 # 更新过程中可以超出副本数的最大数量
      maxUnavailable: 0 # 更新过程中不可用副本的最大数量（0表示保证可用性）
  # ... 其他配置
```

**滚动更新最佳实践：**

- 设置 `maxUnavailable: 0` 确保始终有可用实例
- 设置合理的 `maxSurge`，避免资源过载
- 使用健康检查和就绪探针确保新实例正常后才停止旧实例

---

## 10.2 Docker 部署方式

Docker 是部署 OpenFGA 最简单且最常用的方式。OpenFGA 官方提供了完整的 Docker 镜像，支持多种数据库后端。本节将介绍如何使用 Docker 和 Docker Compose 在生产环境中部署 OpenFGA。

### 10.2.1 Docker 快速部署

OpenFGA 官方提供了针对不同数据库后端优化的 Docker 镜像。

#### 基础 Docker 部署

**1. 使用内存存储（仅用于开发测试）：**

```bash
# 拉取最新镜像
docker pull openfga/openfga:latest

# 运行 OpenFGA（使用内存存储）
docker run -d \
  --name openfga \
  -p 8080:8080 \
  -p 8081:8081 \
  -p 3000:3000 \
  openfga/openfga:latest run
```

> **端口说明：**
>
> - 8080：HTTP API
> - 8081：gRPC API
> - 3000：Playground（生产环境必须禁用）

**2. 使用 Python 验证部署：**

```python
"""
OpenFGA Docker 部署验证脚本
功能：检查 OpenFGA 服务健康状态并创建测试 Store
"""

import requests
import sys
from typing import Dict, Any, Optional

class OpenFGADeploymentValidator:
    """OpenFGA 部署验证器"""

    def __init__(self, api_url: str = "http://localhost:8080"):
        self.api_url = api_url
        self.session = requests.Session()
        self.session.headers.update({
            "Content-Type": "application/json"
        })

    def check_health(self) -> bool:
        """
        检查 OpenFGA 服务健康状态

        Returns:
            bool: 服务是否健康
        """
        try:
            response = self.session.get(
                f"{self.api_url}/healthz",
                timeout=5
            )

            if response.status_code == 200:
                health_data = response.json()
                status = health_data.get("status", "UNKNOWN")
                print(f"✓ OpenFGA 服务运行正常")
                print(f"  状态: {status}")
                return status == "SERVING"
            else:
                print(f"✗ 健康检查失败，状态码: {response.status_code}")
                return False

        except requests.exceptions.ConnectionError:
            print(f"✗ 无法连接到 OpenFGA 服务: {self.api_url}")
            return False
        except Exception as e:
            print(f"✗ 健康检查异常: {str(e)}")
            return False

    def create_test_store(self, store_name: str = "test-store") -> Optional[Dict[str, Any]]:
        """
        创建测试 Store

        Args:
            store_name: Store 名称

        Returns:
            Dict: 创建的 Store 信息，失败返回 None
        """
        try:
            response = self.session.post(
                f"{self.api_url}/stores",
                json={"name": store_name},
                timeout=10
            )

            if response.status_code == 201:
                store_data = response.json()
                print(f"✓ 成功创建测试 Store")
                print(f"  Store ID: {store_data.get('id')}")
                print(f"  Store Name: {store_data.get('name')}")
                print(f"  Created At: {store_data.get('created_at')}")
                return store_data
            else:
                print(f"✗ 创建 Store 失败，状态码: {response.status_code}")
                print(f"  响应: {response.text}")
                return None

        except Exception as e:
            print(f"✗ 创建 Store 异常: {str(e)}")
            return None

    def create_simple_model(self, store_id: str) -> Optional[str]:
        """
        创建简单的授权模型

        Args:
            store_id: Store ID

        Returns:
            str: 模型 ID，失败返回 None
        """
        model = {
            "type_definitions": [
                {
                    "type": "user",
                    "relations": {}
                },
                {
                    "type": "document",
                    "relations": {
                        "viewer": {
                            "this": {}
                        }
                    }
                }
            ]
        }

        try:
            response = self.session.post(
                f"{self.api_url}/stores/{store_id}/authorization-models",
                json=model,
                timeout=10
            )

            if response.status_code == 201:
                model_data = response.json()
                model_id = model_data.get("authorization_model_id")
                print(f"✓ 成功创建授权模型")
                print(f"  Model ID: {model_id}")
                return model_id
            else:
                print(f"✗ 创建模型失败，状态码: {response.status_code}")
                return None

        except Exception as e:
            print(f"✗ 创建模型异常: {str(e)}")
            return None

    def validate_deployment(self) -> bool:
        """
        执行完整的部署验证

        Returns:
            bool: 验证是否成功
        """
        print("=" * 60)
        print("OpenFGA Docker 部署验证")
        print("=" * 60)

        # 步骤 1: 健康检查
        print("\n[1/3] 检查服务健康状态...")
        if not self.check_health():
            return False

        # 步骤 2: 创建测试 Store
        print("\n[2/3] 创建测试 Store...")
        store_data = self.create_test_store()
        if not store_data:
            return False

        store_id = store_data.get("id")

        # 步骤 3: 创建授权模型
        print("\n[3/3] 创建授权模型...")
        model_id = self.create_simple_model(store_id)
        if not model_id:
            return False

        print("\n" + "=" * 60)
        print("✓ OpenFGA Docker 部署验证成功！")
        print("=" * 60)
        print(f"\n可以使用以下信息进行测试：")
        print(f"  API URL: {self.api_url}")
        print(f"  Store ID: {store_id}")
        print(f"  Model ID: {model_id}")

        return True


def main():
    """主函数"""
    import argparse

    parser = argparse.ArgumentParser(
        description="验证 OpenFGA Docker 部署"
    )
    parser.add_argument(
        "--api-url",
        default="http://localhost:8080",
        help="OpenFGA API 地址 (默认: http://localhost:8080)"
    )

    args = parser.parse_args()

    validator = OpenFGADeploymentValidator(args.api_url)
    success = validator.validate_deployment()

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
```

> **代码说明：**
>
> 1. **功能说明**：完整的 OpenFGA Docker 部署验证工具，支持健康检查、Store 创建和模型创建
> 2. **关键步骤**：
>    - 使用 requests 库调用 OpenFGA API
>    - 实现健康检查、Store 创建、模型创建的完整流程
>    - 提供详细的错误信息和成功提示
> 3. **注意事项**：
>    - 确保 OpenFGA 服务已启动
>    - 检查网络连接和端口开放
>    - 适当配置超时时间
> 4. **扩展方向**：可添加更多验证步骤，如写入元组、权限检查等
> 5. **实际应用**：用于 CI/CD 流程中的部署验证，确保服务正常启动

**运行验证脚本：**

```bash
# 安装依赖
pip install requests

# 运行验证
python validate_deployment.py

# 指定自定义 API 地址
python validate_deployment.py --api-url http://openfga.example.com:8080
```

### 10.2.2 使用 Docker Compose 部署

Docker Compose 适合管理多容器应用，可以同时部署 OpenFGA 和数据库。

#### 使用 PostgreSQL 部署

**Docker Compose 配置文件：**

```yaml
# docker-compose.yml
version: "3.8"

networks:
  openfga:
    driver: bridge

volumes:
  postgres_data:
    driver: local

services:
  # PostgreSQL 数据库
  postgres:
    image: postgres:17
    container_name: openfga_postgres
    networks:
      - openfga
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=openfga
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # OpenFGA 数据库迁移
  migrate:
    image: openfga/openfga:latest
    container_name: openfga_migrate
    command: migrate
    networks:
      - openfga
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://postgres:password@postgres:5432/openfga?sslmode=disable
    depends_on:
      postgres:
        condition: service_healthy

  # OpenFGA 服务
  openfga:
    image: openfga/openfga:latest
    container_name: openfga
    command: run
    networks:
      - openfga
    ports:
      - "8080:8080" # HTTP API
      - "8081:8081" # gRPC API
      - "2112:2112" # Metrics
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://postgres:password@postgres:5432/openfga?sslmode=disable
      - OPENFGA_LOG_FORMAT=json
      - OPENFGA_LOG_LEVEL=info
      - OPENFGA_PLAYGROUND_ENABLED=false
      - OPENFGA_METRICS_ENABLED=true
      - OPENFGA_METRICS_ADDR=0.0.0.0:2112
    depends_on:
      migrate:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s
```

**启动服务：**

```bash
# 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f openfga

# 停止服务
docker-compose down

# 停止并删除数据
docker-compose down -v
```

#### 生产环境配置优化

**使用环境变量文件（.env）：**

```bash
# .env
POSTGRES_USER=openfga_user
POSTGRES_PASSWORD=your_secure_password_here
POSTGRES_DB=openfga
OPENFGA_API_KEY=your_api_key_here
```

**优化的 docker-compose.yml：**

```yaml
version: "3.8"

networks:
  openfga:
    driver: bridge

volumes:
  postgres_data:
  openfga_backup:

services:
  postgres:
    image: postgres:17
    container_name: openfga_postgres
    networks:
      - openfga
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      # PostgreSQL 性能优化
      - POSTGRES_INITDB_ARGS=--encoding=UTF8 --locale=C
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - openfga_backup:/backup
    command:
      - postgres
      - -c
      - max_connections=100
      - -c
      - shared_buffers=256MB
      - -c
      - effective_cache_size=1GB
      - -c
      - maintenance_work_mem=64MB
      - -c
      - checkpoint_completion_target=0.9
      - -c
      - wal_buffers=16MB
      - -c
      - default_statistics_target=100
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  migrate:
    image: openfga/openfga:latest
    container_name: openfga_migrate
    command: migrate
    networks:
      - openfga
    environment:
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable
    depends_on:
      postgres:
        condition: service_healthy

  openfga:
    image: openfga/openfga:latest
    container_name: openfga
    command: run
    networks:
      - openfga
    ports:
      - "8080:8080"
      - "8081:8081"
      - "2112:2112"
    environment:
      # 数据存储配置
      - OPENFGA_DATASTORE_ENGINE=postgres
      - OPENFGA_DATASTORE_URI=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable
      - OPENFGA_DATASTORE_MAX_OPEN_CONNS=50
      - OPENFGA_DATASTORE_MAX_IDLE_CONNS=25
      - OPENFGA_DATASTORE_CONN_MAX_IDLE_TIME=10m

      # 日志配置
      - OPENFGA_LOG_FORMAT=json
      - OPENFGA_LOG_LEVEL=info

      # 认证配置
      - OPENFGA_AUTHN_METHOD=preshared
      - OPENFGA_AUTHN_PRESHARED_KEYS=${OPENFGA_API_KEY}

      # 功能开关
      - OPENFGA_PLAYGROUND_ENABLED=false

      # 监控配置
      - OPENFGA_METRICS_ENABLED=true
      - OPENFGA_METRICS_ADDR=0.0.0.0:2112
      - OPENFGA_METRICS_ENABLE_RPC_HISTOGRAMS=true

      # 性能配置
      - OPENFGA_MAX_CONCURRENT_READS_FOR_CHECK=100
      - OPENFGA_MAX_CONCURRENT_READS_FOR_LIST_OBJECTS=50
    depends_on:
      migrate:
        condition: service_completed_successfully
    healthcheck:
      test:
        [
          "CMD",
          "wget",
          "--no-verbose",
          "--tries=1",
          "--spider",
          "http://localhost:8080/healthz",
        ]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 30s
    restart: unless-stopped
```

### 10.2.3 使用 Python SDK 管理部署

使用 Python SDK 可以更方便地管理和验证 OpenFGA 部署。

**安装 OpenFGA Python SDK：**

```bash
pip install openfga-sdk
```

**完整的部署管理脚本：**

```python
"""
OpenFGA 部署管理工具
功能：部署验证、健康检查、配置管理
"""

import asyncio
import os
from typing import Dict, Any, Optional
from openfga_sdk import (
    OpenFgaClient,
    ClientConfiguration,
    ClientCredentials
)
from openfga_sdk.exceptions import ApiException

class OpenFGADeploymentManager:
    """OpenFGA 部署管理器"""

    def __init__(
        self,
        api_url: str = "http://localhost:8080",
        api_key: Optional[str] = None
    ):
        """
        初始化部署管理器

        Args:
            api_url: OpenFGA API 地址
            api_key: API 密钥（如果启用认证）
        """
        config = ClientConfiguration(
            api_url=api_url,
            store_id=None,  # 暂不指定 store
        )

        # 如果提供了 API 密钥，配置认证
        if api_key:
            config.credentials = ClientCredentials(
                method="api_token",
                configuration={"token": api_key}
            )

        self.client = OpenFgaClient(config)
        self.api_url = api_url

    async def check_health(self) -> bool:
        """
        检查服务健康状态

        Returns:
            bool: 服务是否健康
        """
        try:
            # OpenFGA SDK 不直接提供健康检查，使用底层API
            import aiohttp
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{self.api_url}/healthz") as response:
                    if response.status == 200:
                        data = await response.json()
                        status = data.get("status", "UNKNOWN")
                        print(f"✓ 服务健康状态: {status}")
                        return status == "SERVING"
                    else:
                        print(f"✗ 健康检查失败: {response.status}")
                        return False
        except Exception as e:
            print(f"✗ 健康检查异常: {e}")
            return False

    async def create_store(self, name: str) -> Optional[str]:
        """
        创建新的 Store

        Args:
            name: Store 名称

        Returns:
            str: Store ID，失败返回 None
        """
        try:
            response = await self.client.create_store({"name": name})
            store_id = response.id
            print(f"✓ 创建 Store 成功")
            print(f"  Store ID: {store_id}")
            print(f"  Store Name: {name}")
            return store_id
        except ApiException as e:
            print(f"✗ 创建 Store 失败: {e}")
            return None

    async def create_authorization_model(
        self,
        store_id: str,
        model: Dict[str, Any]
    ) -> Optional[str]:
        """
        创建授权模型

        Args:
            store_id: Store ID
            model: 模型定义

        Returns:
            str: 模型 ID，失败返回 None
        """
        try:
            # 更新 client 配置以使用指定的 store
            self.client.set_store_id(store_id)

            response = await self.client.write_authorization_model(model)
            model_id = response.authorization_model_id
            print(f"✓ 创建授权模型成功")
            print(f"  Model ID: {model_id}")
            return model_id
        except ApiException as e:
            print(f"✗ 创建授权模型失败: {e}")
            return None

    async def write_tuples(
        self,
        store_id: str,
        model_id: str,
        tuples: list
    ) -> bool:
        """
        写入关系元组

        Args:
            store_id: Store ID
            model_id: 模型 ID
            tuples: 元组列表

        Returns:
            bool: 是否成功
        """
        try:
            self.client.set_store_id(store_id)

            body = {
                "writes": tuples,
                "authorization_model_id": model_id
            }

            await self.client.write(body)
            print(f"✓ 成功写入 {len(tuples)} 个关系元组")
            return True
        except ApiException as e:
            print(f"✗ 写入元组失败: {e}")
            return False

    async def check_permission(
        self,
        store_id: str,
        user: str,
        relation: str,
        object: str
    ) -> bool:
        """
        检查权限

        Args:
            store_id: Store ID
            user: 用户
            relation: 关系
            object: 对象

        Returns:
            bool: 是否有权限
        """
        try:
            self.client.set_store_id(store_id)

            body = {
                "user": user,
                "relation": relation,
                "object": object
            }

            response = await self.client.check(body)
            allowed = response.allowed
            print(f"✓ 权限检查: {'允许' if allowed else '拒绝'}")
            print(f"  User: {user}")
            print(f"  Relation: {relation}")
            print(f"  Object: {object}")
            return allowed
        except ApiException as e:
            print(f"✗ 权限检查失败: {e}")
            return False

    async def validate_deployment(self) -> bool:
        """
        完整的部署验证流程

        Returns:
            bool: 验证是否成功
        """
        print("=" * 70)
        print("OpenFGA 部署验证（使用 Python SDK）")
        print("=" * 70)

        # 1. 健康检查
        print("\n[1/5] 检查服务健康状态...")
        if not await self.check_health():
            return False

        # 2. 创建 Store
        print("\n[2/5] 创建测试 Store...")
        store_id = await self.create_store("deployment-test-store")
        if not store_id:
            return False

        # 3. 创建授权模型
        print("\n[3/5] 创建授权模型...")
        model = {
            "type_definitions": [
                {
                    "type": "user",
                    "relations": {}
                },
                {
                    "type": "document",
                    "relations": {
                        "viewer": {"this": {}},
                        "editor": {
                            "union": {
                                "child": [
                                    {"this": {}},
                                    {"computedUserset": {"relation": "viewer"}}
                                ]
                            }
                        }
                    }
                }
            ]
        }

        model_id = await self.create_authorization_model(store_id, model)
        if not model_id:
            return False

        # 4. 写入测试元组
        print("\n[4/5] 写入测试关系元组...")
        tuples = [
            {
                "user": "user:alice",
                "relation": "editor",
                "object": "document:roadmap"
            },
            {
                "user": "user:bob",
                "relation": "viewer",
                "object": "document:roadmap"
            }
        ]

        if not await self.write_tuples(store_id, model_id, tuples):
            return False

        # 5. 测试权限检查
        print("\n[5/5] 测试权限检查...")

        # Alice 应该是 editor
        alice_check = await self.check_permission(
            store_id,
            "user:alice",
            "editor",
            "document:roadmap"
        )

        # Bob 应该是 viewer
        bob_check = await self.check_permission(
            store_id,
            "user:bob",
            "viewer",
            "document:roadmap"
        )

        if alice_check and bob_check:
            print("\n" + "=" * 70)
            print("✓ OpenFGA 部署验证成功！")
            print("=" * 70)
            print(f"\n部署信息：")
            print(f"  API URL: {self.api_url}")
            print(f"  Store ID: {store_id}")
            print(f"  Model ID: {model_id}")
            return True
        else:
            print("\n" + "=" * 70)
            print("✗ 权限检查测试失败")
            print("=" * 70)
            return False

    async def close(self):
        """关闭客户端连接"""
        await self.client.close()


async def main():
    """主函数"""
    import argparse

    parser = argparse.ArgumentParser(
        description="OpenFGA 部署管理工具"
    )
    parser.add_argument(
        "--api-url",
        default="http://localhost:8080",
        help="OpenFGA API 地址"
    )
    parser.add_argument(
        "--api-key",
        default=None,
        help="API 密钥（可选）"
    )

    args = parser.parse_args()

    # 创建管理器并验证部署
    manager = OpenFGADeploymentManager(args.api_url, args.api_key)

    try:
        success = await manager.validate_deployment()
        return 0 if success else 1
    finally:
        await manager.close()


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    exit(exit_code)
```

> **代码说明：**
>
> 1. **功能说明**：使用官方 Python SDK 的完整部署管理工具
> 2. **关键步骤**：
>    - 使用 OpenFgaClient 进行异步操作
>    - 实现 Store 创建、模型定义、元组写入和权限检查的完整流程
>    - 支持认证配置
> 3. **注意事项**：
>    - 需要 Python 3.7+ 支持 async/await
>    - 正确处理异步资源的关闭
>    - 合理设置超时和重试机制
> 4. **扩展方向**：可添加更多管理功能，如批量操作、监控集成等
> 5. **实际应用**：用于自动化部署流程、CI/CD 集成、运维脚本

**运行管理脚本：**

```bash
# 安装依赖
pip install openfga-sdk aiohttp

# 运行验证（无认证）
python deployment_manager.py

# 运行验证（带认证）
python deployment_manager.py \
  --api-url https://openfga.example.com \
  --api-key your-api-key-here
```

---

## 10.3 Kubernetes 部署（Helm Chart）

Kubernetes 是生产环境部署 OpenFGA 的推荐方式，提供了自动化、可扩展性和高可用性。OpenFGA 官方提供了 Helm Chart，简化了在 Kubernetes 集群中的部署和管理。

### 10.3.1 Helm Chart 部署

OpenFGA 官方维护的 Helm Chart 提供了完整的生产级别部署配置。

#### 安装 Helm Chart

**1. 添加 OpenFGA Helm 仓库：**

```bash
# 添加 Helm 仓库
helm repo add openfga https://openfga.github.io/helm-charts

# 更新仓库
helm repo update

# 查看可用的 Chart 版本
helm search repo openfga
```

**2. 创建命名空间：**

```bash
# 创建 OpenFGA 命名空间
kubectl create namespace openfga

# 或使用 YAML
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Namespace
metadata:
  name: openfga
  labels:
    name: openfga
EOF
```

**3. 创建配置文件（values.yaml）：**

```yaml
# values-production.yaml
# 副本数
replicaCount: 3

# 镜像配置
image:
  repository: openfga/openfga
  tag: "latest"
  pullPolicy: IfNotPresent

# 数据存储配置
datastore:
  engine: postgres
  # 使用 Secret 存储数据库连接信息
  uriFromSecret:
    name: openfga-datastore-secret
    key: uri

# 认证配置
authn:
  method: preshared
  preshared:
    keysFromSecret:
      name: openfga-auth-secret
      key: api-keys

# HTTP 服务配置
http:
  tls:
    enabled: true
    certFromSecret:
      name: openfga-tls
      key: tls.crt
    keyFromSecret:
      name: openfga-tls
      key: tls.key

# Playground 配置（生产环境必须禁用）
playground:
  enabled: false

# 监控配置
metrics:
  enabled: true
  addr: "0.0.0.0:2112"
  enableRPCHistograms: true

# 日志配置
log:
  format: json
  level: info

# 追踪配置
trace:
  enabled: true
  sampleRatio: 0.3
  otlp:
    endpoint: "otel-collector.monitoring.svc.cluster.local:4317"
    tls:
      enabled: true

# 资源限制
resources:
  requests:
    memory: "512Mi"
    cpu: "500m"
  limits:
    memory: "2Gi"
    cpu: "2000m"

# 自动扩缩容
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Pod 中断预算
podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Pod 反亲和性
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - openfga
          topologyKey: kubernetes.io/hostname

# Service 配置
service:
  type: ClusterIP
  ports:
    http: 8080
    grpc: 8081
    metrics: 2112

# Ingress 配置
ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: openfga.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: openfga-tls
      hosts:
        - openfga.example.com
```

**4. 创建 Secret：**

```bash
# 创建数据库连接 Secret
kubectl create secret generic openfga-datastore-secret \
  --from-literal=uri="postgres://user:password@postgres.default.svc.cluster.local:5432/openfga?sslmode=require" \
  -n openfga

# 创建认证密钥 Secret
kubectl create secret generic openfga-auth-secret \
  --from-literal=api-keys="$(openssl rand -hex 32),$(openssl rand -hex 32)" \
  -n openfga

# 创建 TLS Secret（如果不使用 cert-manager）
kubectl create secret tls openfga-tls \
  --cert=path/to/tls.crt \
  --key=path/to/tls.key \
  -n openfga
```

**5. 部署 OpenFGA：**

```bash
# 使用自定义配置部署
helm install openfga openfga/openfga \
  --namespace openfga \
  --values values-production.yaml \
  --wait

# 查看部署状态
helm status openfga -n openfga

# 查看 Pod 状态
kubectl get pods -n openfga

# 查看服务
kubectl get svc -n openfga
```

**6. 验证部署：**

```bash
# 端口转发进行本地测试
kubectl port-forward -n openfga svc/openfga 8080:8080

# 在另一个终端测试
curl http://localhost:8080/healthz
```

### 10.3.2 使用 Python 管理 Kubernetes 部署

使用 Python 的 kubernetes 客户端可以自动化管理 OpenFGA 在 Kubernetes 中的部署。

**安装依赖：**

```bash
pip install kubernetes pyyaml requests
```

**Kubernetes 部署管理脚本：**

```python
"""
OpenFGA Kubernetes 部署管理工具
功能：部署验证、健康检查、资源监控
"""

import time
import sys
from typing import Dict, List, Optional, Any
from kubernetes import client, config
from kubernetes.client.rest import ApiException
import requests
import yaml


class OpenFGAK8sManager:
    """OpenFGA Kubernetes 部署管理器"""

    def __init__(self, namespace: str = "openfga"):
        """
        初始化 Kubernetes 管理器

        Args:
            namespace: Kubernetes 命名空间
        """
        # 加载 Kubernetes 配置
        try:
            config.load_kube_config()
        except:
            # 如果在集群内运行，使用集群配置
            config.load_incluster_config()

        self.namespace = namespace
        self.apps_v1 = client.AppsV1Api()
        self.core_v1 = client.CoreV1Api()
        self.autoscaling_v1 = client.AutoscalingV1Api()
        self.networking_v1 = client.NetworkingV1Api()

    def check_namespace(self) -> bool:
        """
        检查命名空间是否存在

        Returns:
            bool: 命名空间是否存在
        """
        try:
            self.core_v1.read_namespace(self.namespace)
            print(f"✓ 命名空间 '{self.namespace}' 存在")
            return True
        except ApiException as e:
            if e.status == 404:
                print(f"✗ 命名空间 '{self.namespace}' 不存在")
                return False
            raise

    def create_namespace(self) -> bool:
        """
        创建命名空间

        Returns:
            bool: 是否成功
        """
        try:
            namespace = client.V1Namespace(
                metadata=client.V1ObjectMeta(
                    name=self.namespace,
                    labels={"name": self.namespace}
                )
            )
            self.core_v1.create_namespace(namespace)
            print(f"✓ 成功创建命名空间 '{self.namespace}'")
            return True
        except ApiException as e:
            if e.status == 409:
                print(f"! 命名空间 '{self.namespace}' 已存在")
                return True
            print(f"✗ 创建命名空间失败: {e}")
            return False

    def get_deployment_status(self) -> Optional[Dict[str, Any]]:
        """
        获取 Deployment 状态

        Returns:
            Dict: Deployment 状态信息
        """
        try:
            deployment = self.apps_v1.read_namespaced_deployment(
                name="openfga",
                namespace=self.namespace
            )

            status = {
                "name": deployment.metadata.name,
                "replicas": deployment.spec.replicas,
                "ready_replicas": deployment.status.ready_replicas or 0,
                "available_replicas": deployment.status.available_replicas or 0,
                "updated_replicas": deployment.status.updated_replicas or 0,
                "conditions": []
            }

            if deployment.status.conditions:
                for condition in deployment.status.conditions:
                    status["conditions"].append({
                        "type": condition.type,
                        "status": condition.status,
                        "reason": condition.reason,
                        "message": condition.message
                    })

            return status
        except ApiException as e:
            if e.status == 404:
                print(f"✗ Deployment 'openfga' 不存在")
                return None
            print(f"✗ 获取 Deployment 状态失败: {e}")
            return None

    def get_pods(self) -> List[Dict[str, Any]]:
        """
        获取 Pod 列表

        Returns:
            List: Pod 信息列表
        """
        try:
            pods = self.core_v1.list_namespaced_pod(
                namespace=self.namespace,
                label_selector="app.kubernetes.io/name=openfga"
            )

            pod_list = []
            for pod in pods.items:
                pod_info = {
                    "name": pod.metadata.name,
                    "phase": pod.status.phase,
                    "ready": False,
                    "restarts": 0,
                    "node": pod.spec.node_name,
                    "ip": pod.status.pod_ip
                }

                # 检查容器状态
                if pod.status.container_statuses:
                    container = pod.status.container_statuses[0]
                    pod_info["ready"] = container.ready
                    pod_info["restarts"] = container.restart_count

                pod_list.append(pod_info)

            return pod_list
        except ApiException as e:
            print(f"✗ 获取 Pod 列表失败: {e}")
            return []

    def get_service_endpoint(self) -> Optional[str]:
        """
        获取 Service 访问端点

        Returns:
            str: Service 端点 URL
        """
        try:
            service = self.core_v1.read_namespaced_service(
                name="openfga",
                namespace=self.namespace
            )

            service_type = service.spec.type

            if service_type == "ClusterIP":
                # ClusterIP 服务，返回集群内部地址
                cluster_ip = service.spec.cluster_ip
                port = service.spec.ports[0].port
                return f"http://{cluster_ip}:{port}"

            elif service_type == "LoadBalancer":
                # LoadBalancer 服务，获取外部 IP
                if service.status.load_balancer.ingress:
                    ingress = service.status.load_balancer.ingress[0]
                    ip = ingress.ip or ingress.hostname
                    port = service.spec.ports[0].port
                    return f"http://{ip}:{port}"

            return None
        except ApiException as e:
            print(f"✗ 获取 Service 失败: {e}")
            return None

    def check_hpa_status(self) -> Optional[Dict[str, Any]]:
        """
        检查 HPA（水平自动扩缩容）状态

        Returns:
            Dict: HPA 状态信息
        """
        try:
            hpa = self.autoscaling_v1.read_namespaced_horizontal_pod_autoscaler(
                name="openfga",
                namespace=self.namespace
            )

            return {
                "name": hpa.metadata.name,
                "min_replicas": hpa.spec.min_replicas,
                "max_replicas": hpa.spec.max_replicas,
                "current_replicas": hpa.status.current_replicas,
                "desired_replicas": hpa.status.desired_replicas,
                "current_cpu_utilization": hpa.status.current_cpu_utilization_percentage
            }
        except ApiException as e:
            if e.status == 404:
                return None
            print(f"✗ 获取 HPA 状态失败: {e}")
            return None

    def port_forward_and_check_health(self) -> bool:
        """
        通过 port-forward 检查服务健康状态

        Returns:
            bool: 服务是否健康
        """
        # 注意：这里简化了实现，实际使用时可能需要更复杂的 port-forward 逻辑
        # 或者直接在集群内部访问
        endpoint = self.get_service_endpoint()

        if not endpoint:
            print("✗ 无法获取服务端点")
            return False

        try:
            response = requests.get(
                f"{endpoint}/healthz",
                timeout=5
            )

            if response.status_code == 200:
                data = response.json()
                status = data.get("status", "UNKNOWN")
                print(f"✓ 服务健康状态: {status}")
                return status == "SERVING"
            else:
                print(f"✗ 健康检查失败: {response.status_code}")
                return False
        except Exception as e:
            print(f"✗ 健康检查异常: {e}")
            return False

    def print_deployment_summary(self):
        """打印部署摘要"""
        print("=" * 70)
        print("OpenFGA Kubernetes 部署状态")
        print("=" * 70)

        # 检查命名空间
        print("\n[1] 命名空间检查:")
        self.check_namespace()

        # Deployment 状态
        print("\n[2] Deployment 状态:")
        deployment_status = self.get_deployment_status()
        if deployment_status:
            print(f"  名称: {deployment_status['name']}")
            print(f"  期望副本数: {deployment_status['replicas']}")
            print(f"  就绪副本数: {deployment_status['ready_replicas']}")
            print(f"  可用副本数: {deployment_status['available_replicas']}")

            if deployment_status['conditions']:
                print("  状态条件:")
                for condition in deployment_status['conditions']:
                    print(f"    - {condition['type']}: {condition['status']}")
                    if condition['message']:
                        print(f"      {condition['message']}")

        # Pod 列表
        print("\n[3] Pod 状态:")
        pods = self.get_pods()
        if pods:
            for pod in pods:
                ready_str = "✓" if pod['ready'] else "✗"
                print(f"  {ready_str} {pod['name']}")
                print(f"      Phase: {pod['phase']}, Ready: {pod['ready']}, Restarts: {pod['restarts']}")
                print(f"      Node: {pod['node']}, IP: {pod['ip']}")
        else:
            print("  未找到 Pod")

        # HPA 状态
        print("\n[4] HPA 状态:")
        hpa_status = self.check_hpa_status()
        if hpa_status:
            print(f"  名称: {hpa_status['name']}")
            print(f"  副本范围: {hpa_status['min_replicas']}-{hpa_status['max_replicas']}")
            print(f"  当前副本数: {hpa_status['current_replicas']}")
            print(f"  期望副本数: {hpa_status['desired_replicas']}")
            if hpa_status['current_cpu_utilization']:
                print(f"  CPU 使用率: {hpa_status['current_cpu_utilization']}%")
        else:
            print("  HPA 未配置")

        # Service 端点
        print("\n[5] Service 端点:")
        endpoint = self.get_service_endpoint()
        if endpoint:
            print(f"  端点: {endpoint}")
        else:
            print("  无法获取端点")

        print("\n" + "=" * 70)


def main():
    """主函数"""
    import argparse

    parser = argparse.ArgumentParser(
        description="OpenFGA Kubernetes 部署管理工具"
    )
    parser.add_argument(
        "--namespace",
        default="openfga",
        help="Kubernetes 命名空间 (默认: openfga)"
    )
    parser.add_argument(
        "--create-namespace",
        action="store_true",
        help="如果命名空间不存在则创建"
    )

    args = parser.parse_args()

    try:
        manager = OpenFGAK8sManager(args.namespace)

        # 检查并创建命名空间
        if not manager.check_namespace():
            if args.create_namespace:
                if not manager.create_namespace():
                    sys.exit(1)
            else:
                print("使用 --create-namespace 参数来创建命名空间")
                sys.exit(1)

        # 打印部署摘要
        manager.print_deployment_summary()

        sys.exit(0)
    except Exception as e:
        print(f"✗ 错误: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

> **代码说明：**
>
> 1. **功能说明**：使用 Kubernetes Python 客户端管理 OpenFGA 部署
> 2. **关键步骤**：
>    - 使用官方 kubernetes 库访问集群
>    - 检查 Deployment、Pod、Service、HPA 状态
>    - 提供完整的部署状态摘要
> 3. **注意事项**：
>    - 需要正确配置 kubectl 和集群访问权限
>    - 处理集群内和集群外两种运行场景
>    - 合理处理 API 异常
> 4. **扩展方向**：可添加部署、更新、回滚等管理功能
> 5. **实际应用**：用于监控 Kubernetes 中的 OpenFGA 部署状态

**运行管理脚本：**

```bash
# 安装依赖
pip install kubernetes pyyaml requests

# 查看部署状态
python k8s_manager.py --namespace openfga

# 创建命名空间（如果不存在）
python k8s_manager.py --namespace openfga --create-namespace
```

### 10.3.3 生产环境最佳实践

在 Kubernetes 中部署 OpenFGA 时，应遵循以下最佳实践：

**1. 资源配置**

```yaml
# 根据负载合理配置资源
resources:
  requests:
    memory: "1Gi" # 最小内存
    cpu: "1000m" # 最小 CPU
  limits:
    memory: "4Gi" # 最大内存
    cpu: "4000m" # 最大 CPU
```

**2. 健康检查**

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: openfga-network-policy
  namespace: openfga
spec:
  podSelector:
    matchLabels:
      app: openfga
  policyTypes:
    - Ingress
    - Egress
  ingress:
    # 只允许来自负载均衡器的流量
    - from:
        - podSelector:
            matchLabels:
              app: nginx-ingress
      ports:
        - protocol: TCP
          port: 8080
    # 允许监控系统访问指标
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 2112
  egress:
    # 允许访问数据库
    - to:
        - podSelector:
            matchLabels:
              app: postgres
      ports:
        - protocol: TCP
          port: 5432
```

#### 数据库安全配置

**1. 使用加密连接**

```yaml
datastore:
  uri: "postgres://user:password@host:5432/dbname?sslmode=require"
```

**2. 数据库用户权限限制**

```sql
-- 创建只读用户（用于监控和备份）
CREATE USER openfga_readonly WITH PASSWORD 'password';
GRANT CONNECT ON DATABASE openfga TO openfga_readonly;
GRANT USAGE ON SCHEMA public TO openfga_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO openfga_readonly;

-- 创建应用用户（最小权限原则）
CREATE USER openfga_app WITH PASSWORD 'password';
GRANT CONNECT ON DATABASE openfga TO openfga_app;
GRANT USAGE ON SCHEMA public TO openfga_app;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO openfga_app;
```

### 11.2.2 合规性要求

不同行业和地区有不同的合规要求，如 GDPR、SOC 2、HIPAA 等。OpenFGA 部署需要满足相关的合规性要求。

#### 数据保护合规（GDPR）

**1. 数据加密**

- 传输加密：使用 TLS 1.2+ 加密所有网络通信
- 存储加密：数据库使用加密存储（如 PostgreSQL 的透明数据加密）

**2. 数据保留策略**

```sql
-- 定期清理过期数据（示例）
-- 删除 90 天前的关系元组变更日志
DELETE FROM changelog WHERE timestamp < NOW() - INTERVAL '90 days';
```

**3. 数据访问审计**

启用详细的审计日志（见 11.3 节），记录所有数据访问操作。

#### 安全合规（SOC 2）

**1. 访问控制**

- 实施最小权限原则
- 定期审查访问权限
- 使用多因素认证（MFA）

**2. 监控和日志**

- 启用完整的审计日志
- 设置异常访问告警
- 定期审查日志

**3. 变更管理**

- 所有配置变更需经过审批
- 保留变更历史记录
- 实施变更回滚机制

#### 健康信息保护（HIPAA）

如果处理健康信息，需要满足 HIPAA 要求：

**1. 加密要求**

```yaml
# 强制使用 TLS
http:
  tls:
    enabled: true
    minVersion: "1.2"

# 数据库连接加密
datastore:
  uri: "postgres://...?sslmode=require&sslrootcert=/path/to/ca.crt"
```

**2. 访问日志**

所有访问操作必须记录，包括：

- 用户标识
- 访问时间
- 访问的资源
- 访问结果（允许/拒绝）

**3. 数据备份**

- 定期备份（建议每日）
- 加密备份数据
- 异地存储备份

#### 合规性检查清单

```bash
#!/bin/bash
# 合规性检查脚本

echo "=== OpenFGA 合规性检查 ==="

# 1. 检查 TLS 是否启用
echo "检查 TLS..."
if curl -k https://openfga.example.com/healthz 2>&1 | grep -q "SSL"; then
    echo "✓ TLS 已启用"
else
    echo "✗ TLS 未正确配置"
fi

# 2. 检查 Playground 是否禁用
echo "检查 Playground..."
if curl -s https://openfga.example.com/playground 2>&1 | grep -q "404\|403"; then
    echo "✓ Playground 已禁用"
else
    echo "✗ Playground 仍然可访问"
fi

# 3. 检查审计日志是否启用
echo "检查审计日志..."
# 实现具体的检查逻辑

# 4. 检查备份策略
echo "检查备份..."
if [ -f "/backup/latest.dump" ]; then
    echo "✓ 备份文件存在"
else
    echo "✗ 未找到备份文件"
fi

echo "=== 检查完成 ==="
```

---

## 10.3 Kubernetes 部署（Helm Chart）

审计日志是生产环境的重要组成部分，不仅用于故障排查，还用于满足合规性要求和安全审计。本节将介绍如何配置和使用 OpenFGA 的审计日志功能。

### 11.3.1 审计日志配置

#### 日志格式配置

生产环境推荐使用 JSON 格式，便于日志聚合和分析。

```yaml
# config/production.yaml
log:
  format: json # JSON 格式，结构化日志
  level: info # info 级别记录关键操作
```

**JSON 格式日志示例：**

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "level": "info",
  "msg": "Check request",
  "method": "POST",
  "path": "/stores/01HVMMBCMGZNT3SED4Z17ECXCA/check",
  "status_code": 200,
  "duration_ms": 45,
  "user": "user:alice",
  "relation": "viewer",
  "object": "document:report",
  "allowed": true,
  "store_id": "01HVMMBCMGZNT3SED4Z17ECXCA"
}
```

#### 结构化日志字段

OpenFGA 的日志包含以下关键字段：

- **操作类型**：check、write、read、listObjects、listUsers
- **用户标识**：发起请求的用户或应用
- **资源信息**：store_id、object、relation
- **请求结果**：status_code、allowed（对于 check 请求）
- **性能指标**：duration_ms（请求耗时）
- **时间戳**：ISO 8601 格式

#### 日志级别配置

根据不同场景选择合适的日志级别：

```yaml
# 生产环境推荐配置
log:
  level: info  # 记录关键操作和错误

# 调试场景
log:
  level: debug  # 记录详细调试信息（注意性能影响）

# 安全审计场景
log:
  level: info   # 记录所有安全相关操作
```

#### 日志聚合和存储

**1. 使用 Fluentd/Fluent Bit 收集日志**

```yaml
# Fluentd 配置示例
<source>
@type tail
path /var/log/openfga/*.log
pos_file /var/log/fluentd/openfga.pos
tag openfga
<parse>
@type json
time_key timestamp
time_format %Y-%m-%dT%H:%M:%S.%NZ
</parse>
</source>

<match openfga>
@type elasticsearch
host elasticsearch.logging.svc.cluster.local
port 9200
index_name openfga
type_name _doc
logstash_format true
logstash_dateformat %Y.%m.%d
</match>
```

**2. 使用 Loki 收集日志（Kubernetes）**

```yaml
# OpenFGA Deployment 配置日志输出到 stdout
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openfga
spec:
  template:
    spec:
      containers:
        - name: openfga
          # ... 其他配置
          # 日志会自动被 Loki 收集
```

**3. 日志保留策略**

```yaml
# 日志保留配置示例（Elasticsearch）
PUT /_ilm/policy/openfga-logs-policy
{
  "policy": {
    "phases": {
      "hot": {
        "actions": {
          "rollover": {
            "max_size": "50GB",
            "max_age": "7d"
          }
        }
      },
      "warm": {
        "min_age": "7d",
        "actions": {
          "shrink": {
            "number_of_shards": 1
          }
        }
      },
      "delete": {
        "min_age": "90d"
      }
    }
  }
}
```

#### API 访问日志

**HTTP 请求日志格式：**

```json
{
  "timestamp": "2024-01-15T10:30:00Z",
  "method": "POST",
  "path": "/stores/{store_id}/check",
  "status_code": 200,
  "duration_ms": 45,
  "client_ip": "192.168.1.100",
  "user_agent": "OpenFGA-SDK/1.0.0",
  "request_id": "req-123456789"
}
```

**gRPC 请求日志：**

OpenFGA 的 gRPC 请求也会记录类似的日志信息，可通过配置启用 gRPC 日志。

#### 自定义审计日志

对于合规性要求，可能需要记录额外的审计信息。可以通过中间件或代理层添加：

```go
// 自定义审计日志中间件示例（Go）
func auditLogMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()

        // 记录请求信息
        auditLog := map[string]interface{}{
            "timestamp": time.Now().UTC().Format(time.RFC3339),
            "method": r.Method,
            "path": r.URL.Path,
            "client_ip": r.RemoteAddr,
            "user_agent": r.UserAgent(),
            "request_id": r.Header.Get("X-Request-ID"),
        }

        // 记录响应
        ww := &responseWriter{ResponseWriter: w, statusCode: 200}
        next.ServeHTTP(ww, r)

        auditLog["status_code"] = ww.statusCode
        auditLog["duration_ms"] = time.Since(start).Milliseconds()

        // 发送到审计日志系统
        sendToAuditLog(auditLog)
    })
}
```

### 11.3.2 合规性要求

#### 数据访问审计

根据合规要求，需要记录以下操作：

**1. 必须记录的操作：**

- 所有权限检查（Check API）
- 关系元组的创建、更新、删除（Write API）
- 授权模型的创建和更新
- Store 的创建和删除
- 用户和对象列表查询（ListObjects、ListUsers）

**2. 审计日志字段要求：**

```json
{
  "event_type": "check_permission",
  "timestamp": "2024-01-15T10:30:00Z",
  "user": {
    "id": "user:alice",
    "ip": "192.168.1.100",
    "session_id": "sess-123456"
  },
  "resource": {
    "store_id": "01HVMMBCMGZNT3SED4Z17ECXCA",
    "object": "document:report",
    "relation": "viewer"
  },
  "result": {
    "allowed": true,
    "reason": "direct_relation"
  },
  "metadata": {
    "request_id": "req-123456789",
    "duration_ms": 45
  }
}
```

#### GDPR 合规要求

**1. 数据主体权利**

- **访问权**：能够查询特定用户的所有权限关系
- **删除权**：能够删除用户的所有数据
- **更正权**：能够修正错误的权限数据

**查询用户所有关系的脚本：**

```javascript
// 查询特定用户的所有关系
async function getUserAllRelations(userId, storeId) {
  const allTuples = [];
  let continuationToken = null;

  do {
    const response = await fgaClient.read({
      tuple_key: {
        user: userId,
      },
      page_size: 100,
      continuation_token: continuationToken,
    });

    allTuples.push(...response.tuples);
    continuationToken = response.continuation_token;
  } while (continuationToken);

  return allTuples;
}
```

**2. 数据保留期限**

根据 GDPR，需要定义数据保留期限：

```sql
-- 创建数据保留策略
CREATE POLICY data_retention_policy ON changelog
  FOR DELETE
  USING (created_at < NOW() - INTERVAL '2 years');
```

#### SOC 2 合规要求

**1. 访问控制审计**

记录所有管理操作的审计日志：

```json
{
  "event_type": "admin_action",
  "timestamp": "2024-01-15T10:30:00Z",
  "admin_user": "admin:ops-team",
  "action": "create_store",
  "target_resource": {
    "store_id": "01HVMMBCMGZNT3SED4Z17ECXCA",
    "store_name": "production-store"
  },
  "result": "success",
  "ip_address": "10.0.0.50"
}
```

**2. 异常访问检测**

```javascript
// 检测异常访问模式
async function detectAnomalousAccess(accessLogs) {
  const anomalies = [];

  // 检测：短时间内大量失败请求
  const recentFailures = accessLogs.filter(
    (log) => log.status_code >= 400 && log.timestamp > Date.now() - 3600000 // 最近1小时
  );

  if (recentFailures.length > 100) {
    anomalies.push({
      type: "high_failure_rate",
      count: recentFailures.length,
      time_window: "1 hour",
    });
  }

  // 检测：非正常时间访问
  const offHoursAccess = accessLogs.filter((log) => {
    const hour = new Date(log.timestamp).getHours();
    return hour < 6 || hour > 22; // 非工作时间
  });

  if (offHoursAccess.length > accessLogs.length * 0.1) {
    anomalies.push({
      type: "off_hours_access",
      percentage: ((offHoursAccess.length / accessLogs.length) * 100).toFixed(
        2
      ),
    });
  }

  return anomalies;
}
```

#### 日志安全保护

**1. 日志加密**

确保日志传输和存储加密：

```yaml
# Fluentd 配置 TLS
<match openfga>
@type elasticsearch
host elasticsearch.logging.svc.cluster.local
port 9200
scheme https
ssl_verify true
ssl_version TLSv1_2
user elastic
password ${ELASTIC_PASSWORD}
</match>
```

**2. 日志访问控制**

限制日志访问权限：

```yaml
# Elasticsearch 角色配置
PUT /_security/role/logs_auditor
{
  "indices": [
    {
      "names": ["openfga-*"],
      "privileges": ["read"],
      "query": {
        "bool": {
          "must": [
            {
              "range": {
                "timestamp": {
                  "gte": "now-90d"
                }
              }
            }
          ]
        }
      }
    }
  ]
}
```

#### 审计日志查询和报告

**生成审计报告示例：**

```javascript
// 生成月度审计报告
async function generateMonthlyAuditReport(month, year) {
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0);

  // 查询该月的所有访问日志
  const logs = await queryLogs({
    index: "openfga",
    query: {
      range: {
        timestamp: {
          gte: startDate.toISOString(),
          lte: endDate.toISOString(),
        },
      },
    },
  });

  const report = {
    period: `${year}-${month}`,
    total_requests: logs.length,
    check_requests: logs.filter((l) => l.event_type === "check").length,
    write_operations: logs.filter((l) => l.event_type === "write").length,
    failed_requests: logs.filter((l) => l.status_code >= 400).length,
    unique_users: new Set(logs.map((l) => l.user)).size,
    unique_resources: new Set(logs.map((l) => l.object)).size,
    top_users: getTopUsers(logs, 10),
    security_events: detectSecurityEvents(logs),
  };

  return report;
}
```

---

## 10.4 基础设施即代码（Terraform Provider）

基础设施即代码（Infrastructure as Code, IaC）是现代运维的最佳实践，通过代码管理基础设施配置，实现可重复、可追溯的部署。本节将介绍如何使用 Python 脚本和配置管理工具来自动化 OpenFGA 的部署。

### 10.4.1 IaC 概述与优势

基础设施即代码（IaC）允许通过代码定义和管理基础设施，具有以下优势：

**主要优势：**

1. **可重复性**：确保每次部署都是一致的
2. **版本控制**：所有配置变更都有历史记录
3. **自动化**：减少人工操作，降低错误率
4. **文档化**：代码本身就是最好的文档
5. **团队协作**：多人可以同时维护基础设施代码

**常用 IaC 工具：**

- **Terraform**：跨云平台的 IaC 工具
- **Ansible**：配置管理和自动化工具
- **Pulumi**：使用编程语言定义基础设施
- **Python 脚本**：灵活的自动化方案

### 10.4.2 使用 Python 管理云资源

下面演示如何使用 Python 和 boto3（AWS SDK）自动化部署 OpenFGA 所需的云资源：

```bash
#!/bin/bash
# PostgreSQL 备份脚本

BACKUP_DIR="/backup/openfga"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/openfga_${TIMESTAMP}.sql.gz"

# 创建备份目录
mkdir -p ${BACKUP_DIR}

# 执行备份
PGPASSWORD=${DB_PASSWORD} pg_dump \
  -h ${DB_HOST} \
  -U ${DB_USER} \
  -d ${DB_NAME} \
  --verbose \
  --clean \
  --if-exists \
  --create \
  | gzip > ${BACKUP_FILE}

# 验证备份文件
if [ -f "${BACKUP_FILE}" ] && [ -s "${BACKUP_FILE}" ]; then
    echo "备份成功: ${BACKUP_FILE}"

    # 保留最近 30 天的备份
    find ${BACKUP_DIR} -name "openfga_*.sql.gz" -mtime +30 -delete

    # 上传到云存储（可选）
    # aws s3 cp ${BACKUP_FILE} s3://backup-bucket/openfga/
else
    echo "备份失败！"
    exit 1
fi
```

**2. 使用 pg_dumpall 备份（包含授权模型）**

```bash
# 备份所有数据库（包括系统数据库）
PGPASSWORD=${DB_PASSWORD} pg_dumpall \
  -h ${DB_HOST} \
  -U ${DB_USER} \
  --clean \
  --if-exists \
  | gzip > backup_all_${TIMESTAMP}.sql.gz
```

**3. 连续归档备份（WAL）**

对于大型数据库，可以使用 PostgreSQL 的 WAL 归档进行连续备份：

```sql
-- postgresql.conf 配置
wal_level = replica
archive_mode = on
archive_command = 'cp %p /backup/wal_archive/%f'
```

**4. 物理备份（文件系统快照）**

如果数据库运行在支持快照的存储系统上：

```bash
# AWS EBS 快照示例
aws ec2 create-snapshot \
  --volume-id vol-1234567890abcdef0 \
  --description "OpenFGA daily backup $(date +%Y-%m-%d)"
```

#### 关系元组导出备份

除了数据库备份，还可以导出关系元组作为额外备份：

```javascript
// 导出所有关系元组
async function exportAllTuples(storeId) {
  const allTuples = [];
  let continuationToken = null;

  do {
    const response = await fgaClient.read(
      {
        tuple_key: {},
        page_size: 1000,
        continuation_token: continuationToken,
      },
      {
        storeId: storeId,
      }
    );

    allTuples.push(
      ...response.tuples.map((t) => ({
        user: t.key.user,
        relation: t.key.relation,
        object: t.key.object,
      }))
    );

    continuationToken = response.continuation_token;
  } while (continuationToken);

  // 保存到文件
  const fs = require("fs");
  fs.writeFileSync(
    `backup_tuples_${storeId}_${Date.now()}.json`,
    JSON.stringify(
      {
        store_id: storeId,
        export_date: new Date().toISOString(),
        tuples: allTuples,
      },
      null,
      2
    )
  );

  return allTuples;
}
```

#### 授权模型备份

授权模型也需要单独备份：

```javascript
// 备份授权模型
async function backupAuthorizationModels(storeId) {
  const models = await fgaClient.readAuthorizationModels({
    storeId: storeId,
  });

  const fs = require("fs");
  fs.writeFileSync(
    `backup_models_${storeId}_${Date.now()}.json`,
    JSON.stringify(
      {
        store_id: storeId,
        export_date: new Date().toISOString(),
        models: models.authorization_models,
      },
      null,
      2
    )
  );

  return models;
}
```

#### 备份策略规划

**1. 备份频率**

根据数据变更频率确定备份频率：

```bash
# 每日全量备份（推荐用于生产环境）
0 2 * * * /usr/local/bin/backup-openfga.sh full

# 每小时增量备份（高数据变更场景）
0 * * * * /usr/local/bin/backup-openfga.sh incremental

# 每周完整备份 + 每日增量备份（平衡方案）
0 2 * * 0 /usr/local/bin/backup-openfga.sh full
0 2 * * 1-6 /usr/local/bin/backup-openfga.sh incremental
```

**2. 备份保留策略**

```bash
#!/bin/bash
# 备份保留策略
# - 保留最近 7 天的每日备份
# - 保留最近 4 周的每周备份
# - 保留最近 12 个月的每月备份

BACKUP_DIR="/backup/openfga"

# 删除超过 7 天的每日备份
find ${BACKUP_DIR}/daily -name "*.sql.gz" -mtime +7 -delete

# 保留每月第一天的备份
find ${BACKUP_DIR}/daily -name "*.sql.gz" -daystart -mtime +30 \
  ! -name "*_01_*.sql.gz" -delete

# 删除超过 12 个月的备份
find ${BACKUP_DIR}/monthly -name "*.sql.gz" -mtime +365 -delete
```

**3. 异地备份**

确保备份存储在异地，防止单点故障：

```bash
# 上传到 S3（AWS）
aws s3 cp ${BACKUP_FILE} s3://backup-bucket/openfga/ \
  --storage-class GLACIER_IR  # 使用低成本存储

# 上传到 Azure Blob Storage
az storage blob upload \
  --account-name ${STORAGE_ACCOUNT} \
  --container-name backups \
  --file ${BACKUP_FILE} \
  --name openfga/${BACKUP_FILE}

# 上传到 Google Cloud Storage
gsutil cp ${BACKUP_FILE} gs://backup-bucket/openfga/
```

#### 自动化备份方案

**使用 Kubernetes CronJob：**

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: openfga-backup
  namespace: openfga
spec:
  schedule: "0 2 * * *" # 每天凌晨 2 点
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: backup
              image: postgres:17
              command:
                - /bin/bash
                - -c
                - |
                  PGPASSWORD=${DB_PASSWORD} pg_dump \
                    -h ${DB_HOST} \
                    -U ${DB_USER} \
                    -d ${DB_NAME} \
                    | gzip > /backup/openfga_$(date +%Y%m%d_%H%M%S).sql.gz

                  # 上传到 S3
                  aws s3 cp /backup/*.sql.gz s3://backup-bucket/openfga/
              env:
                - name: DB_HOST
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secret
                      key: host
                - name: DB_USER
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secret
                      key: user
                - name: DB_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: postgres-secret
                      key: password
                - name: DB_NAME
                  value: openfga
                - name: AWS_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: aws-credentials
                      key: access-key-id
                - name: AWS_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: aws-credentials
                      key: secret-access-key
              volumeMounts:
                - name: backup-volume
                  mountPath: /backup
          volumes:
            - name: backup-volume
              persistentVolumeClaim:
                claimName: backup-pvc
          restartPolicy: OnFailure
```

### 11.4.2 恢复流程

#### 数据库恢复

**1. 从 SQL 备份恢复**

```bash
#!/bin/bash
# PostgreSQL 恢复脚本

BACKUP_FILE=$1
DB_NAME="openfga_restored"

if [ -z "$BACKUP_FILE" ]; then
    echo "使用方法: $0 <备份文件>"
    exit 1
fi

# 如果是压缩文件，先解压
if [[ $BACKUP_FILE == *.gz ]]; then
    echo "解压备份文件..."
    gunzip -c ${BACKUP_FILE} > /tmp/backup.sql
    BACKUP_FILE="/tmp/backup.sql"
fi

# 创建新数据库（如果需要）
createdb -h ${DB_HOST} -U postgres ${DB_NAME}

# 恢复数据
psql -h ${DB_HOST} -U ${DB_USER} -d ${DB_NAME} < ${BACKUP_FILE}

echo "恢复完成！"
```

**2. 从 WAL 归档恢复（时间点恢复）**

```bash
# 配置恢复
cat > recovery.conf <<EOF
restore_command = 'cp /backup/wal_archive/%f %p'
recovery_target_time = '2024-01-15 10:30:00'
EOF

# PostgreSQL 会自动从 WAL 归档恢复到指定时间点
```

**3. 从快照恢复（云环境）**

```bash
# AWS EBS 快照恢复
aws ec2 restore-snapshot \
  --snapshot-id snap-1234567890abcdef0 \
  --volume-id vol-newvolumeid
```

#### 关系元组恢复

```javascript
// 从备份文件恢复关系元组
async function restoreTuples(backupFile, storeId) {
  const fs = require("fs");
  const backup = JSON.parse(fs.readFileSync(backupFile, "utf-8"));

  // 批量写入关系元组
  const batchSize = 100;
  for (let i = 0; i < backup.tuples.length; i += batchSize) {
    const batch = backup.tuples.slice(i, i + batchSize);

    await fgaClient.write(
      {
        writes: batch.map((t) => ({
          user: t.user,
          relation: t.relation,
          object: t.object,
        })),
      },
      {
        storeId: storeId,
        authorizationModelId: backup.model_id,
      }
    );

    console.log(
      `已恢复 ${Math.min(i + batchSize, backup.tuples.length)}/${
        backup.tuples.length
      } 个关系元组`
    );
  }
}
```

#### 授权模型恢复

```javascript
// 恢复授权模型
async function restoreAuthorizationModel(backupFile, storeId) {
  const fs = require("fs");
  const backup = JSON.parse(fs.readFileSync(backupFile, "utf-8"));

  // 获取最新的模型定义
  const latestModel = backup.models[backup.models.length - 1];

  // 创建授权模型
  const response = await fgaClient.writeAuthorizationModel(
    {
      type_definitions: latestModel.type_definitions,
      schema_version: latestModel.schema_version,
    },
    {
      storeId: storeId,
    }
  );

  console.log(`授权模型已恢复，新模型 ID: ${response.authorization_model_id}`);
  return response;
}
```

#### 灾难恢复演练

定期进行灾难恢复演练，确保恢复流程的有效性：

```bash
#!/bin/bash
# 灾难恢复演练脚本

echo "=== OpenFGA 灾难恢复演练 ==="

# 1. 创建测试环境
echo "创建测试环境..."
kubectl create namespace openfga-dr-test

# 2. 选择最近的备份
LATEST_BACKUP=$(ls -t /backup/openfga/*.sql.gz | head -n 1)
echo "使用备份: ${LATEST_BACKUP}"

# 3. 恢复数据库
echo "恢复数据库..."
./restore-database.sh ${LATEST_BACKUP}

# 4. 部署 OpenFGA
echo "部署 OpenFGA..."
helm install openfga-dr-test openfga/openfga \
  --namespace openfga-dr-test \
  --set datastore.uri=${RESTORED_DB_URI}

# 5. 验证恢复结果
echo "验证恢复结果..."
sleep 30
curl -f http://openfga-dr-test.openfga-dr-test.svc.cluster.local:8080/healthz || exit 1

# 6. 运行测试
echo "运行功能测试..."
npm run test:dr

# 7. 清理测试环境
echo "清理测试环境..."
helm uninstall openfga-dr-test -n openfga-dr-test
kubectl delete namespace openfga-dr-test

echo "=== 演练完成 ==="
```

#### 恢复时间目标（RTO）和恢复点目标（RPO）

根据业务需求确定 RTO 和 RPO：

**RTO（Recovery Time Objective）**：系统恢复可用的最大时间

- 关键业务：RTO < 1 小时
- 一般业务：RTO < 4 小时

**RPO（Recovery Point Objective）**：可接受的数据丢失量

- 关键业务：RPO < 15 分钟（需要连续备份）
- 一般业务：RPO < 24 小时（每日备份即可）

---

## 10.5 CI/CD 集成（GitHub Actions）

OpenFGA 的版本升级需要谨慎规划，确保在升级过程中不影响生产服务。本节将介绍版本升级流程和数据迁移策略。

### 11.5.1 版本升级流程

#### 升级前准备

**1. 检查当前版本**

```bash
# 检查当前 OpenFGA 版本
curl -s https://openfga.example.com/version | jq

# 或使用 CLI
fga version
```

**2. 查看发布说明**

访问 OpenFGA 官方 GitHub 仓库，查看目标版本的发布说明和变更日志：

- 新功能
- 破坏性变更（Breaking Changes）
- 弃用功能（Deprecations）
- 已知问题

**3. 升级路径检查**

确认升级路径是否支持：

```
当前版本 -> 目标版本

例如：
v1.3.0 -> v1.4.0  ✓ 支持
v1.3.0 -> v1.5.0  ✓ 支持（跳过中间版本）
v1.3.0 -> v2.0.0  ⚠️ 需检查是否有破坏性变更
```

**4. 备份数据**

升级前必须备份所有数据（见 11.4 节）：

```bash
# 备份数据库
./backup-database.sh

# 导出关系元组
./export-tuples.sh

# 备份授权模型
./backup-models.sh
```

#### 升级步骤

**步骤 1：在测试环境验证**

```bash
# 1. 部署测试环境
kubectl create namespace openfga-test

# 2. 恢复生产数据到测试环境
./restore-to-test.sh

# 3. 升级测试环境
helm upgrade openfga-test openfga/openfga \
  --namespace openfga-test \
  --set image.tag=v1.4.0 \
  --reuse-values

# 4. 运行完整测试套件
npm run test:integration

# 5. 验证功能
./verify-upgrade.sh
```

**步骤 2：生产环境滚动升级**

**使用 Kubernetes Rolling Update：**

```yaml
# 更新 Deployment 镜像版本
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openfga
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0 # 确保始终有可用实例
  template:
    spec:
      containers:
      - name: openfga
          image: openfga/openfga:v1.4.0 # 新版本
        # ... 其他配置保持不变
```

```bash
# 执行升级
kubectl set image deployment/openfga \
  openfga=openfga/openfga:v1.4.0 \
  -n openfga

# 监控升级过程
kubectl rollout status deployment/openfga -n openfga

# 查看 Pod 状态
kubectl get pods -n openfga -w
```

**步骤 3：数据库迁移（如需要）**

如果新版本包含数据库 schema 变更，OpenFGA 会自动执行迁移：

```bash
# OpenFGA 启动时会自动检测并执行数据库迁移
# 监控日志确认迁移完成
kubectl logs -f deployment/openfga -n openfga | grep -i migrate
```

**步骤 4：验证升级**

```bash
#!/bin/bash
# 升级验证脚本

echo "=== OpenFGA 升级验证 ==="

# 1. 检查版本
VERSION=$(curl -s https://openfga.example.com/version | jq -r '.version')
echo "当前版本: ${VERSION}"
if [ "${VERSION}" != "v1.4.0" ]; then
    echo "警告: 版本不匹配"
    exit 1
fi

# 2. 健康检查
curl -f https://openfga.example.com/healthz || exit 1

# 3. API 功能测试
STORE_ID=$(curl -s -X POST https://openfga.example.com/stores \
  -H "Authorization: Bearer ${API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"name":"upgrade-test"}' | jq -r '.id')

# 4. 权限检查测试
curl -s -X POST "https://openfga.example.com/stores/${STORE_ID}/check" \
  -H "Authorization: Bearer ${API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "user": "user:test",
    "relation": "viewer",
    "object": "document:test"
  }' | jq

# 5. 清理测试数据
curl -s -X DELETE "https://openfga.example.com/stores/${STORE_ID}" \
  -H "Authorization: Bearer ${API_KEY}"

echo "=== 验证完成 ==="
```

**步骤 5：回滚计划（如果需要）**

如果升级后出现问题，立即回滚：

```bash
# Kubernetes 回滚
kubectl rollout undo deployment/openfga -n openfga

# 或回滚到指定版本
kubectl rollout undo deployment/openfga \
  --to-revision=2 \
  -n openfga

# 验证回滚
kubectl rollout status deployment/openfga -n openfga
```

#### 零停机升级策略

**蓝绿部署升级：**

```bash
# 1. 部署绿色环境（新版本）
helm install openfga-green openfga/openfga \
  --namespace openfga \
  --set image.tag=v1.4.0 \
  --set service.labels.version=green

# 2. 验证绿色环境
./verify-green-environment.sh

# 3. 切换流量到绿色环境
kubectl patch service openfga -n openfga -p '{
  "spec": {
    "selector": {
      "version": "green"
    }
  }
}'

# 4. 监控一段时间（建议 24-48 小时）

# 5. 删除蓝色环境（旧版本）
helm uninstall openfga-blue -n openfga
```

### 11.5.2 数据迁移

#### 跨版本数据兼容性

OpenFGA 保证向后兼容，但某些版本可能包含 schema 变更：

**1. 检查兼容性**

```bash
# 运行兼容性检查工具
fga migrate check \
  --from-version v1.3.0 \
  --to-version v1.4.0 \
  --datastore-uri ${DATABASE_URI}
```

**2. 自动迁移**

OpenFGA 启动时自动检测并执行必要的数据库迁移：

```bash
# 查看迁移日志
kubectl logs deployment/openfga -n openfga | grep -i migration
```

#### Store 迁移

**在不同 OpenFGA 实例间迁移 Store：**

```javascript
// 完整 Store 迁移脚本
async function migrateStore(sourceClient, targetClient, storeId) {
  console.log(`开始迁移 Store: ${storeId}`);

  // 1. 导出授权模型
  const models = await sourceClient.readAuthorizationModels({
    storeId: storeId,
  });
  const latestModel =
    models.authorization_models[models.authorization_models.length - 1];

  // 2. 创建目标 Store
  const targetStore = await targetClient.createStore({
    name: `Migrated: ${storeId}`,
  });
  const targetStoreId = targetStore.id;

  // 3. 创建授权模型
  const newModel = await targetClient.writeAuthorizationModel(
    {
      type_definitions: latestModel.type_definitions,
      schema_version: latestModel.schema_version,
    },
    {
      storeId: targetStoreId,
    }
  );

  // 4. 导出所有关系元组
  const tuples = await exportAllTuples(sourceClient, storeId);

  // 5. 导入关系元组
  await importTuples(
    targetClient,
    targetStoreId,
    newModel.authorization_model_id,
    tuples
  );

  console.log(`迁移完成: ${storeId} -> ${targetStoreId}`);
  return targetStoreId;
}

async function exportAllTuples(client, storeId) {
  const allTuples = [];
  let continuationToken = null;

  do {
    const response = await client.read(
      {
        tuple_key: {},
        page_size: 1000,
        continuation_token: continuationToken,
      },
      { storeId }
    );

    allTuples.push(
      ...response.tuples.map((t) => ({
        user: t.key.user,
        relation: t.key.relation,
        object: t.key.object,
      }))
    );

    continuationToken = response.continuation_token;
  } while (continuationToken);

  return allTuples;
}

async function importTuples(client, storeId, modelId, tuples) {
  const batchSize = 100;

  for (let i = 0; i < tuples.length; i += batchSize) {
    const batch = tuples.slice(i, i + batchSize);

    await client.write(
      {
        writes: batch,
      },
      {
        storeId: storeId,
        authorizationModelId: modelId,
      }
    );

    console.log(
      `已导入 ${Math.min(i + batchSize, tuples.length)}/${
        tuples.length
      } 个关系元组`
    );
  }
}
```

#### 数据库迁移

**从 SQLite 迁移到 PostgreSQL：**

```bash
#!/bin/bash
# SQLite 到 PostgreSQL 迁移脚本

SQLITE_DB="openfga.db"
PG_HOST="postgres.example.com"
PG_DB="openfga"

# 1. 导出 SQLite 数据
sqlite3 ${SQLITE_DB} .dump > sqlite_dump.sql

# 2. 转换 SQL 格式（SQLite 到 PostgreSQL）
# 注意：需要手动调整某些 SQL 语法差异

# 3. 导入到 PostgreSQL
psql -h ${PG_HOST} -U postgres -d ${PG_DB} < sqlite_dump.sql

# 4. 验证数据
psql -h ${PG_HOST} -U postgres -d ${PG_DB} -c "SELECT COUNT(*) FROM tuple;"
```

**使用 OpenFGA CLI 迁移：**

```bash
# OpenFGA CLI 提供了迁移工具
fga store migrate \
  --source-datastore-uri "sqlite://openfga.db" \
  --target-datastore-uri "postgres://user:pass@host/db" \
  --store-id ${STORE_ID}
```

#### 版本回滚数据兼容性

如果升级后需要回滚，注意数据兼容性：

**1. 检查回滚兼容性**

```bash
# 某些升级可能包含不可逆的 schema 变更
# 回滚前检查数据是否兼容旧版本
fga migrate check \
  --from-version v1.4.0 \
  --to-version v1.3.0 \
  --datastore-uri ${DATABASE_URI}
```

**2. 备份当前数据**

回滚前再次备份，以防需要恢复到升级后状态。

---

## 10.6 监控与可观测性

Kubernetes 是生产环境部署 OpenFGA 的推荐方式，提供了自动化、可扩展和高可用的部署能力。本节将详细介绍 Kubernetes 环境下的部署最佳实践。

### 11.6.1 部署配置

#### Helm Chart 配置

OpenFGA 提供了官方 Helm Chart，简化 Kubernetes 部署：

**基础 values.yaml：**

```yaml
# values.yaml
replicaCount: 3

image:
  repository: openfga/openfga
  tag: "latest"
  pullPolicy: IfNotPresent

datastore:
  engine: postgres
  uriFromSecret:
    name: openfga-datastore-secret
    key: uri

authn:
  method: preshared
  preshared:
    keysFromSecret:
      name: openfga-auth-secret
      key: api-key

http:
  tls:
    enabled: true
    certFromSecret:
      name: openfga-tls
      key: tls.crt
    keyFromSecret:
      name: openfga-tls
      key: tls.key

playground:
  enabled: false

metrics:
  enabled: true
  addr: "0.0.0.0:2112"

log:
  format: json
  level: info

trace:
  enabled: true
  sampleRatio: 0.3
  otlp:
    endpoint: "otel-collector.monitoring.svc.cluster.local:4317"
    tls:
      enabled: true

resources:
  requests:
    memory: "512Mi"
    cpu: "500m"
  limits:
    memory: "2Gi"
    cpu: "2000m"

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

podDisruptionBudget:
  enabled: true
  minAvailable: 2

nodeSelector: {}
tolerations: []
affinity: {}
```

#### 资源配额配置

**1. 资源请求和限制**

```yaml
resources:
  requests:
    memory: "512Mi" # 最小内存
    cpu: "500m" # 最小 CPU（0.5 核）
  limits:
    memory: "2Gi" # 最大内存
    cpu: "2000m" # 最大 CPU（2 核）
```

**2. 资源配置建议**

根据负载规模调整资源配置：

- **小型部署**（< 1000 QPS）：
  - 内存：512 Mi - 1 Gi
  - CPU：500m - 1000m
- **中型部署**（1000-10000 QPS）：
  - 内存：1 Gi - 4 Gi
  - CPU：1000m - 4000m
- **大型部署**（> 10000 QPS）：
  - 内存：4 Gi - 8 Gi
  - CPU：4000m - 8000m

#### 健康检查配置

```yaml
livenessProbe:
  httpGet:
    path: /healthz
    port: 8080
    scheme: HTTP
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /healthz
    port: 8080
    scheme: HTTP
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
```

#### 服务配置

```yaml
# Service 配置
apiVersion: v1
kind: Service
metadata:
  name: openfga
  namespace: openfga
spec:
  type: ClusterIP
  ports:
    - name: http
      port: 8080
      targetPort: 8080
      protocol: TCP
    - name: metrics
      port: 2112
      targetPort: 2112
      protocol: TCP
  selector:
    app: openfga
```

**使用 Ingress 暴露服务：**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: openfga-ingress
  namespace: openfga
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - openfga.example.com
      secretName: openfga-tls
  rules:
    - host: openfga.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: openfga
                port:
                  number: 8080
```

### 11.6.2 高可用配置

#### Pod 反亲和性配置

确保 Pod 分布在不同的节点上：

```yaml
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - openfga
          topologyKey: kubernetes.io/hostname
```

#### Pod 中断预算（PDB）

```yaml
podDisruptionBudget:
  enabled: true
  minAvailable: 2 # 确保至少有 2 个 Pod 可用
  # 或使用
  # maxUnavailable: 1
```

#### 水平自动扩缩容（HPA）

```yaml
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

  # 自定义指标扩缩容
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "100"
```

#### 数据库高可用

**使用 PostgreSQL 主从复制：**

```yaml
# PostgreSQL 主从配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-config
data:
  POSTGRES_REPLICATION_MODE: "master"
  POSTGRES_REPLICATION_USER: "replicator"
  POSTGRES_REPLICATION_PASSWORD: "${REPLICATION_PASSWORD}"
```

**OpenFGA 连接只读副本：**

```yaml
# 为读取操作使用只读副本
datastore:
  engine: postgres
  uri: "${PRIMARY_DB_URI}" # 写入使用主库
  readUri: "${REPLICA_DB_URI}" # 读取使用从库（如果支持）
```

#### 多区域部署

**1. 跨区域部署配置**

```yaml
# 部署到多个可用区
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app
              operator: In
              values:
                - openfga
        topologyKey: topology.kubernetes.io/zone
```

**2. 区域感知路由**

```yaml
# 使用 Service 的 topologyKeys 实现区域感知
apiVersion: v1
kind: Service
metadata:
  name: openfga
spec:
  topologyKeys:
    - "topology.kubernetes.io/zone"
    - "*"
```

---

## 10.7 日志管理与分析

完善的监控和告警系统是生产环境稳定运行的关键。本节将介绍如何配置 OpenFGA 的监控指标和告警规则。

### 11.7.1 监控指标

#### Prometheus 指标配置

OpenFGA 原生支持 Prometheus 指标：

```yaml
metrics:
  enabled: true
  addr: "0.0.0.0:2112"
  enableRPCHistograms: true # 启用 RPC 延迟直方图
```

**关键指标：**

1. **HTTP 请求指标**

   - `http_requests_total`：总请求数
   - `http_request_duration_seconds`：请求延迟
   - `http_request_size_bytes`：请求大小

2. **授权检查指标**

   - `openfga_check_requests_total`：Check 请求总数
   - `openfga_check_duration_seconds`：Check 延迟
   - `openfga_check_allowed_total`：允许的检查数
   - `openfga_check_denied_total`：拒绝的检查数

3. **关系元组操作指标**

   - `openfga_write_requests_total`：Write 请求总数
   - `openfga_write_duration_seconds`：Write 延迟
   - `openfga_read_requests_total`：Read 请求总数

4. **数据库指标**
   - `datastore_connections_active`：活跃连接数
   - `datastore_connections_idle`：空闲连接数
   - `datastore_query_duration_seconds`：查询延迟

#### Prometheus ServiceMonitor 配置

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: openfga
  namespace: openfga
spec:
  selector:
    matchLabels:
      app: openfga
  endpoints:
    - port: metrics
      interval: 30s
      path: /metrics
```

#### Grafana 仪表板配置

创建 Grafana 仪表板监控 OpenFGA：

```json
{
  "dashboard": {
    "title": "OpenFGA Production Dashboard",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{status}}"
          }
        ]
      },
      {
        "title": "Request Latency (p95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "p95"
          }
        ]
      },
      {
        "title": "Check Success Rate",
        "targets": [
          {
            "expr": "rate(openfga_check_allowed_total[5m]) / rate(openfga_check_requests_total[5m]) * 100",
            "legendFormat": "Success Rate"
          }
        ]
      },
      {
        "title": "Database Connections",
        "targets": [
          {
            "expr": "datastore_connections_active",
            "legendFormat": "Active"
          },
          {
            "expr": "datastore_connections_idle",
            "legendFormat": "Idle"
          }
        ]
      }
    ]
  }
}
```

#### 分布式追踪配置

```yaml
trace:
  enabled: true
  sampleRatio: 0.3 # 30% 采样率
  otlp:
    endpoint: "otel-collector.monitoring.svc.cluster.local:4317"
    tls:
      enabled: true
  serviceName: "openfga"
```

### 11.7.2 告警规则

#### Prometheus 告警规则

```yaml
# alerts.yaml
groups:
  - name: openfga
    interval: 30s
    rules:
      # 高错误率告警
      - alert: HighErrorRate
        expr: |
          rate(http_requests_total{status=~"5.."}[5m]) 
          / rate(http_requests_total[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "OpenFGA 错误率过高"
          description: "错误率超过 5%，当前值为 {{ $value | humanizePercentage }}"

      # 高延迟告警
      - alert: HighLatency
        expr: |
          histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "OpenFGA 延迟过高"
          description: "P95 延迟超过 1 秒，当前值为 {{ $value }}s"

      # 数据库连接数告警
      - alert: DatabaseConnectionExhausted
        expr: |
          datastore_connections_active / datastore_max_open_conns > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "数据库连接数即将耗尽"
          description: "活跃连接数达到最大连接数的 80%"

      # 实例不可用告警
      - alert: InstanceDown
        expr: |
          up{job="openfga"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "OpenFGA 实例不可用"
          description: "实例 {{ $labels.instance }} 已下线超过 1 分钟"

      # Check 操作失败率告警
      - alert: HighCheckFailureRate
        expr: |
          rate(openfga_check_requests_total{status="error"}[5m]) 
          / rate(openfga_check_requests_total[5m]) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "Check 操作失败率过高"
          description: "失败率超过 10%，当前值为 {{ $value | humanizePercentage }}"
```

#### 告警通知配置

**使用 Alertmanager 发送通知：**

```yaml
# alertmanager.yaml
route:
  group_by: ["alertname", "cluster", "service"]
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 12h
  receiver: "default"
  routes:
  - match:
      severity: critical
      receiver: "critical-alerts"
  - match:
      severity: warning
      receiver: "warning-alerts"

receivers:
  - name: "default"
  webhook_configs:
      - url: "http://alerting-service:8080/alerts"

  - name: "critical-alerts"
  slack_configs:
      - api_url: "${SLACK_WEBHOOK_URL}"
        channel: "#ops-critical"
        title: "🚨 Critical Alert"
        text: "{{ range .Alerts }}{{ .Annotations.description }}{{ end }}"

  - name: "warning-alerts"
  email_configs:
      - to: "ops-team@example.com"
        from: "alerts@example.com"
        smarthost: "smtp.example.com:587"
        subject: "OpenFGA Warning Alert"
```

#### 自定义告警脚本

```bash
#!/bin/bash
# 自定义告警检查脚本

API_URL="https://openfga.example.com"
THRESHOLD_ERROR_RATE=0.05
THRESHOLD_LATENCY=1.0

# 检查错误率
ERROR_RATE=$(curl -s "${API_URL}/metrics" | \
  grep 'http_requests_total' | \
  awk '{if ($2 > 100) total+=$2; if ($2 > 100 && $1 ~ /5../) errors+=$2} END {print errors/total}')

if (( $(echo "$ERROR_RATE > $THRESHOLD_ERROR_RATE" | bc -l) )); then
    echo "告警: 错误率 ${ERROR_RATE} 超过阈值 ${THRESHOLD_ERROR_RATE}"
    # 发送告警通知
    send_alert "HighErrorRate" "错误率过高: ${ERROR_RATE}"
fi

# 检查延迟
LATENCY=$(curl -s "${API_URL}/metrics" | \
  grep 'http_request_duration_seconds_bucket' | \
  awk '{...}' | \
  calculate_p95)

if (( $(echo "$LATENCY > $THRESHOLD_LATENCY" | bc -l) )); then
    echo "告警: P95 延迟 ${LATENCY}s 超过阈值 ${THRESHOLD_LATENCY}s"
    send_alert "HighLatency" "延迟过高: ${LATENCY}s"
fi
```

---

## 本章小结

本章深入探讨了 OpenFGA 在生产环境中的部署与运维实践，为读者提供了全面的知识体系和实用指南。

**核心内容回顾：**

首先，我们学习了**生产环境部署策略**。生产环境的部署需要考虑高可用性、可扩展性、安全性和性能等多个维度。我们介绍了单实例部署、高可用部署、以及集群部署等不同的架构模式，并提供了 Docker Compose 和 Kubernetes Helm 两种部署方式的具体配置。根据官方最佳实践，建议使用少量大容量服务器而非大量小容量服务器，以提高缓存命中率和简化管理。

接下来，我们详细介绍了**安全配置与合规性考虑**。安全性是授权系统的生命线，我们讲解了 TLS/HTTPS 配置、认证配置、网络安全、数据库安全等关键安全措施。在生产环境中，必须禁用 Playground、启用 TLS、使用强认证机制。我们还介绍了 GDPR、SOC 2、HIPAA 等不同合规要求下的配置策略。

随后，我们探讨了**审计日志与合规要求**。审计日志不仅是故障排查的工具，更是满足合规性要求的重要手段。我们介绍了如何配置结构化日志、日志聚合和存储、以及如何满足不同合规标准的要求。生产环境应使用 JSON 格式日志，便于日志分析和合规审计。

然后，我们学习了**备份与恢复策略**。合理的备份策略可以确保在数据丢失或系统故障时快速恢复服务。我们介绍了数据库备份、关系元组导出备份、授权模型备份等多种备份方式，并提供了自动化和异地备份的方案。恢复流程包括数据库恢复、关系元组恢复、授权模型恢复等步骤。我们还强调了定期进行灾难恢复演练的重要性。

我们还学习了**版本升级与迁移指南**。版本升级需要谨慎规划，确保不影响生产服务。我们介绍了升级前准备、测试环境验证、生产环境滚动升级、以及回滚策略。对于数据迁移，我们讲解了跨版本兼容性检查、Store 迁移、数据库迁移等方法。

最后，我们详细介绍了**Kubernetes 生产部署最佳实践**和**监控告警配置**。Kubernetes 提供了自动化、可扩展和高可用的部署能力，我们讲解了 Helm Chart 配置、资源配额、健康检查、服务配置、高可用配置（Pod 反亲和性、PDB、HPA）等最佳实践。监控方面，我们介绍了 Prometheus 指标、Grafana 仪表板、分布式追踪的配置，以及各种告警规则的设置。

**关键要点：**

1. **部署架构选择**：根据规模和需求选择合适的部署架构，生产环境推荐高可用架构
2. **安全第一**：生产环境必须启用 TLS、禁用 Playground、使用强认证、配置网络安全
3. **完善的监控**：建立全面的监控和告警系统，及时发现和处理问题
4. **备份策略**：制定合理的备份策略，定期备份并测试恢复流程
5. **升级谨慎**：版本升级前充分测试，制定回滚计划，确保系统稳定性

**实践建议：**

在生产环境中部署 OpenFGA 时，建议：

- 从测试环境开始，逐步推广到生产环境
- 建立完善的文档和操作手册
- 定期进行灾难恢复演练
- 持续监控系统指标，优化配置
- 关注 OpenFGA 社区更新和安全公告

通过本章的学习，读者应该能够：

- 设计和实施生产级别的 OpenFGA 部署架构
- 配置安全措施以满足合规要求
- 建立完善的监控和告警系统
- 制定和执行备份恢复策略
- 安全地进行版本升级和数据迁移

---

## 实践练习

### 基础练习

1. **部署题：单实例部署到生产环境**

   使用 Docker Compose 在生产环境部署 OpenFGA：

   - 配置 PostgreSQL 数据库
   - 启用 TLS 加密
   - 禁用 Playground
   - 配置 JSON 格式日志
   - 启用指标收集
   - 设置适当的资源限制

2. **安全配置题：配置 TLS 和认证**

   为 OpenFGA 配置安全访问：

   - 使用 cert-manager 自动获取和管理 TLS 证书
   - 配置预共享密钥认证（至少 2 个密钥）
   - 配置 Kubernetes NetworkPolicy 限制网络访问
   - 验证 Playground 已禁用

3. **备份与恢复题：实施自动化备份策略**

   创建完整的备份方案：

   - 编写数据库备份脚本（支持压缩和加密）
   - 配置 Kubernetes CronJob 实现每日自动备份
   - 上传备份到云存储（S3/Azure/GCS）
   - 实现备份保留策略（保留 7 天每日备份，4 周每周备份）
   - 编写恢复脚本并测试恢复流程

### 进阶练习

4. **高可用部署题：Kubernetes 生产部署**

   使用 Helm Chart 部署高可用 OpenFGA：

   - 配置 3 个副本
   - 设置 Pod 反亲和性确保分布在不同节点
   - 配置 PodDisruptionBudget（minAvailable: 2）
   - 设置水平自动扩缩容（HPA）
   - 配置 Ingress 和 TLS
   - 验证高可用性（模拟节点故障）

5. **监控告警题：建立完整的监控体系**

   配置 Prometheus 和 Grafana：

   - 配置 ServiceMonitor 收集指标
   - 创建 Grafana 仪表板，包含：
     - 请求速率和延迟（P50、P95、P99）
     - Check API 成功率
     - 数据库连接池状态
     - 错误率趋势
   - 配置 Prometheus 告警规则：
     - 高错误率告警（> 5%）
     - 高延迟告警（P95 > 1s）
     - 实例不可用告警
     - 数据库连接数告警
   - 配置 Alertmanager 发送到 Slack 或邮件

6. **版本升级题：零停机升级实践**

   执行一次生产环境版本升级：

   - 在测试环境验证新版本
   - 备份生产数据
   - 使用蓝绿部署策略升级
   - 验证升级后的功能
   - 制定并测试回滚计划

### 挑战练习

7. **综合题：多区域高可用部署**

   设计并实现跨区域的高可用部署：

   - 在多个可用区（AZ）部署 OpenFGA
   - 配置区域感知路由
   - 实现数据库主从复制（跨区域）
   - 配置监控和告警（跨区域）
   - 设计灾难恢复方案
   - 测试故障转移（模拟单区域故障）

8. **合规性题：满足 GDPR 合规要求**

   实施 GDPR 合规配置：

   - 配置数据加密（传输和存储）
   - 实现数据访问审计日志
   - 编写脚本支持数据主体权利：
     - 访问权：查询用户所有权限关系
     - 删除权：删除用户所有数据
     - 更正权：修正错误权限
   - 实施数据保留策略
   - 生成合规性检查报告

9. **性能优化题：生产环境性能调优**

   针对高负载场景优化配置：

   - 分析当前性能瓶颈
   - 优化数据库连接池配置
   - 配置缓存策略（内存缓存）
   - 调整并发限制参数
   - 优化查询深度和广度限制
   - 实施批量操作优化
   - 验证性能提升效果

---

## 延伸阅读

### 官方文档

- **OpenFGA 官方文档**：[https://openfga.dev/docs](https://openfga.dev/docs)

  - 完整的 API 参考和配置选项

- **生产部署最佳实践**：[https://openfga.dev/docs/best-practices/running-in-production](https://openfga.dev/docs/best-practices/running-in-production)

  - 官方推荐的生产环境配置

- **Helm Charts**：[https://github.com/openfga/helm-charts](https://github.com/openfga/helm-charts)

  - Kubernetes Helm Chart 仓库和使用说明

- **OpenFGA CLI**：[https://github.com/openfga/cli](https://github.com/openfga/cli)
  - 命令行工具文档和示例

### 相关技术文档

- **Kubernetes 官方文档**：[https://kubernetes.io/docs/](https://kubernetes.io/docs/)

  - Kubernetes 部署和管理指南

- **PostgreSQL 高可用**：[https://www.postgresql.org/docs/current/high-availability.html](https://www.postgresql.org/docs/current/high-availability.html)

  - PostgreSQL 高可用配置

- **Prometheus 监控**：[https://prometheus.io/docs/](https://prometheus.io/docs/)

  - Prometheus 监控系统文档

- **Grafana 仪表板**：[https://grafana.com/docs/grafana/latest/](https://grafana.com/docs/grafana/latest/)

  - Grafana 可视化和告警配置

- **cert-manager**：[https://cert-manager.io/docs/](https://cert-manager.io/docs/)
  - Kubernetes TLS 证书管理

### 合规性参考

- **GDPR 合规指南**：[https://gdpr.eu/](https://gdpr.eu/)

  - GDPR 法规和合规要求

- **SOC 2 框架**：[https://www.aicpa.org/interestareas/frc/assuranceadvisoryservices/aicpasoc2report.html](https://www.aicpa.org/interestareas/frc/assuranceadvisoryservices/aicpasoc2report.html)

  - SOC 2 安全合规标准

- **HIPAA 合规**：[https://www.hhs.gov/hipaa/index.html](https://www.hhs.gov/hipaa/index.html)
  - HIPAA 健康信息保护法规

### 社区资源

- **OpenFGA GitHub**：[https://github.com/openfga/openfga](https://github.com/openfga/openfga)

  - 源代码、问题和讨论

- **OpenFGA Discord**：[https://discord.gg/openfga](https://discord.gg/openfga)

  - 社区交流和问题咨询

- **CNCF 项目**：[https://www.cncf.io/projects/openfga/](https://www.cncf.io/projects/openfga/)
  - Cloud Native Computing Foundation 项目信息

### 学习建议

在学习和实践过程中，建议：

1. **从测试环境开始**：在生产环境部署前，先在测试环境充分验证
2. **参考官方示例**：OpenFGA 官方提供了丰富的示例和最佳实践
3. **参与社区讨论**：遇到问题可以到 Discord 或 GitHub 寻求帮助
4. **定期更新**：关注 OpenFGA 版本更新，及时升级以获得新功能和安全补丁
5. **文档维护**：记录自己的部署配置和遇到的问题，形成内部文档
